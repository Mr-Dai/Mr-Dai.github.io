<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java TreeMap 源码解析 - Robert Peng&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="呆呆的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="呆呆的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在本文中，我们将详细解析 java.util.TreeMap 的源代码。本文将首先讲述红黑树及其相关操作的基本原理，并结合 TreeMap 中的相关代码加深印象，继而再对 TreeMap 中的其他代码进行详析。"><meta property="og:type" content="blog"><meta property="og:title" content="Java TreeMap 源码解析"><meta property="og:url" content="https://mr-dai.github.io/java_collection_treemap/"><meta property="og:site_name" content="Robert Peng&#039;s Blog"><meta property="og:description" content="在本文中，我们将详细解析 java.util.TreeMap 的源代码。本文将首先讲述红黑树及其相关操作的基本原理，并结合 TreeMap 中的相关代码加深印象，继而再对 TreeMap 中的其他代码进行详析。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/2-3-4-tree-2-node.svg/190px-2-3-4-tree-2-node.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/2-3-4-tree-3-node.svg/240px-2-3-4-tree-3-node.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/2-3-4-tree-4-node.svg/240px-2-3-4-tree-4-node.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png"><meta property="og:image" content="https://mr-dai.github.io/img/TreeMap@1.jpg"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png"><meta property="og:image" content="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png"><meta property="article:published_time" content="2017-02-26T16:00:00.000Z"><meta property="article:modified_time" content="2017-02-26T16:00:00.000Z"><meta property="article:author" content="Robert Peng"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/2-3-4-tree-2-node.svg/190px-2-3-4-tree-2-node.svg.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-dai.github.io/java_collection_treemap/"},"headline":"Java TreeMap 源码解析","image":["https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/2-3-4-tree-2-node.svg/190px-2-3-4-tree-2-node.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/2-3-4-tree-3-node.svg/240px-2-3-4-tree-3-node.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/2-3-4-tree-4-node.svg/240px-2-3-4-tree-4-node.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png","https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png","https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png","https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png","https://mr-dai.github.io/img/TreeMap@1.jpg","https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png","https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png","https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png","https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png","https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png"],"datePublished":"2017-02-26T16:00:00.000Z","dateModified":"2017-02-26T16:00:00.000Z","author":{"@type":"Person","name":"Robert Peng"},"publisher":{"@type":"Organization","name":"Robert Peng's Blog","logo":{"@type":"ImageObject","url":"https://mr-dai.github.io/img/avatar.png"}},"description":"在本文中，我们将详细解析 java.util.TreeMap 的源代码。本文将首先讲述红黑树及其相关操作的基本原理，并结合 TreeMap 中的相关代码加深印象，继而再对 TreeMap 中的其他代码进行详析。"}</script><link rel="canonical" href="https://mr-dai.github.io/java_collection_treemap/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2017-02-26T16:00:00.000Z" title="2/26/2017, 4:00:00 PM">2017-02-27</time>发表</span><span class="level-item"><time dateTime="2017-02-26T16:00:00.000Z" title="2/26/2017, 4:00:00 PM">2017-02-27</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Java TreeMap 源码解析</h1><div class="content"><p>在本文中，我们将详细解析 <code>java.util.TreeMap</code> 的源代码。本文将首先讲述红黑树及其相关操作的基本原理，并结合 <code>TreeMap</code> 中的相关代码加深印象，继而再对 <code>TreeMap</code> 中的其他代码进行详析。</p>
<span id="more"></span>

<p>为提高可读性，本文中将会在保证功能不变的情况下对 <code>TreeMap</code> 的源代码进行一定的修改，包括修改变量名、新增局部变量、省略重复代码等。</p>
<h2 id="2-3-4-树及红黑树"><a href="#2-3-4-树及红黑树" class="headerlink" title="2-3-4 树及红黑树"></a>2-3-4 树及红黑树</h2><p>首先我们看 <code>java.util.TreeMap</code> 的 JavaDoc 的第一句话：</p>
<blockquote>
<p>A Red-Black tree based <code>NavigableMap</code> implementation.</p>
</blockquote>
<p>由此我们了解到，<code>TreeMap</code> 实现了 <code>java.util.NavigableMap</code> 接口，其本质上的数据结构是红黑树。因此首先我们需要了解什么是红黑树。</p>
<p>红黑树是一种<strong>自平衡</strong>的<strong>二叉搜索树</strong>（Self-balancing Binary Search Tree）。阅读过<a target="_blank" rel="noopener" href="http://algs4.cs.princeton.edu/home/">《Algorithms》</a>一书的读者应该了解，红黑树的思想延伸自 2-3-4 树，它们本质上是等价的，红黑树只是在使用统一的二叉树结点的基础上加上结点的颜色信息来替代 2-3-4 树中特有的 3-结点和 4-结点，而红黑树的相关操作实际上也都一一对应着 2-3-4 树的操作。因此，本文将结合讲解 2-3-4 树的相关操作以加深读者对红黑树的理解。除此之外，2-3-4 树实际上就是一种特殊的 B 树，理解 2-3-4 树对读者后续理解 B 树也大有裨益。</p>
<p>通过阅读 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree">2-3-4 树的维基百科</a>可知，2-3-4 树是一种完美平衡的搜索树，除普通的二叉结点，或 2-结点外，还包含了分别有 3 个和 4 个子结点的 3-结点和 4-结点：</p>
<table>
<thead>
<tr>
<th align="center">2-结点</th>
<th align="center">3-结点</th>
<th align="center">4-结点</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b2/2-3-4-tree-2-node.svg/190px-2-3-4-tree-2-node.svg.png"></td>
<td align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/2-3-4-tree-3-node.svg/240px-2-3-4-tree-3-node.svg.png"></td>
<td align="center"><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/35/2-3-4-tree-4-node.svg/240px-2-3-4-tree-4-node.svg.png"></td>
</tr>
</tbody></table>
<p>而红黑树则是通过为结点间的链接赋予颜色属性来使用二叉结点表示 2-3-4 树。但在计算机语言实现中，难以表示链接（指针）的颜色，因此就将颜色信息储存在了结点中，以表示由父结点指向该结点的链接的颜色。当一个黑色父结点只有一个红色子结点时，这两个结点代表了 2-3-4 树中的一个 3-结点，两个结点的一共 3 个子结点对应 3-结点的 3 个子结点；当一个黑色父结点有两个红色子结点时，这三个节点代表了一个 4-结点，两个子结点的一共 4 个子结点则代表了 4-结点的 4 个子结点。</p>
<p>我们通过阅读<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Red%E2%80%93black_tree">红黑树的维基百科</a>可以了解到，红黑树满足如下性质：</p>
<ol>
<li>每个结点的颜色为红色或黑色</li>
<li>根节点的颜色为黑色</li>
<li>若某个结点的颜色为红色，那么它的两个孩子结点的颜色必为黑色，即不存在两对连续的红色结点</li>
<li>对于任意给定的内部结点，所有从该结点到位于其子树内的叶子结点的路径所经过的黑色结点数相同</li>
</ol>
<p>其中，性质 1 定义了树结点的颜色属性；性质 2 本身意义并不大 —— 实际上根节点的颜色对红黑树的性质影响极小，该性质完全可以被忽略；而性质 3 和 4 则是确保一颗红黑树为平衡二叉搜索树的有力约束，同时红黑树的性质 4 实际上等价于等价 2-3-4 树的完美平衡性。除此之外，我们可以由性质 4 推得，<strong>根节点到最远叶结点的距离不大于由根节点到最近叶结点的距离的两倍</strong>，因此一棵红黑树只是在大致上是平衡的。</p>
<h2 id="平衡树操作-——-查找"><a href="#平衡树操作-——-查找" class="headerlink" title="平衡树操作 —— 查找"></a>平衡树操作 —— 查找</h2><p>对于 2-3-4 树而言，其本质上也是一棵搜索树，在遇到 3-结点和 4-结点时只需要通过键的大小选择合适的子结点继续向下查找即可，思想上与一般的二叉搜索树无异。</p>
<p>对于红黑树来说，不考虑其自平衡的特性，其本身也是一棵二叉搜索树，因此红黑树的查找操作与一般二叉搜索树无异。形式化来说，红黑树的查找操作可如下表述：</p>
<blockquote>
<p>如果树是空的，则查找未命中（返回 <code>null</code>）；如果被查找的键与根结点的键相等，查找命中（返回对应值）；否则就（递归地）在合适的子树中继续查找：如果被查找的键较小就选择左子树，较大则选择右子树。</p>
</blockquote>
<p><code>TreeMap</code> 的 <code>get(K key)</code> 方法实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">return</span> (p == <span class="keyword">null</span> ? <span class="keyword">null</span> : p.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K, V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></span><br><span class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">    Entry&lt;K, V&gt; p = root;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            p = p.left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            p = p.right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K, V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">        K k = (K) key;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; p = root;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                p = p.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                p = p.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除去针对自定义 <code>Comparator</code> 或 <code>Comparable</code> 键的独立实现外，<code>TreeMap#get</code> 方法的实现并无太特别的地方。</p>
<h2 id="平衡树操作-——-插入"><a href="#平衡树操作-——-插入" class="headerlink" title="平衡树操作 —— 插入"></a>平衡树操作 —— 插入</h2><p>自平衡二叉树的自平衡机制在结点数量发生变化时便会被触发，具体来说就是插入结点和删除结点的时候。</p>
<p>2-3-4 树的插入操作可形式化地描述如下：</p>
<blockquote>
<p>首先从 2-3-4 树的根节点递归地向下寻找插入的位置：</p>
<ol>
<li>如果当前结点为一个 4-结点：<ul>
<li>暂存位于 4-结点中间的键值，并将其移除，以将该结点变为一个 3-结点 </li>
<li>将该 3-结点分裂为两个 2-结点 </li>
<li>如果该结点为根节点，那么就用暂存的中间键值创建一个新的 2-结点链接分裂得出的两个 2-结点，并将该新结点作为新的根节点。树的高度增加 1，回到根节点继续递归</li>
<li>否则就将暂存的中间键值插入到父结点（2-结点变 3-结点，3-结点变 4-结点），并由该父结点链接分裂得出的两个 2-结点。树的高度增加 1，回到父节点继续递归</li>
</ul>
</li>
<li>继续查找其区间包含待插入键值的子结点</li>
<li>如果该子结点为叶子结点，便直接将键值插入到该结点中，结束递归<ul>
<li>否则，进入对应的子结点并重复递归</li>
</ul>
</li>
</ol>
</blockquote>
<p>大致的过程可以参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/2%E2%80%933%E2%80%934_tree#Example">这里</a>。</p>
<p>对于红黑树而言，在插入前，我们采用与一般二叉搜索树相同的机制寻找新叶结点插入的位置，并在插入后将其颜色置为<strong>红色</strong>，即对应 2-3-4 树中将子结点升阶的一般操作（2-结点变 3-结点，3-结点变 4-结点）。值得注意的是，<strong>该动作不会使红黑树的性质 4 失效</strong>（新插入的红色结点不影响任意路径经过的黑色结点数），<strong>但有可能使性质 3 失效</strong>（父结点同为红色结点时，出现连续的两个红色结点）。此时为使性质 3 重新成立，具体采用什么动作则需要分情况讨论。</p>
<p>深刻了解红黑树操作的读者可以直接看后面的总结部分。</p>
<p>在详细分析每种情形前，我们先来看看 <code>TreeMap#put</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 树为空，将新结点作为根结点</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K, V&gt; parent;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123; <span class="comment">// 使用 Comparator 定位插入位置</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value); <span class="comment">// 在内部结点中找到了相同的键，直接替换结点的值</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 使用 Comparable#compareTo 方法定位插入位置。效果与上述代码等价</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    Entry&lt;K, V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="comment">// 将新结点插入叶结点的对应链接</span></span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    <span class="comment">// 修复红黑树</span></span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line"></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    n.color = RED; <span class="comment">// 新结点置为红色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="keyword">null</span> &amp;&amp; n != root &amp;&amp; n.parent.color == RED) &#123; <span class="comment">// 向上递归修复直至遇到黑色结点</span></span><br><span class="line">        <span class="keyword">if</span> (parentOf(n) == leftOf(parentOf(parentOf(n)))) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK; <span class="comment">// 根结点置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为方便表述，下文将用<strong>叔父结点</strong>（Uncle Node）来表示某个结点的父结点的兄弟结点（Sibling Node）。</p>
<h3 id="红黑树插入情形-1：插入空树"><a href="#红黑树插入情形-1：插入空树" class="headerlink" title="红黑树插入情形 1：插入空树"></a>红黑树插入情形 1：插入空树</h3><p>当插入前红黑树为空时，需将新的结点作为红黑树的根结点。该情形已由 <code>TreeMap#put</code> 方法本身所处理。</p>
<h3 id="红黑树插入情形-2：父结点为黑色"><a href="#红黑树插入情形-2：父结点为黑色" class="headerlink" title="红黑树插入情形 2：父结点为黑色"></a>红黑树插入情形 2：父结点为黑色</h3><p>如果插入了新结点后，新结点的父结点为黑色，对应于 2-3-4 树中将新键值插入到了 2-结点使其成为 3-结点的情形。这实际上不会破坏 2-3-4 树的平衡性，新的结点不是 4-结点也不需要进行分裂，也没有违反红黑树的性质 3。此外，性质 4 也没有违反，因为新插入的结点为红色结点，不会影响根结点到任意叶子结点所经过的黑色结点的数量。</p>
<p><code>TreeMap#fixAfterInsertion</code> 方法的内部 <code>while</code> 循环会先判断当前扫描结点的父结点颜色是否为红色。当父结点颜色为黑色时，控制流不会进入 <code>while</code> 循环体。</p>
<h3 id="红黑树插入情形-3：父结点与叔父结点均为红色结点"><a href="#红黑树插入情形-3：父结点与叔父结点均为红色结点" class="headerlink" title="红黑树插入情形 3：父结点与叔父结点均为红色结点"></a>红黑树插入情形 3：父结点与叔父结点均为红色结点</h3><p>由于父结点与新插入的叶子结点同为红色，性质 3 不再成立，此时便需要启动修复。实际上，由于修复过程是自底向上递归进行的，是否进入该情形与当前结点 $N$ 的颜色无关，但 $N$ 实际上却是只会是红色的。这种情形对应于 2-3-4 树中遇到 4-结点的情形（由 $P$、$U$、$G$ 共同组成的 4-结点），因此此时我们需要对 4-结点进行分裂，并把中间键值（$G$）插入到上一级结点中。</p>
<p>实际上，我们只需要将父结点和叔父结点的颜色反转（置为黑色），并将它们的父结点（新叶子结点的爷爷结点）置为红色即可使性质 3 和性质 4 在该子树内重新成立。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png"></p>
<p>若如图中所示，修复后，爷爷结点 $G$ 变为红色，代表插入到了上一层的结点中，而 $P$ 和 $U$ 变为黑色，代表成为了分裂后的 2-结点，而红色的 $N$ 结点也代表了新键值插入 2-结点产生 3-结点的过程。若爷爷结点 $G$ 为红黑树的根结点，那么即修复成功。若 $G$ 不是根结点，那么我们只能确保性质 3 和 4 在以 $G$ 为根的子树内成立，在 $G$ 往上的树中并不一定成立，因此我们需要继续从 $G$ 开始递归地向上修复。</p>
<p><code>TreeMap#fixAfterInsertion</code> 方法中的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != <span class="keyword">null</span> &amp;&amp; n != root &amp;&amp; n.parent.color == RED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentOf(n) == leftOf(parentOf(parentOf(n)))) &#123;</span><br><span class="line">        <span class="comment">// g = parentOf(parentOf(n))</span></span><br><span class="line">        Entry&lt;K, V&gt; u = rightOf(parentOf(parentOf(n)));</span><br><span class="line">        <span class="keyword">if</span> (colorOf(u) == RED) &#123;</span><br><span class="line">                setColor(parentOf(n), BLACK); <span class="comment">// p = parentOf(n)</span></span><br><span class="line">                setColor(u, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(n)), RED);</span><br><span class="line">                n = parentOf(parentOf(n));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 与上半部分代码相对称 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="子树的左旋转与右旋转"><a href="#子树的左旋转与右旋转" class="headerlink" title="子树的左旋转与右旋转"></a>子树的左旋转与右旋转</h3><p>对接下来的两种不平衡情形的修复涉及到了对子树的旋转操作。旋转操作会保持二叉搜索树性质的情况下反转指定父子结点的父子关系，即原本的子结点升级为父结点，父结点降级为子结点，而两个结点原本的其他子结点及子树则基于一定的规则重新分配。</p>
<p>以左旋转为例，父结点 P 与其右子结点 Q 一同逆时针旋转，原本的父结点 P 将变为右子结点 Q 的左子结点。除此之外，Q 原本的左子结点 B 将成为 P 的左子结点。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/2/23/Tree_rotation.png"></p>
<p>右旋转则为左旋转的逆过程。</p>
<p>在 <code>TreeMap</code> 中，左旋转与右旋转分别对应于方法 <code>rotateLeft</code> 和 <code>rotateRight</code>，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树插入情形-4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构"><a href="#红黑树插入情形-4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构" class="headerlink" title="红黑树插入情形 4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构"></a>红黑树插入情形 4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构</h3><p>在该情形下，父结点为红色结点，但叔父结点为黑色结点。除此之外，当前结点为父结点的左子结点，而父结点同为爷爷结点的左子结点，即这三代结点形成了左左结构。</p>
<p>此时，我们需要将父结点与爷爷结点的颜色互换，并以爷爷结点为锚点执行右旋转操作。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png"></p>
<p>对于 2-3-4 树而言，原本的两个连续的红色结点无法代表 2-3-4 树的结点，但在经过旋转和变色后，$N$、$P$、$G$ 则重新构成了一个 4-结点，因此我们仍需以上升后的 $N$ 结点为起点向上递归修复，触发下一次的 4-结点分裂。</p>
<p>若三代结点间形成的是右右结构，我们只需要轴对称地执行左旋转操作即可。</p>
<p><code>TreeMap#fixAfterInsertion</code> 方法中的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != <span class="keyword">null</span> &amp;&amp; n != root &amp;&amp; n.parent.color == RED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentOf(n) == leftOf(parentOf(parentOf(n)))) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; u = rightOf(parentOf(parentOf(n)));</span><br><span class="line">        <span class="keyword">if</span> (colorOf(u) == RED) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == rightOf(parentOf(n))) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">            setColor(parentOf(n), BLACK);</span><br><span class="line">            setColor(parentOf(parentOf(n)), RED);</span><br><span class="line">            rotateRight(parentOf(parentOf(n)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 与上半部分轴对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树插入情形-5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构"><a href="#红黑树插入情形-5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构" class="headerlink" title="红黑树插入情形 5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构"></a>红黑树插入情形 5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构</h3><p>在该情形下，父结点为红色结点，但叔父结点为黑色结点。除此之外，当前结点为父结点的右子结点，而父结点则为爷爷结点的左子结点，即这三代结点形成了左右结构。</p>
<p>此时，我们需要以父结点为锚点执行左旋转操作。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png"></p>
<p>实际上这项操作并未使得子树得以修复，而是使得当前的结构进入了情形 4，因此我们需要再次执行情形 4 对应的修复动作。同理，原本的两个连续的红色结点无法代表 2-3-4 树的结点，因此我们需要进入情形 4 再执行对应修复，以重新得到一个合法的红黑树。</p>
<p>若三代结点间形成的是右左结构，我们只需要轴对称地执行右旋转即可。</p>
<p><code>TreeMap#fixAfterInsertion</code> 方法中的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (n != <span class="keyword">null</span> &amp;&amp; n != root &amp;&amp; n.parent.color == RED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parentOf(n) == leftOf(parentOf(parentOf(n)))) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; u = rightOf(parentOf(parentOf(n)));</span><br><span class="line">        <span class="keyword">if</span> (colorOf(u) == RED) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == rightOf(parentOf(n))) &#123; <span class="comment">// 进入情形 5</span></span><br><span class="line">                n = parentOf(n);</span><br><span class="line">                rotateLeft(n);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 进入情形 4，继续修复</span></span><br><span class="line">            setColor(parentOf(n), BLACK);</span><br><span class="line">            setColor(parentOf(parentOf(n)), RED);</span><br><span class="line">            rotateRight(parentOf(parentOf(n)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 与上半部分轴对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>红黑树插入修复的总结如下：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>情形</th>
<th>处理</th>
<th>示意图</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>$P$ 为<strong>黑色结点</strong></td>
<td>结束修复</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>$P$ 和 $U$ 均为<strong>红色结点</strong></td>
<td>将 $P$、$U$、$G$ 的颜色反转。 $G$ 的颜色变为红色，故从 $G$ 开始继续往上执行相同的修复过程</td>
<td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Red-black_tree_insert_case_3.svg/800px-Red-black_tree_insert_case_3.svg.png"></td>
</tr>
<tr>
<td>4</td>
<td>$U$ 为<strong>黑色结点</strong>，$G$、$P$、$N$ 形成<strong>左左</strong>结构</td>
<td>$P$、$G$ 颜色互换，并以 $G$ 进行右旋转</td>
<td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/dc/Red-black_tree_insert_case_5.svg/800px-Red-black_tree_insert_case_5.svg.png"></td>
</tr>
<tr>
<td>5</td>
<td>$U$ 为<strong>黑色结点</strong>，$G$、$P$、$N$ 形成<strong>左右</strong>结构</td>
<td>以 $P$ 进行左旋转，从 $P$ 开始继续修复，进入情形 4</td>
<td><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/89/Red-black_tree_insert_case_4.svg/800px-Red-black_tree_insert_case_4.svg.png"></td>
</tr>
</tbody></table>
<p><code>TreeMap#fixAfterInsertion</code> 方法的总结如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    n.color = RED; <span class="comment">// 新结点置为红色</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n != <span class="keyword">null</span> &amp;&amp; n != root &amp;&amp; n.parent.color == RED) &#123;</span><br><span class="line">        Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">        Entry&lt;K, V&gt; g = parentOf(p);</span><br><span class="line">        <span class="keyword">if</span> (p == leftOf(g)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; u = rightOf(g);</span><br><span class="line">            <span class="keyword">if</span> (colorOf(u) == RED) &#123;   <span class="comment">// 进入情形 3，进行颜色反转</span></span><br><span class="line">                setColor(p, BLACK);</span><br><span class="line">                setColor(u, BLACK);</span><br><span class="line">                setColor(g, RED);</span><br><span class="line">                <span class="comment">// 递进至爷爷结点，即新出现的红色结点，继续向上修复</span></span><br><span class="line">                n = g;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == rightOf(p)) &#123; <span class="comment">// 进入情形 5，以父结点进行左旋转</span></span><br><span class="line">                    n = p;</span><br><span class="line">                    rotateLeft(n);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(p, BLACK);    <span class="comment">// 进入情形 4。设置颜色后，以爷爷结点进行右旋转</span></span><br><span class="line">                setColor(g, RED);</span><br><span class="line">                rotateRight(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            Entry&lt;K, V&gt; u = leftOf(g);</span><br><span class="line">            <span class="keyword">if</span> (colorOf(u) == RED) &#123;  <span class="comment">// 进入情形 3</span></span><br><span class="line">                setColor(p, BLACK);</span><br><span class="line">                setColor(u, BLACK);</span><br><span class="line">                setColor(g, RED);</span><br><span class="line">                n = g;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (n == leftOf(p)) &#123; <span class="comment">// 进入情形 5，以父结点进行右旋转</span></span><br><span class="line">                    n = p;</span><br><span class="line">                    rotateRight(n);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(p, BLACK);   <span class="comment">// 进入情形 4。设置颜色后，以爷爷结点进行左旋转</span></span><br><span class="line">                setColor(g, RED);</span><br><span class="line">                rotateLeft(g);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK <span class="comment">// 将根结点置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡树操作-——-删除"><a href="#平衡树操作-——-删除" class="headerlink" title="平衡树操作 —— 删除"></a>平衡树操作 —— 删除</h2><p>与插入操作同理，在删除前，我们采用与一般二叉搜索树相同的方法查找需要删除的元素。与之不同的是，我们不会直接执行原地删除操作，因为待删除的结点有可能是内部结点，而新插入的结点只可能是叶子结点，因此要完成删除操作还需要一些特殊的预处理。</p>
<p>当删除内部结点时，我们采取与一般二叉搜索树相同的方法，先将其与其后继结点（Successor Node）互换（颜色保持不变），再删除该后继结点。后继结点通常指大于该结点的最小结点或小于该结点的最大结点。对于一个同时有着左右子结点的结点来说，其后继结点即为位于其右子树最左下角的结点或位于其左子树最右下角的结点。因此在完成该预处理后，我们只需要考虑待删除结点只有一个子结点或没有子结点（叶子结点）两种情况。</p>
<p>对于一般的二叉搜索树而言，删除有一个子结点的内部结点只需要让其父结点的对应链接直接指向该子结点即可。而删除叶子结点的操作则更是简单了。</p>
<p>首先我们考虑 2-3-4 树的删除操作。形式化的描述如下：</p>
<blockquote>
<ol>
<li>查找待删除的键值<ul>
<li>如果键值所处结点不是叶子结点，那就继续向下递归寻找其后续结点，同时在下沉的过程中对结点进行调整，以确保所找到的后续结点不是一个 2-结点</li>
<li>如果键值所处的结点是一个 2-叶子结点，那就对结点进行相同的调整</li>
</ul>
</li>
</ol>
</blockquote>
<p>在下降的过程中对沿途所有非根结点的 2-结点 $N$ 作如下调整：</p>
<blockquote>
<ol>
<li>如果父结点 $P$ 和兄弟结点 $S$ 均为 2-结点，那就将 $N$、$P$、$S$ 组合成一个 4-结点，树的高度减少 1。实际上，这种情况只有在父结点 $P$ 同为根结点时才会发生，<br>因为其他 2-结点在下降的过程中早已被转换</li>
<li>如果有一个位于该结点左侧或右侧的兄弟 3-结点或 4-结点 $S$（即包含多于一个的键值），那么就与该兄弟结点进行旋转操作：<ul>
<li>将兄弟结点 $S$ 距离该结点 $N$ 最近的键值上升到两个结点的父结点 $P$ 中</li>
<li>父结点 $P$ 原有的键值下降到该 2-结点 $N$ 中以形成一个 3-结点 </li>
<li>原本属于上升至父结点的键值的子结点现在成为 $N$ 的新的子结点</li>
</ul>
</li>
<li>如果父结点 $P$ 为 3-结点或 4-结点且所有兄弟结点均为 2-结点，那么就将 $N$、$P$ 以及其最近的兄弟结点 $S$ 执行混合操作：<ul>
<li>利用 $N$ 的键值、 $S$ 的键值以及 $P$ 中位于 $N$ 和 $S$ 链接交合处的键值（一共三个键值）组成一个 4-结点</li>
<li>将 $S$ 原本的子结点变为该结点的子结点</li>
</ul>
</li>
</ol>
</blockquote>
<p><img src="/img/TreeMap@1.jpg"></p>
<p>如此一来，待删除键值所处的叶子结点便不是 2-结点（包含多于一个键值），可以安全地将其移除并对该叶子结点进行降阶，同时不影响 2-3-4 树的平衡性。该过程结合《Algorithms》一书的图 3.3.26 应该会更好理解。（见右侧）</p>
<p>但对于红黑树而言，如果被移除的结点是一个黑色结点则有可能使得性质 3 和 4 不再成立，因此需要在此时对红黑树进行修复。</p>
<p>我们先对可能发生的情况进行讨论：</p>
<ul>
<li><strong>待删除的结点为红色结点</strong>：这种情况对应于 2-3-4 树中的一般结点降阶过程。那么由性质 3 可知，它的父结点和子结点必为黑色结点，而从红黑树内部移除一个红色结点不会改变根结点到任意叶子结点所经过黑色结点的数量，因此性质 4 也不会变化，在这种情况下我们不需要进行任何修复；</li>
<li><strong>待删除结点为黑色结点，其子结点为红色结点</strong>：这种情况同样对应于 2-3-4 树中的一般结点降阶过程。但由它的红色子结点会顶替它原有的位置，这会导致红黑树的性质 4 不成立（通过该结点的所有路径所经过的黑色结点数减少 1），此时我们只需要将该子结点置为黑色即可使性质 4 重新成立。</li>
</ul>
<p><code>TreeMap#remove</code> 方法的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = getEntry(key); <span class="comment">// 查找待删除的结点</span></span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)                 <span class="comment">// 结点不存在，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p);                <span class="comment">// 删除结点</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K, V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123; <span class="comment">// 待删除结点是有两个子结点的内部结点</span></span><br><span class="line">        Entry&lt;K, V&gt; s = successor(p);   <span class="comment">// 与后继结点替换</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;                          <span class="comment">// 开始删除该后继结点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，p 所指向的结点只可能有 1 个或 0 个子结点</span></span><br><span class="line"></span><br><span class="line">    Entry&lt;K, V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right); <span class="comment">// 获取其子结点作为替换结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">// 替换结点不为空，即 p 有一个子结点</span></span><br><span class="line">        replacement.parent = p.parent; <span class="comment">// 用替换结点替换 p</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)   <span class="comment">// p 为根结点</span></span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK) <span class="comment">// 若被删除的结点为黑色结点，执行自平衡修复</span></span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// p 为叶子结点，且 p 为根结点，即此时红黑树只有一个结点</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// p 为叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK) <span class="comment">// 若被删除的结点为黑色结点，执行自平衡修复</span></span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123; <span class="comment">// 移除 p</span></span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以看一下 <code>TreeMap#fixAfterDeletion</code> 方法的循环结束条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123; <span class="comment">// 当 n 为根结点或红色结点时结束循环</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    setColor(n, BLACK); <span class="comment">// 对于上面提到的第二种情形，红色子结点会在这里被置为黑色</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们就需要分情况讨论<strong>待删除结点及其子结点同为黑色结点</strong>的情况了，即在 2-3-4 树中删除 2-结点的情况。出于方便，接下来我们将作为修复起点的结点称为 $N$，其父结点为 $P$，兄弟结点为 $S$，并有 $S$ 结点的左右子结点分别为 $S_L$ 和 $S_R$。</p>
<h3 id="红黑树删除情形-1：兄弟结点-S-为红色结点"><a href="#红黑树删除情形-1：兄弟结点-S-为红色结点" class="headerlink" title="红黑树删除情形 1：兄弟结点 S 为红色结点"></a>红黑树删除情形 1：兄弟结点 S 为红色结点</h3><p>在这种情况下，我们需要以父结点 $P$ 为锚点进行左旋转，让兄弟结点 $S$ 变为当前结点 $N$ 的爷爷结点，再将 $P$ 置为红色，$S$ 置为黑色即可。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png"></p>
<p><code>TreeMap#fixAfterDeletion</code> 方法的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == leftOf(p)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; s = rightOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123; <span class="comment">// 进入情形 1</span></span><br><span class="line">                setColor(s, BLACK);</span><br><span class="line">                setColor(p, RED);</span><br><span class="line">                rotateLeft(p);</span><br><span class="line">                s = rightOf(p);</span><br><span class="line">                s_l = leftOf(s);</span><br><span class="line">                s_r = rightOf(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(n, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时我们并未完成修复，因为由于黑色结点被删除，经过 $N$ 的路径仍然比经过 $S_L$ 的路径少一个黑色结点，因此我们仍然需要以 $N$ 为起点进行修复，但此时则进入了其他情形（取决于原 $S_L$ 的颜色）。</p>
<h3 id="红黑树删除情形-2：兄弟结点及其子结点均为黑色结点"><a href="#红黑树删除情形-2：兄弟结点及其子结点均为黑色结点" class="headerlink" title="红黑树删除情形 2：兄弟结点及其子结点均为黑色结点"></a>红黑树删除情形 2：兄弟结点及其子结点均为黑色结点</h3><p>此时，由于被删除结点的关系，经过结点 $N$ 的路径少了一个黑色结点。此时我们需要将兄弟结点 $S$ 置为红色，如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c7/Red-black_tree_delete_case_3.png"></p>
<p>这对应于在 2-3-4 树中将两个 2-结点合并为一个 3-结点的过程。即便如此，我们也只是确保了性质 4 在以 $P$ 为根的子树内成立，我们仍需要继续以 $P$ 为起点向上修复。</p>
<p><code>TreeMap#fixAfterDeletion</code> 方法中的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == leftOf(p)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; s = rightOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s_l)  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(s_r) == BLACK) &#123; <span class="comment">// 进入情形 2</span></span><br><span class="line">                setColor(s, RED);        <span class="comment">// 兄弟结点置为红色</span></span><br><span class="line">                n = p;                   <span class="comment">// 继续从父结点开始向上修复</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(n, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树删除情形-3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点"><a href="#红黑树删除情形-3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点" class="headerlink" title="红黑树删除情形 3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点"></a>红黑树删除情形 3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点</h3><p>此时，我们以 $S$ 为锚点执行右旋转，并将 $S_L$ 与 $S$ 的颜色互换，继而进入情形 4。如下图所示：</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/30/Red-black_tree_delete_case_5.png"></p>
<p><code>TreeMap#fixAfterDeletion</code> 方法中的相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == leftOf(p)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; s = rightOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s_l)  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(s_r) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(s_r) == BLACK) &#123; <span class="comment">// 进入情形 3</span></span><br><span class="line">                    setColor(s_l, BLACK);</span><br><span class="line">                    setColor(s, RED);</span><br><span class="line">                    rotateRight(s);</span><br><span class="line">                    s = rightOf(p);</span><br><span class="line">                    s_l = leftOf(s);</span><br><span class="line">                    s_r = rightOf(s);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(n, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="红黑树删除情形-4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点"><a href="#红黑树删除情形-4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点" class="headerlink" title="红黑树删除情形 4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点"></a>红黑树删除情形 4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点</h3><p>在这种情况下，我们在结点 $P$ 上做左旋转，并互换 $P$ 和 $S$ 的颜色，再将 $S_R$ 置为黑色。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/3/31/Red-black_tree_delete_case_6.png"></p>
<p>如此一来，由于 $N$ 新增了一个新的黑色父结点 $P$，原本经过 $N$ 的路径的黑色结点数得到了恢复，同时由于 $S_R$ 的颜色变为了黑色，经过 $S_R$ 的路径的黑色结点数也没有变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == leftOf(p)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; s = rightOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s_l)  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(s_r) == BLACK) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(s_r) == BLACK) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                setColor(s, colorOf(p));</span><br><span class="line">                setColor(p, BLACK);</span><br><span class="line">                setColor(s_r, BLACK);</span><br><span class="line">                rotateLeft(p);</span><br><span class="line">                n = root; <span class="comment">// 结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(n, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>我们定义待删除的结点为 $D$、其唯一子结点为 $N$、父结点为 $P$、爷爷结点为 $G$、兄弟结点为 $S$，那么红黑树删除修复可总结如下：</p>
<table>
<thead>
<tr>
<th>#</th>
<th>情形</th>
<th>处理</th>
<th>示意图</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>$D$ 为<strong>红色</strong>结点</td>
<td>无需修复</td>
<td></td>
</tr>
<tr>
<td></td>
<td>$D$ 为<strong>黑色</strong>结点，$N$ 为<strong>红色</strong>结点</td>
<td>$N$ 置为黑色，结束修复</td>
<td></td>
</tr>
<tr>
<td>1</td>
<td>$D$、$N$ 为<strong>黑色</strong>结点，$S$ 为红色结点</td>
<td>以 $P$ 进行左旋转，$P$、$S$ 进行颜色互换，使 $N$ 的父结点为红色结点</td>
<td><img src="https://upload.wikimedia.org/wikipedia/commons/3/39/Red-black_tree_delete_case_2.png"></td>
</tr>
</tbody></table>
<p><code>TreeMap#fixAfterDeletion</code> 方法的总结如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K, V&gt; n)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K, V&gt; p = parentOf(n);</span><br><span class="line">    <span class="keyword">while</span> (n != root &amp;&amp; colorOf(n) == BLACK) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == leftOf(p)) &#123;</span><br><span class="line">            Entry&lt;K, V&gt; s = rightOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123; <span class="comment">// 进入情形 1，以 P 进行左旋转</span></span><br><span class="line">                setColor(s, BLACK);</span><br><span class="line">                setColor(p, RED);</span><br><span class="line">                rotateLeft(p);</span><br><span class="line">                s = rightOf(p);</span><br><span class="line">                s_l = leftOf(s);</span><br><span class="line">                s_r = rightOf(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s_l)  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(s_r) == BLACK) &#123; <span class="comment">// 进入情形 2，将 S 置为红色，向上递归</span></span><br><span class="line">                setColor(s, RED);</span><br><span class="line">                n = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(s_r) == BLACK) &#123; <span class="comment">// 进入情形 3，以 S 进行右旋转</span></span><br><span class="line">                    setColor(s_l, BLACK);</span><br><span class="line">                    setColor(s, RED);</span><br><span class="line">                    rotateRight(s);</span><br><span class="line">                    s = rightOf(p);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(s, colorOf(p));  <span class="comment">// 进入情形 4，以 P 进行左旋转，结束修复</span></span><br><span class="line">                setColor(p, BLACK);</span><br><span class="line">                setColor(s_r, BLACK);</span><br><span class="line">                rotateLeft(p);</span><br><span class="line">                n = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 与上半部分代码轴对称</span></span><br><span class="line">            Entry&lt;K, V&gt; s = leftOf(p);</span><br><span class="line">            Entry&lt;K, V&gt; s_l = leftOf(s);</span><br><span class="line">            Entry&lt;K, V&gt; s_r = rightOf(s);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s) == RED) &#123; <span class="comment">// 进入情形 1，以 P 进行右旋转</span></span><br><span class="line">                setColor(s, BLACK);</span><br><span class="line">                setColor(p, RED);</span><br><span class="line">                rotateRight(p);</span><br><span class="line">                s = leftOf(p);</span><br><span class="line">                s_l = leftOf(s);</span><br><span class="line">                s_r = rightOf(s);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(s_r) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(s_l) == BLACK) &#123; <span class="comment">// 进入情形 2，将 S 置为红色，向上递归</span></span><br><span class="line">                setColor(s, RED);</span><br><span class="line">                n = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(s_l) == BLACK) &#123; <span class="comment">// 进入情形 3，以 S 进行左旋转</span></span><br><span class="line">                    setColor(s_r, BLACK);</span><br><span class="line">                    setColor(s, RED);</span><br><span class="line">                    rotateLeft(s);</span><br><span class="line">                    s = leftOf(p);</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(s, colorOf(p)); <span class="comment">// 进入情形 4，以 P 进行右旋转，结束修复</span></span><br><span class="line">                setColor(p, BLACK);</span><br><span class="line">                setColor(s_l, BLACK);</span><br><span class="line">                rotateRight(p);</span><br><span class="line">                n = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setColor(n, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没理解为什么这些东西要这么做？没关系，我也不理解，可能写这些代码的人自己也不理解 =。= 实际上这些 <code>private</code> 方法大多数都有 <code>/** From CLR */</code> 的注释，在 <code>TreeMap.java</code> 中也能找到这么一段注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Balancing operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Implementations of rebalancings during insertion and deletion are</span></span><br><span class="line"><span class="comment"> * slightly different than the CLR version.  Rather than using dummy</span></span><br><span class="line"><span class="comment"> * nilnodes, we use a set of accessors that deal properly with null.  They</span></span><br><span class="line"><span class="comment"> * are used to avoid messiness surrounding nullness checks in the main</span></span><br><span class="line"><span class="comment"> * algorithms.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>因此，此 CLR 指的应该就是 Common Language Runtime，这些自平衡代码也很有可能是从 C# 那边“借”来的。详见<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/38482750/from-clr-in-java-treemap-implementation">这里</a>。不管怎么说，红黑树都是很复杂的数据结构，如果你不能完全记忆这些操作那就罢了，没什么必要。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java TreeMap 源码解析</p><p><a href="https://mr-dai.github.io/java_collection_treemap/">https://mr-dai.github.io/java_collection_treemap/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Robert Peng</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2017-02-27</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2017-02-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay-qrcode.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat-qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/sql_reference/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">SQL Reference</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/java_string_formatting/"><span class="level-item">Java String Formatting</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://mr-dai.github.io/java_collection_treemap/';
            this.page.identifier = 'java_collection_treemap/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'robertpsblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="呆呆"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">呆呆</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/robert.peng" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/robert.peng"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bigtable/"><span class="tag">Bigtable</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GC/"><span class="tag">GC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gradle/"><span class="tag">Gradle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Groovy/"><span class="tag">Groovy</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hive-ThriftServer/"><span class="tag">Hive ThriftServer</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-824/"><span class="tag">MIT 6.824</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mesos/"><span class="tag">Mesos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paxos/"><span class="tag">Paxos</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raft/"><span class="tag">Raft</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark-SQL/"><span class="tag">Spark SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SparkSQL/"><span class="tag">SparkSQL</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD/"><span class="tag">主从备份</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/"><span class="tag">分布式共识</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98/"><span class="tag">分布式内存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"><span class="tag">分布式存储</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式系统</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"><span class="tag">分布式计算</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"><span class="tag">团队协作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"><span class="tag">集群资源调度</span><span class="tag">2</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#2-3-4-树及红黑树"><span class="level-left"><span class="level-item">1</span><span class="level-item">2-3-4 树及红黑树</span></span></a></li><li><a class="level is-mobile" href="#平衡树操作-——-查找"><span class="level-left"><span class="level-item">2</span><span class="level-item">平衡树操作 —— 查找</span></span></a></li><li><a class="level is-mobile" href="#平衡树操作-——-插入"><span class="level-left"><span class="level-item">3</span><span class="level-item">平衡树操作 —— 插入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#红黑树插入情形-1：插入空树"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">红黑树插入情形 1：插入空树</span></span></a></li><li><a class="level is-mobile" href="#红黑树插入情形-2：父结点为黑色"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">红黑树插入情形 2：父结点为黑色</span></span></a></li><li><a class="level is-mobile" href="#红黑树插入情形-3：父结点与叔父结点均为红色结点"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">红黑树插入情形 3：父结点与叔父结点均为红色结点</span></span></a></li><li><a class="level is-mobile" href="#子树的左旋转与右旋转"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">子树的左旋转与右旋转</span></span></a></li><li><a class="level is-mobile" href="#红黑树插入情形-4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">红黑树插入情形 4：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左左结构</span></span></a></li><li><a class="level is-mobile" href="#红黑树插入情形-5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">红黑树插入情形 5：叔父结点为黑色结点，当前结点与其父结点及爷爷结点间形成左右结构</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">3.7</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#平衡树操作-——-删除"><span class="level-left"><span class="level-item">4</span><span class="level-item">平衡树操作 —— 删除</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#红黑树删除情形-1：兄弟结点-S-为红色结点"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">红黑树删除情形 1：兄弟结点 S 为红色结点</span></span></a></li><li><a class="level is-mobile" href="#红黑树删除情形-2：兄弟结点及其子结点均为黑色结点"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">红黑树删除情形 2：兄弟结点及其子结点均为黑色结点</span></span></a></li><li><a class="level is-mobile" href="#红黑树删除情形-3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">红黑树删除情形 3：兄弟结点及其右子结点为黑色结点，其左子结点为红色结点</span></span></a></li><li><a class="level is-mobile" href="#红黑树删除情形-4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">红黑树删除情形 4：兄弟结点及其左子结点为黑色结点，其右子结点为红色结点</span></span></a></li><li><a class="level is-mobile" href="#总结-1"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">总结</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Robert Peng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>