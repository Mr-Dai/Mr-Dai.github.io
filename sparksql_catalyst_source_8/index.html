<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Spark Catalyst 进阶：Join - Robert Peng&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="呆呆的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="呆呆的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在之前的文章中，我们已经了解了 SparkSQL 把 SQL 语句变为 SparkJob 的过程。这个过程我们只是做了一个 Overview，具体不同的语句会变为怎样的 Job 我们并未一一列举。实际上列举起来是一件相当大工程的事。 在那么多的 SQL 操作中，有那么一个操作十分常用，但又十分耗时，那就是 Join 操作。在这篇文章里，我们将深入探讨 SparkSQL 会对不同的 Join 做出怎"><meta property="og:type" content="blog"><meta property="og:title" content="Spark Catalyst 进阶：Join"><meta property="og:url" content="https://mr-dai.github.io/sparksql_catalyst_source_8/"><meta property="og:site_name" content="Robert Peng&#039;s Blog"><meta property="og:description" content="在之前的文章中，我们已经了解了 SparkSQL 把 SQL 语句变为 SparkJob 的过程。这个过程我们只是做了一个 Overview，具体不同的语句会变为怎样的 Job 我们并未一一列举。实际上列举起来是一件相当大工程的事。 在那么多的 SQL 操作中，有那么一个操作十分常用，但又十分耗时，那就是 Join 操作。在这篇文章里，我们将深入探讨 SparkSQL 会对不同的 Join 做出怎"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mr-dai.github.io/img/og_image.png"><meta property="article:published_time" content="2015-08-23T16:00:00.000Z"><meta property="article:modified_time" content="2015-08-23T16:00:00.000Z"><meta property="article:author" content="Robert Peng"><meta property="article:tag" content="Spark"><meta property="article:tag" content="SparkSQL"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-dai.github.io/sparksql_catalyst_source_8/"},"headline":"Spark Catalyst 进阶：Join","image":["https://mr-dai.github.io/img/og_image.png"],"datePublished":"2015-08-23T16:00:00.000Z","dateModified":"2015-08-23T16:00:00.000Z","author":{"@type":"Person","name":"Robert Peng"},"publisher":{"@type":"Organization","name":"Robert Peng's Blog","logo":{"@type":"ImageObject","url":"https://mr-dai.github.io/img/avatar.png"}},"description":"在之前的文章中，我们已经了解了 SparkSQL 把 SQL 语句变为 SparkJob 的过程。这个过程我们只是做了一个 Overview，具体不同的语句会变为怎样的 Job 我们并未一一列举。实际上列举起来是一件相当大工程的事。 在那么多的 SQL 操作中，有那么一个操作十分常用，但又十分耗时，那就是 Join 操作。在这篇文章里，我们将深入探讨 SparkSQL 会对不同的 Join 做出怎"}</script><link rel="canonical" href="https://mr-dai.github.io/sparksql_catalyst_source_8/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2015-08-23T16:00:00.000Z" title="8/23/2015, 4:00:00 PM">2015-08-24</time>发表</span><span class="level-item"><time dateTime="2015-08-23T16:00:00.000Z" title="8/23/2015, 4:00:00 PM">2015-08-24</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Spark/">Spark</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Spark Catalyst 进阶：Join</h1><div class="content"><p>在之前的文章中，我们已经了解了 SparkSQL 把 SQL 语句变为 SparkJob 的过程。这个过程我们只是做了一个 Overview，具体不同的语句会变为怎样的 Job 我们并未一一列举。实际上列举起来是一件相当大工程的事。</p>
<p>在那么多的 SQL 操作中，有那么一个操作十分常用，但又十分耗时，那就是 Join 操作。在这篇文章里，我们将深入探讨 SparkSQL 会对不同的 Join 做出怎样的操作。</p>
<span id="more"></span>

<h2 id="什么是-Join-？"><a href="#什么是-Join-？" class="headerlink" title="什么是 Join ？"></a>什么是 Join ？</h2><p>在 SQL 中，Join 用于根据两个或多个表中的列之间的关系，从这些表中查询数据。表达 Join 的方式有两种：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons, Orders</span><br><span class="line"><span class="keyword">WHERE</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName;</span><br></pre></td></tr></table></figure>

<p>实际上，第一种方式更像是 SQL 的语法糖，理论上而言我们更偏向后一种写法。这种使用关键字 <code>JOIN</code> 的规范写法使用 <code>ON</code> 关键字表明了 Join 的条件，同时在 <code>JOIN</code> 前面加上了一个 <code>INNER</code> 来表明要执行的 Join 的类型。SparkSQL 支持的 SQL 操作有以下几种：</p>
<table>
<thead>
<tr>
<th>Join 类型</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>Inner Join</td>
<td>使用比较运算符根据每个表共有的列的值匹配两个表中的行</td>
</tr>
<tr>
<td>Left Semi Join</td>
<td>对于左表的每个键值，在右表中找到第一个匹配的键值便返回</td>
</tr>
<tr>
<td>Left Outer Join</td>
<td>左向外联接的结果集包括 LEFT OUTER 子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值</td>
</tr>
<tr>
<td>Right Outer Join</td>
<td>右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值</td>
</tr>
<tr>
<td>Full Outer Join</td>
<td>完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值</td>
</tr>
</tbody></table>
<p>接下来我们就开始看看 SparkSQL 会怎么处理这些 JOIN 语句。</p>
<h2 id="Parser"><a href="#Parser" class="headerlink" title="Parser"></a>Parser</h2><p>首先 JOIN 语句要变成 Logical Plan 就需要先经过 Parser。根据我们之前学习过的内容来判断，JOIN 语句相关的解析规则在 <code>SqlParser</code> 类中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SqlParser</span> <span class="keyword">extends</span> <span class="title">AbstractSparkSQLParser</span> <span class="keyword">with</span> <span class="title">DataTypeParser</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直接查找关键字 `Join`，发现在 relations 中创建了这样一个实例</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> relations: <span class="type">Parser</span>[<span class="type">LogicalPlan</span>] =</span><br><span class="line">  <span class="comment">// 我们知道 relation 指代的是一张表，那么在遇到像 `Table1, Table2` 这样的语句就会进入这里</span></span><br><span class="line">    ( relation ~ rep1(<span class="string">&quot;,&quot;</span> ~&gt; relation) ^^ &#123;</span><br><span class="line">        <span class="keyword">case</span> r1 ~ joins =&gt; joins.foldLeft(r1) &#123; <span class="keyword">case</span>(lhs, r) =&gt; <span class="type">Join</span>(lhs, r, <span class="type">Inner</span>, <span class="type">None</span>) &#125; &#125;</span><br><span class="line">		<span class="comment">// 对于这样的语句，这里的做法是 foldLeft 地形成了一个由 Inner Join 组成的单边二叉树</span></span><br><span class="line">    | relation</span><br><span class="line">    )</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> select: <span class="type">Parser</span>[<span class="type">LogicalPlan</span>] =</span><br><span class="line">    <span class="type">SELECT</span> ~&gt; <span class="type">DISTINCT</span>.? ~</span><br><span class="line">      repsep(projection, <span class="string">&quot;,&quot;</span>) ~</span><br><span class="line">	  <span class="comment">// FROM 这里引用了上面的 relations，由此可见 SparkSQL 支持我们提到的第一种 SQL 写法，产生的是一个 Inner Join</span></span><br><span class="line">      (<span class="type">FROM</span>   ~&gt; relations).? ~</span><br><span class="line">      (<span class="type">WHERE</span>  ~&gt; expression).? ~</span><br><span class="line">      (<span class="type">GROUP</span>  ~  <span class="type">BY</span> ~&gt; rep1sep(expression, <span class="string">&quot;,&quot;</span>)).? ~</span><br><span class="line">      (<span class="type">HAVING</span> ~&gt; expression).? ~</span><br><span class="line">      sortType.? ~</span><br><span class="line">      (<span class="type">LIMIT</span>  ~&gt; expression).? ^^ &#123;</span><br><span class="line">        <span class="keyword">case</span> d ~ p ~ r ~ f ~ g ~ h ~ o ~ l =&gt;</span><br><span class="line">          <span class="keyword">val</span> base = r.getOrElse(<span class="type">OneRowRelation</span>)</span><br><span class="line">          <span class="keyword">val</span> withFilter = f.map(<span class="type">Filter</span>(_, base)).getOrElse(base)</span><br><span class="line">          <span class="keyword">val</span> withProjection = g</span><br><span class="line">            .map(<span class="type">Aggregate</span>(_, assignAliases(p), withFilter))</span><br><span class="line">            .getOrElse(<span class="type">Project</span>(assignAliases(p), withFilter))</span><br><span class="line">          <span class="keyword">val</span> withDistinct = d.map(_ =&gt; <span class="type">Distinct</span>(withProjection)).getOrElse(withProjection)</span><br><span class="line">          <span class="keyword">val</span> withHaving = h.map(<span class="type">Filter</span>(_, withDistinct)).getOrElse(withDistinct)</span><br><span class="line">          <span class="keyword">val</span> withOrder = o.map(_(withHaving)).getOrElse(withHaving)</span><br><span class="line">          <span class="keyword">val</span> withLimit = l.map(<span class="type">Limit</span>(_, withOrder)).getOrElse(withOrder)</span><br><span class="line">          withLimit</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...	  </span></span><br><span class="line">	  </span><br><span class="line">  <span class="comment">// Join 实例另一次出现的位置在这里	  </span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> joinedRelation: <span class="type">Parser</span>[<span class="type">LogicalPlan</span>] =</span><br><span class="line">  <span class="comment">// 这里对应的语句便是 JOIN `table` [ON ...]</span></span><br><span class="line">    relationFactor ~ rep1(joinType.? ~ (<span class="type">JOIN</span> ~&gt; relationFactor) ~ joinConditions.?) ^^ &#123;</span><br><span class="line">      <span class="keyword">case</span> r1 ~ joins =&gt;</span><br><span class="line">        joins.foldLeft(r1) &#123; <span class="keyword">case</span> (lhs, jt ~ rhs ~ cond) =&gt;</span><br><span class="line">          <span class="type">Join</span>(lhs, rhs, joinType = jt.getOrElse(<span class="type">Inner</span>), cond)</span><br><span class="line">		  <span class="comment">// 注意这里 Join 类型在未指定时为 Inner Join。同时注意这里的 cond 是个 Option[Expression]</span></span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">// 这里同样是 foldLeft 地形成了一个 Join 的二叉树</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> joinConditions: <span class="type">Parser</span>[<span class="type">Expression</span>] =</span><br><span class="line">    <span class="type">ON</span> ~&gt; expression</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过在 JOIN 关键字前加入如下关键字可以改变 Join 的类型	</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> joinType: <span class="type">Parser</span>[<span class="type">JoinType</span>] =</span><br><span class="line">    ( <span class="type">INNER</span>           ^^^ <span class="type">Inner</span></span><br><span class="line">    | <span class="type">LEFT</span>  ~ <span class="type">SEMI</span>    ^^^ <span class="type">LeftSemi</span></span><br><span class="line">    | <span class="type">LEFT</span>  ~ <span class="type">OUTER</span>.? ^^^ <span class="type">LeftOuter</span></span><br><span class="line">    | <span class="type">RIGHT</span> ~ <span class="type">OUTER</span>.? ^^^ <span class="type">RightOuter</span></span><br><span class="line">    | <span class="type">FULL</span>  ~ <span class="type">OUTER</span>.? ^^^ <span class="type">FullOuter</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...	</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此，输入到 SparkSQL 中的 SQL 语句与 Join 类型的关系可以总结如下：</p>
<table>
<thead>
<tr>
<th>Join 类型</th>
<th>SQL 语句</th>
</tr>
</thead>
<tbody><tr>
<td>Inner Join</td>
<td><code>SELECT ... FROM table1, table2[, ...] ...</code><hr /><code>SELECT ... FROM ... JOIN ... [ON ...]</code></td>
</tr>
<tr>
<td>Left Semi Join</td>
<td><code>SELECT ... FROM ... LEFT SEMI JOIN ... [ON ...]</code></td>
</tr>
<tr>
<td>Left Outer Join</td>
<td><code>SELECT ... FROM ... LEFT [OUTER] JOIN ... [ON ...]</code></td>
</tr>
<tr>
<td>Right Outer Join</td>
<td><code>SELECT ... FROM ... RIGHT [OUTER] JOIN ... [ON ...]</code></td>
</tr>
<tr>
<td>Full Outer Join</td>
<td><code>SELECT ... FROM ... FULL [OUTER] JOIN ... [ON ...]</code></td>
</tr>
</tbody></table>
<p>接下来我们来看一下表示 Logical Plan 的 <code>Join</code> 类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Join</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">  left: <span class="type">LogicalPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  right: <span class="type">LogicalPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">  joinType: <span class="type">JoinType</span>, // <span class="type">JoinType</span> 包括 5 个 case object，对应 5 个 <span class="type">Join</span> 类型</span></span></span><br><span class="line"><span class="params"><span class="class">  condition: <span class="type">Option</span>[<span class="type">Expression</span>]</span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = &#123;</span><br><span class="line">    joinType <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">LeftSemi</span> =&gt;</span><br><span class="line">        left.output</span><br><span class="line">      <span class="keyword">case</span> <span class="type">LeftOuter</span> =&gt;</span><br><span class="line">        left.output ++ right.output.map(_.withNullability(<span class="literal">true</span>))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RightOuter</span> =&gt;</span><br><span class="line">        left.output.map(_.withNullability(<span class="literal">true</span>)) ++ right.output</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FullOuter</span> =&gt;</span><br><span class="line">        left.output.map(_.withNullability(<span class="literal">true</span>)) ++ right.output.map(_.withNullability(<span class="literal">true</span>))</span><br><span class="line">      <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        left.output ++ right.output</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 防止用户构成了一些根本无法 Join 的左右子树</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">selfJoinResolved</span></span>: <span class="type">Boolean</span> = left.outputSet.intersect(right.outputSet).isEmpty</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">lazy</span> <span class="keyword">val</span> resolved: <span class="type">Boolean</span> = &#123;</span><br><span class="line">    childrenResolved &amp;&amp; !expressions.exists(!_.resolved) &amp;&amp; selfJoinResolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Join 的 Logical Plan 本身只有一个类，显得十分简单。</p>
<h2 id="Analyzer"><a href="#Analyzer" class="headerlink" title="Analyzer"></a>Analyzer</h2><p>在通过 Parser 得到 Unresolved Logical Plan 以后，下一步就轮到 Analyzer 了。经过之前的学习，我们知道 Analyzer 所应用的全部规则都位于 <code>Analyzer.scala</code> 中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Analyzer</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    catalog: <span class="type">Catalog</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    registry: <span class="type">FunctionRegistry</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    conf: <span class="type">CatalystConf</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    maxIterations: <span class="type">Int</span> = 100</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">RuleExecutor</span>[<span class="type">LogicalPlan</span>] <span class="keyword">with</span> <span class="type">HiveTypeCoercion</span> <span class="keyword">with</span> <span class="type">CheckAnalysis</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">ResolveReferences</span> <span class="keyword">extends</span> <span class="title">Rule</span>[<span class="type">LogicalPlan</span>] </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">LogicalPlan</span> = plan transformUp &#123;</span><br><span class="line">	</span><br><span class="line">	  <span class="comment">// ...</span></span><br><span class="line">	</span><br><span class="line">	  <span class="comment">// 同样，经过搜索，Join 仅出现在该分支中</span></span><br><span class="line">	  <span class="comment">// 该处用于处理之前的 selfJoinResolved 为 false 的情况</span></span><br><span class="line">      <span class="keyword">case</span> j @ <span class="type">Join</span>(left, right, _, _) <span class="keyword">if</span> left.outputSet.intersect(right.outputSet).nonEmpty =&gt;</span><br><span class="line">	    <span class="comment">// 找出冲突的 Attribute</span></span><br><span class="line">        <span class="keyword">val</span> conflictingAttributes = left.outputSet.intersect(right.outputSet)</span><br><span class="line">        logDebug(<span class="string">s&quot;Conflicting attributes <span class="subst">$&#123;conflictingAttributes.mkString(&quot;,&quot;)&#125;</span> in <span class="subst">$j</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 根据右子树类型的不同将右子树进行了替换</span></span><br><span class="line">        <span class="keyword">val</span> newRight = right transformUp &#123;</span><br><span class="line">          <span class="keyword">case</span> r <span class="keyword">if</span> r == oldRelation =&gt; newRelation</span><br><span class="line">        &#125; transformUp &#123;</span><br><span class="line">          <span class="keyword">case</span> other =&gt; other transformExpressions &#123;</span><br><span class="line">            <span class="keyword">case</span> a: <span class="type">Attribute</span> =&gt; attributeRewrites.get(a).getOrElse(a)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j.copy(right = newRight)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// ...</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>看起来，Analyzer 对 Join 树做的操作仅在于解决一些很奇怪的属性冲突。这种问题属于少数派，相信大多数时候 SparkSQL 都不会进入这个分支。</p>
<h2 id="Optimizer"><a href="#Optimizer" class="headerlink" title="Optimizer"></a>Optimizer</h2><p>接下来我们来看一下 Optimizer 是否有与 Join 相关的优化逻辑：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Join 首先出现在了这个 Rule 中</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ColumnPruning</span> <span class="keyword">extends</span> <span class="title">Rule</span>[<span class="type">LogicalPlan</span>] </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对 c 进行剪枝，只需要包含在 allReferences 中的属性</span></span><br><span class="line">  <span class="comment">// 通过在 c 之上加上一个 Project 计划来实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">prunedChild</span></span>(c: <span class="type">LogicalPlan</span>, allReferences: <span class="type">AttributeSet</span>) =</span><br><span class="line">    <span class="keyword">if</span> ((c.outputSet -- allReferences.filter(c.outputSet.contains)).nonEmpty) &#123;</span><br><span class="line">      <span class="type">Project</span>(allReferences.filter(c.outputSet.contains).toSeq, c)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      c</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">LogicalPlan</span> = plan transform &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Join 后只 SELECT 了少部分属性</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Project</span>(projectList, <span class="type">Join</span>(left, right, joinType, condition)) =&gt;</span><br><span class="line">      <span class="comment">// Collect the list of all references required either above or to evaluate the condition.</span></span><br><span class="line">      <span class="keyword">val</span> allReferences: <span class="type">AttributeSet</span> =</span><br><span class="line">        <span class="type">AttributeSet</span>(</span><br><span class="line">          projectList.flatMap(_.references.iterator)) ++</span><br><span class="line">          condition.map(_.references).getOrElse(<span class="type">AttributeSet</span>(<span class="type">Seq</span>.empty))</span><br><span class="line">	  <span class="comment">// 包括 SELECT 了的属性以及出现在了 ON 中的属性  </span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/** Applies a projection only when the child is producing unnecessary attributes */</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">pruneJoinChild</span></span>(c: <span class="type">LogicalPlan</span>): <span class="type">LogicalPlan</span> = prunedChild(c, allReferences)</span><br><span class="line">      <span class="comment">// 先对左右子树进行 Project 再 Join</span></span><br><span class="line">      <span class="type">Project</span>(projectList, <span class="type">Join</span>(pruneJoinChild(left), pruneJoinChild(right), joinType, condition))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消除 LeftSemiJoin 中右子树中不必要的属性</span></span><br><span class="line">    <span class="keyword">case</span> <span class="type">Join</span>(left, right, <span class="type">LeftSemi</span>, condition) =&gt;</span><br><span class="line">      <span class="comment">// Collect the list of all references required to evaluate the condition.</span></span><br><span class="line">      <span class="keyword">val</span> allReferences: <span class="type">AttributeSet</span> =</span><br><span class="line">        condition.map(_.references).getOrElse(<span class="type">AttributeSet</span>(<span class="type">Seq</span>.empty))</span><br><span class="line">      <span class="comment">// 包括出现在 ON 中的属性</span></span><br><span class="line">      <span class="type">Join</span>(left, prunedChild(right, allReferences), <span class="type">LeftSemi</span>, condition)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由此可见，Optimizer 对 Join 操作做出的优化，在于将 SELECT 以及 ON 所包含的属性考虑进去后，将左右子树中不需要的属性先删去再 Join，以此来优化 Join 的性能。</p>
<p>至此，Logical Plan 的处理过程就全部完成了。接下来就是重中之重了。</p>
<h2 id="Planner"><a href="#Planner" class="headerlink" title="Planner"></a>Planner</h2><p>我们知道，Planner 将 Optimized Logical Plan 变为 Physical Plan 的规则全都位于 <code>SparkStrategies</code> 类中，那我们直接看吧：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[sql] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SparkStrategies</span> <span class="keyword">extends</span> <span class="title">QueryPlanner</span>[<span class="type">SparkPlan</span>] </span>&#123;</span><br><span class="line">  self: <span class="type">SQLContext</span>#<span class="type">SparkPlanner</span> =&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">LeftSemiJoin</span> <span class="keyword">extends</span> <span class="title">Strategy</span> <span class="keyword">with</span> <span class="title">PredicateHelper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Seq</span>[<span class="type">SparkPlan</span>] = plan <span class="keyword">match</span> &#123;</span><br><span class="line">	  <span class="comment">// ExtractEquiJoinKeys 用于将出现在 condition 的相等条件中的属性拆分出来</span></span><br><span class="line">	  <span class="comment">// leftKeys 和 rightKeys 分别对应属于左子树和属于右子树的 Attribute</span></span><br><span class="line">	  <span class="comment">// 相同索引值的 leftKey 和 rightKey 构成原本的 condition 中的一对相等条件，即 `leftKey(i) = rightKey(i)`</span></span><br><span class="line">	  <span class="comment">// 剩余的非相等条件会被放入到结果的 condition 中</span></span><br><span class="line">	  <span class="comment">// 该 unapply 函数当且仅当 leftKeys 和 rightKeys 不为空时会有返回</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">LeftSemi</span>, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">	    <span class="comment">// 该参数默认为 10 * 1024 * 1024，即 10mb</span></span><br><span class="line">        <span class="keyword">if</span> sqlContext.conf.autoBroadcastJoinThreshold &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">          right.statistics.sizeInBytes &lt;= sqlContext.conf.autoBroadcastJoinThreshold =&gt;</span><br><span class="line">		<span class="comment">// 右子树 &lt;= 10 MB</span></span><br><span class="line">        <span class="comment">// 产生一个 BroadcastLeftSemiJoinHash 实例		</span></span><br><span class="line">        <span class="keyword">val</span> semiJoin = joins.<span class="type">BroadcastLeftSemiJoinHash</span>(</span><br><span class="line">          leftKeys, rightKeys, planLater(left), planLater(right))</span><br><span class="line">		<span class="comment">// 再把剩下的非相等条件以 Filter 的形式覆盖上去  </span></span><br><span class="line">        condition.map(<span class="type">Filter</span>(_, semiJoin)).getOrElse(semiJoin) :: <span class="type">Nil</span></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">LeftSemi</span>, leftKeys, rightKeys, condition, left, right) =&gt;</span><br><span class="line">	    <span class="comment">// 情况基本同上，只是这里改为使用 LeftSemiJoinHash 实例</span></span><br><span class="line">        <span class="keyword">val</span> semiJoin = joins.<span class="type">LeftSemiJoinHash</span>(</span><br><span class="line">          leftKeys, rightKeys, planLater(left), planLater(right))</span><br><span class="line">        condition.map(<span class="type">Filter</span>(_, semiJoin)).getOrElse(semiJoin) :: <span class="type">Nil</span></span><br><span class="line">      <span class="comment">// no predicate can be evaluated by matching hash keys</span></span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, <span class="type">LeftSemi</span>, condition) =&gt;</span><br><span class="line">	    <span class="comment">// 剩下的 Left Semi Join 就直接变成 LeftSemiJoinBNL 实例</span></span><br><span class="line">        joins.<span class="type">LeftSemiJoinBNL</span>(planLater(left), planLater(right), condition) :: <span class="type">Nil</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 到这里，Left Semi Join 已经全部由上面那个 Strategy 变成 Physical Plan 了</span></span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">HashJoin</span> <span class="keyword">extends</span> <span class="title">Strategy</span> <span class="keyword">with</span> <span class="title">PredicateHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">makeBroadcastHashJoin</span></span>(</span><br><span class="line">        leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span><br><span class="line">        rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span><br><span class="line">        left: <span class="type">LogicalPlan</span>,</span><br><span class="line">        right: <span class="type">LogicalPlan</span>,</span><br><span class="line">        condition: <span class="type">Option</span>[<span class="type">Expression</span>],</span><br><span class="line">        side: joins.<span class="type">BuildSide</span>) = &#123;</span><br><span class="line">		<span class="comment">// 产生一个 BroadcastHashJoin 实例，并用 Filter 把剩余的 condition 盖了上去</span></span><br><span class="line">      <span class="keyword">val</span> broadcastHashJoin = execution.joins.<span class="type">BroadcastHashJoin</span>(</span><br><span class="line">        leftKeys, rightKeys, side, planLater(left), planLater(right))</span><br><span class="line">      condition.map(<span class="type">Filter</span>(_, broadcastHashJoin)).getOrElse(broadcastHashJoin) :: <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Seq</span>[<span class="type">SparkPlan</span>] = plan <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">Inner</span>, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="keyword">if</span> sqlContext.conf.autoBroadcastJoinThreshold &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           right.statistics.sizeInBytes &lt;= sqlContext.conf.autoBroadcastJoinThreshold =&gt;</span><br><span class="line">		<span class="comment">// Inner Join，ON 里有相等条件，右子树不算大 -&gt; BroadcastHashJoin</span></span><br><span class="line">        makeBroadcastHashJoin(leftKeys, rightKeys, left, right, condition, joins.<span class="type">BuildRight</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">Inner</span>, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="keyword">if</span> sqlContext.conf.autoBroadcastJoinThreshold &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           left.statistics.sizeInBytes &lt;= sqlContext.conf.autoBroadcastJoinThreshold =&gt;</span><br><span class="line">		   <span class="comment">// Inner Join，ON 里有相等条件，左子树不算大 -&gt; BroadcastHashJoin</span></span><br><span class="line">          makeBroadcastHashJoin(leftKeys, rightKeys, left, right, condition, joins.<span class="type">BuildLeft</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">Inner</span>, leftKeys, rightKeys, condition, left, right)</span><br><span class="line">        <span class="keyword">if</span> sqlContext.conf.sortMergeJoinEnabled =&gt;</span><br><span class="line">		<span class="comment">// Inner Join，ON 里有相等条件，sortMergeJoin 设置被开启 -&gt; SortMergeJoin</span></span><br><span class="line">        <span class="keyword">val</span> mergeJoin =</span><br><span class="line">          joins.<span class="type">SortMergeJoin</span>(leftKeys, rightKeys, planLater(left), planLater(right))</span><br><span class="line">        condition.map(<span class="type">Filter</span>(_, mergeJoin)).getOrElse(mergeJoin) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(<span class="type">Inner</span>, leftKeys, rightKeys, condition, left, right) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide =</span><br><span class="line">          <span class="keyword">if</span> (right.statistics.sizeInBytes &lt;= left.statistics.sizeInBytes) &#123;</span><br><span class="line">            joins.<span class="type">BuildRight</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            joins.<span class="type">BuildLeft</span></span><br><span class="line">          &#125;</span><br><span class="line">		<span class="comment">// Inner Join，ON 里有相等条件 -&gt; ShuffledHashJoin，以较小的一边作为 buildSide</span></span><br><span class="line">        <span class="keyword">val</span> hashJoin = joins.<span class="type">ShuffledHashJoin</span>(</span><br><span class="line">          leftKeys, rightKeys, buildSide, planLater(left), planLater(right))</span><br><span class="line">        condition.map(<span class="type">Filter</span>(_, hashJoin)).getOrElse(hashJoin) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">ExtractEquiJoinKeys</span>(joinType, leftKeys, rightKeys, condition, left, right) =&gt;</span><br><span class="line">	  <span class="comment">// ON 里有相等条件 -&gt; HashOuterJoin</span></span><br><span class="line">        joins.<span class="type">HashOuterJoin</span>(</span><br><span class="line">          leftKeys, rightKeys, joinType, condition, planLater(left), planLater(right)) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">CartesianProduct</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Seq</span>[<span class="type">SparkPlan</span>] = plan <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, _, <span class="type">None</span>) =&gt;</span><br><span class="line">	    <span class="comment">// 没有 ON 语句 -&gt; CartesianProduct</span></span><br><span class="line">        execution.joins.<span class="type">CartesianProduct</span>(planLater(left), planLater(right)) :: <span class="type">Nil</span></span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, <span class="type">Inner</span>, <span class="type">Some</span>(condition)) =&gt;</span><br><span class="line">	    <span class="comment">// Inner Join，有 ON 语句 -&gt; CartesianProduct 再盖一个 Filter</span></span><br><span class="line">        execution.<span class="type">Filter</span>(condition,</span><br><span class="line">          execution.joins.<span class="type">CartesianProduct</span>(planLater(left), planLater(right))) :: <span class="type">Nil</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">object</span> <span class="title">BroadcastNestedLoopJoin</span> <span class="keyword">extends</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(plan: <span class="type">LogicalPlan</span>): <span class="type">Seq</span>[<span class="type">SparkPlan</span>] = plan <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> logical.<span class="type">Join</span>(left, right, joinType, condition) =&gt;</span><br><span class="line">        <span class="keyword">val</span> buildSide =</span><br><span class="line">          <span class="keyword">if</span> (right.statistics.sizeInBytes &lt;= left.statistics.sizeInBytes) &#123;</span><br><span class="line">            joins.<span class="type">BuildRight</span></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            joins.<span class="type">BuildLeft</span></span><br><span class="line">          &#125;</span><br><span class="line">		<span class="comment">// 剩下的 JOIN -&gt; 以较小一侧为 buildSide 的 BroadcastNestedLoopJoin</span></span><br><span class="line">        joins.<span class="type">BroadcastNestedLoopJoin</span>(</span><br><span class="line">          planLater(left), planLater(right), buildSide, joinType, condition) :: <span class="type">Nil</span></span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="type">Nil</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>通过阅读上述代码，我们找到了如下几个与 JOIN 有关的 SparkPlan：</p>
<ul>
  <li>`BroadcastLeftSemiJoinHash`：Left Semi Join，ON 中存在相等条件，右子树小于阈值（默认 10MB）</li>
  <li>`LeftSemiJoinHash`：Left Semi Join，ON 中存在相等条件</li>
  <li>`LeftSemiJoinBNL`：Left Semi Join</li>
  <li>`BroadcastHashJoin`：Inner Join，ON 里有相等条件，左子树或右子树小于阈值（默认 10MB）。以较小的一侧为 BuildSide</li>
  <li>`SortMergeJoin`：Inner Join，ON 里有相等条件，sortMergeJoin 设置被开启</li>
  <li>`ShuffledHashJoin`：Inner Join，ON 里有相等条件。以较小的一侧为 buildSide。</li>
  <li>`HashOuterJoin`：ON 里有相等条件</li>
  <li>`CartesianProduct`：Inner Join，有 ON 语句</li>
  <li>`CartesianProduct`：没有 ON 语句</li>
  <li>`BroadcastNestedLoopJoin`：剩下的都是它</li>
</ul>

<p>足足 10 种用于 Join 的 Physical Plan。看来 SparkSQL 也知道这是最关键的操作。接下来我们逐个解析这些 Plan。</p>
<h2 id="Physical-Plan"><a href="#Physical-Plan" class="headerlink" title="Physical Plan"></a>Physical Plan</h2><h3 id="BroadcastLeftSemiJoinHash"><a href="#BroadcastLeftSemiJoinHash" class="headerlink" title="BroadcastLeftSemiJoinHash"></a>BroadcastLeftSemiJoinHash</h3><p>准入条件：Left Semi Join，ON 中存在相等条件，右子树小于阈值（默认 10MB）</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastLeftSemiJoinHash</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> <span class="keyword">with</span> <span class="title">HashJoin</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继承自 HashJoin</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，在看之前我们先看看 <code>HashJoin</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HashJoin</span> </span>&#123;</span><br><span class="line">  self: <span class="type">SparkPlan</span> =&gt;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这些成员大部分由子类的构造函数传入</span></span><br><span class="line">  <span class="keyword">val</span> leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>]</span><br><span class="line">  <span class="keyword">val</span> rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>]</span><br><span class="line">  <span class="keyword">val</span> buildSide: <span class="type">BuildSide</span>  <span class="comment">// 只有两个子类 case object：BuildLeft 和 BuildRight</span></span><br><span class="line">  <span class="keyword">val</span> left: <span class="type">SparkPlan</span></span><br><span class="line">  <span class="keyword">val</span> right: <span class="type">SparkPlan</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// buildPlan 为 buildSide 指定的那边的 SparkPlan，streamedPlan 则为剩下那个</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> (buildPlan, streamedPlan) = buildSide <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BuildLeft</span> =&gt; (left, right)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BuildRight</span> =&gt; (right, left)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// buildKeys 为 buildSide 指定的那边的 keys，streamedKeys 则为剩下那边的 keys</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> (buildKeys, streamedKeys) = buildSide <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BuildLeft</span> =&gt; (leftKeys, rightKeys)</span><br><span class="line">    <span class="keyword">case</span> <span class="type">BuildRight</span> =&gt; (rightKeys, leftKeys)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output ++ right.output</span><br><span class="line"></span><br><span class="line">  <span class="comment">// abstract class Projection extends (Row =&gt; Row)</span></span><br><span class="line">  <span class="comment">// 根据 key 和 output 生成了一个 key generator</span></span><br><span class="line">  <span class="comment">// 子类会使用这个 generator 为每个 Row 生成一个 key(也是一个 Row)并放入到 HashSet 或 HashMap</span></span><br><span class="line">  <span class="comment">// 想必这个 key 应该实现了比较高效的 hashCode 方法</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> buildSideKeyGenerator: <span class="type">Projection</span> =</span><br><span class="line">    newProjection(buildKeys, buildPlan.output)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 同理</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> streamSideKeyGenerator: () =&gt; <span class="type">MutableProjection</span> =</span><br><span class="line">    newMutableProjection(streamedKeys, streamedPlan.output)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 直接看比较复杂，等用到时我们再进行解析</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">hashJoin</span></span>(streamIter: <span class="type">Iterator</span>[<span class="type">Row</span>], hashedRelation: <span class="type">HashedRelation</span>): <span class="type">Iterator</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好，我们再回到 <code>BroadcastLeftSemiJoinHash</code>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastLeftSemiJoinHash</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> <span class="keyword">with</span> <span class="title">HashJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以右子树为 buildSide</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> buildSide: <span class="type">BuildSide</span> = <span class="type">BuildRight</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出属性集与左子树相同</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SparkPlan 入口方法</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 获取右子树结果集</span></span><br><span class="line">    <span class="keyword">val</span> buildIter = buildPlan.execute().map(_.copy()).collect().toIterator</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">val</span> hashSet = <span class="keyword">new</span> java.util.<span class="type">HashSet</span>[<span class="type">Row</span>]()</span><br><span class="line">    <span class="keyword">var</span> currentRow: <span class="type">Row</span> = <span class="literal">null</span></span><br><span class="line">    <span class="comment">// 利用右子树结果集构建一个 key 的 HashSet</span></span><br><span class="line">    <span class="keyword">while</span> (buildIter.hasNext) &#123;</span><br><span class="line">      currentRow = buildIter.next()</span><br><span class="line">	  <span class="comment">// 利用 buildSideKeyGenerator 为右子树结果集的每个 Row 都生成一个 key</span></span><br><span class="line">      <span class="keyword">val</span> rowKey = buildSideKeyGenerator(currentRow)</span><br><span class="line">      <span class="keyword">if</span> (!rowKey.anyNull) &#123;</span><br><span class="line">        <span class="keyword">val</span> keyExists = hashSet.contains(rowKey)</span><br><span class="line">        <span class="keyword">if</span> (!keyExists) &#123;</span><br><span class="line">		  <span class="comment">// key 们放入到 hashSet 中</span></span><br><span class="line">          hashSet.add(rowKey)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将 hashSet 广播出去</span></span><br><span class="line">    <span class="keyword">val</span> broadcastedRelation = sparkContext.broadcast(hashSet)</span><br><span class="line"></span><br><span class="line">    streamedPlan.execute().mapPartitions &#123; streamIter =&gt;</span><br><span class="line">	  <span class="comment">// 利用 streamSideKeyGenerator 为左子树的 Row 生成 key</span></span><br><span class="line">      <span class="keyword">val</span> joinKeys = streamSideKeyGenerator()</span><br><span class="line">      streamIter.filter(current =&gt; &#123;</span><br><span class="line">        !joinKeys(current).anyNull &amp;&amp; broadcastedRelation.value.contains(joinKeys.currentValue)</span><br><span class="line">		<span class="comment">// 在之前的 hashSet 中包含本 key，则放入到结果集中</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先，在实例化结果 RDD 的时候，右子树的结果就已经计算完毕并被收集回来，将右子树的 Row 变为 key 并放入 HashSet 再广播出去的动作将由 Master 独自完成。在结果 RDD 的 <code>collect</code> 或其他方法被调用的时候，左子树的每个 Partition 同样会将自己的 Row 变为 key，并与之前广播的 HashSet 中的元素进行比对，返回 key 存在于 HashSet 中的记录。</p>
<p>RDD 的计算本该是 lazy 的。诚然，这里左子树的计算确实是 lazy 的，但右子树不是，右子树在 RDD 实例化的时候就已经计算完毕了，因此该方法不太适用于较大的右子树。不过，能产生这种 SparkPlan 本来就要求 LeftSemiJoin 操作右子树的 Statistics 值小于一定的阈值，因此这样做还是合理的。</p>
<h3 id="LeftSemiJoinHash"><a href="#LeftSemiJoinHash" class="headerlink" title="LeftSemiJoinHash"></a>LeftSemiJoinHash</h3><p>准入条件：Left Semi Join，ON 中存在相等条件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftSemiJoinHash</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> <span class="keyword">with</span> <span class="title">HashJoin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样以右子树作为 BuildSide	</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> buildSide: <span class="type">BuildSide</span> = <span class="type">BuildRight</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表明对于 leftKeys 以及 rightKeys 的每个属性，具有相同值的 Row 可能分散在不同的 Partition 中</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildDistribution</span></span>: <span class="type">Seq</span>[<span class="type">ClusteredDistribution</span>] =</span><br><span class="line">    <span class="type">ClusteredDistribution</span>(leftKeys) :: <span class="type">ClusteredDistribution</span>(rightKeys) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同样直接以左子树的输入作为输出	</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 先计算出右子树的结果 RDD</span></span><br><span class="line">	<span class="comment">// 再把左右子树的 Partition 们 zip 起来（意味着左右子树的结果 Partition 数相同）</span></span><br><span class="line">    buildPlan.execute().zipPartitions(streamedPlan.execute()) &#123; (buildIter, streamIter) =&gt;</span><br><span class="line">	  <span class="comment">// 在 zip 起来的 Partition 内采取了和之前一样的算法</span></span><br><span class="line">      <span class="keyword">val</span> hashSet = <span class="keyword">new</span> java.util.<span class="type">HashSet</span>[<span class="type">Row</span>]()</span><br><span class="line">      <span class="keyword">var</span> currentRow: <span class="type">Row</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a Hash set of buildKeys</span></span><br><span class="line">	  <span class="comment">// 先构建右子树的 key set</span></span><br><span class="line">      <span class="keyword">while</span> (buildIter.hasNext) &#123;</span><br><span class="line">        currentRow = buildIter.next()</span><br><span class="line">        <span class="keyword">val</span> rowKey = buildSideKeyGenerator(currentRow)</span><br><span class="line">        <span class="keyword">if</span> (!rowKey.anyNull) &#123;</span><br><span class="line">          <span class="keyword">val</span> keyExists = hashSet.contains(rowKey)</span><br><span class="line">          <span class="keyword">if</span> (!keyExists) &#123;</span><br><span class="line">            hashSet.add(rowKey)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 再从左子树中筛选返回</span></span><br><span class="line">      <span class="keyword">val</span> joinKeys = streamSideKeyGenerator()</span><br><span class="line">      streamIter.filter(current =&gt; &#123;</span><br><span class="line">        !joinKeys(current).anyNull &amp;&amp; hashSet.contains(joinKeys.currentValue)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，其核心算法本身和 <code>BroadcastLeftSemiJoinHash</code> 并无不同，但却使用了 <code>zipPartitions</code> 方法来计算两个 RDD 的 Join 结果。如果要确保结果完全正确，就需要两个 RDD 的 Partition 数相同，同时在 key 上有着相同值的 Row 必然处于 index 相同的 Partition 内。我暂时无法理解 SparkSQL 要如何保证这两个条件同时满足，只能先放一放了。</p>
<h3 id="LeftSemiJoinBN"><a href="#LeftSemiJoinBN" class="headerlink" title="LeftSemiJoinBN"></a>LeftSemiJoinBN</h3><p>准入条件：Left Semi Join</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftSemiJoinBNL</span>(<span class="params">streamed: <span class="type">SparkPlan</span>, broadcast: <span class="type">SparkPlan</span>, condition: <span class="type">Option</span>[<span class="type">Expression</span>]</span>)</span></span><br><span class="line"><span class="comment">// 注：实例化时传入的 streamed 为左子树，broadcast 为右子树</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">BinaryNode</span> &#123;</span><br><span class="line">  <span class="comment">// 由于 ON 语句中不再有相等条件，因此该算法也不使用 HashSet 来查找相同元素了</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">left</span></span>: <span class="type">SparkPlan</span> = streamed</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">right</span></span>: <span class="type">SparkPlan</span> = broadcast</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 输出的属性与 Partition 方法与左子树保持一致</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputPartitioning</span></span>: <span class="type">Partitioning</span> = streamed.outputPartitioning</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据传入的 ON condition 生成了一个(Row) =&gt; Boolean</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> boundCondition =</span><br><span class="line">    newPredicate(condition.getOrElse(<span class="type">Literal</span>(<span class="literal">true</span>)), left.output ++ right.output)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 计算右子树并把结果广播出去</span></span><br><span class="line">    <span class="keyword">val</span> broadcastedRelation =</span><br><span class="line">      sparkContext.broadcast(broadcast.execute().map(_.copy()).collect().toIndexedSeq)</span><br><span class="line"></span><br><span class="line">    streamed.execute().mapPartitions &#123; streamedIter =&gt;</span><br><span class="line">      <span class="keyword">val</span> joinedRow = <span class="keyword">new</span> <span class="type">JoinedRow</span></span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 筛选吻合的行</span></span><br><span class="line">      streamedIter.filter(streamedRow =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> matched = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 遍历右子树结果，并在找到第一个匹配结果的时候结束循环</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; broadcastedRelation.value.size &amp;&amp; !matched) &#123;</span><br><span class="line">          <span class="keyword">val</span> broadcastedRow = broadcastedRelation.value(i)</span><br><span class="line">		  <span class="comment">// 利用当前的两个 Row 生成一个 JoinedRow 并验证是否吻合条件</span></span><br><span class="line">          <span class="keyword">if</span> (boundCondition(joinedRow(streamedRow, broadcastedRow))) &#123;</span><br><span class="line">            matched = <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        matched</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没什么特别，相当好理解。</p>
<h3 id="BroadcastHashJoin"><a href="#BroadcastHashJoin" class="headerlink" title="BroadcastHashJoin"></a>BroadcastHashJoin</h3><p>准入条件：Inner Join，ON 里有相等条件，左子树或右子树小于阈值（默认 10MB），以较小的一侧为 BuildSide</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHashJoin</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    buildSide: <span class="type">BuildSide</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">BinaryNode</span> <span class="keyword">with</span> <span class="type">HashJoin</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> timeout: <span class="type">Duration</span> = &#123;</span><br><span class="line">    <span class="comment">// 默认为 5*60，即 5 分钟</span></span><br><span class="line">    <span class="keyword">val</span> timeoutValue = sqlContext.conf.broadcastTimeout</span><br><span class="line">    <span class="keyword">if</span> (timeoutValue &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="type">Duration</span>.<span class="type">Inf</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeoutValue.seconds</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputPartitioning</span></span>: <span class="type">Partitioning</span> = streamedPlan.outputPartitioning</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildDistribution</span></span>: <span class="type">Seq</span>[<span class="type">Distribution</span>] =</span><br><span class="line">    <span class="type">UnspecifiedDistribution</span> :: <span class="type">UnspecifiedDistribution</span> :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动一个异步计算</span></span><br><span class="line">  <span class="meta">@transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> broadcastFuture = future &#123;</span><br><span class="line">    <span class="comment">// Note that we use .execute().collect() because we don&#x27;t want to convert data to Scala types</span></span><br><span class="line">	<span class="comment">// 收集较小子树的结果</span></span><br><span class="line">    <span class="keyword">val</span> input: <span class="type">Array</span>[<span class="type">Row</span>] = buildPlan.execute().map(_.copy()).collect()</span><br><span class="line">	<span class="comment">// 生成一个 Key 到 Row(s)的 HashMap 并广播出去</span></span><br><span class="line">    <span class="keyword">val</span> hashed = <span class="type">HashedRelation</span>(input.iterator, buildSideKeyGenerator, input.length)</span><br><span class="line">    sparkContext.broadcast(hashed)</span><br><span class="line">  &#125;(<span class="type">BroadcastHashJoin</span>.broadcastHashJoinExecutionContext)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 等待异步计算完成</span></span><br><span class="line">    <span class="keyword">val</span> broadcastRelation = <span class="type">Await</span>.result(broadcastFuture, timeout)</span><br><span class="line"></span><br><span class="line">    streamedPlan.execute().mapPartitions &#123; streamedIter =&gt;</span><br><span class="line">      hashJoin(streamedIter, broadcastRelation.value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看到，在最后 <code>BroadcastHashJoin</code> 调用了父类 <code>HashJoin</code> 的 <code>hashJoin</code> 方法。我们来看看那个方法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">HashJoin</span> </span>&#123;</span><br><span class="line">  self: <span class="type">SparkPlan</span> =&gt;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参考上面，这里传入的 hashedRelation 实际上是 Key 到 Row(s)的 HashMap</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">hashJoin</span></span>(streamIter: <span class="type">Iterator</span>[<span class="type">Row</span>], hashedRelation: <span class="type">HashedRelation</span>): <span class="type">Iterator</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">Row</span>] &#123;</span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> currentStreamedRow: <span class="type">Row</span> = _</span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> currentHashMatches: <span class="type">CompactBuffer</span>[<span class="type">Row</span>] = _</span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> currentMatchPosition: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> joinRow = <span class="keyword">new</span> <span class="type">JoinedRow2</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> joinKeys = streamSideKeyGenerator()</span><br><span class="line">	  </span><br><span class="line">	  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	   * 这里我们需要考虑我们平常使用 Iterator 的方式，基本都是这样：</span></span><br><span class="line"><span class="comment">	   * while (iterator.hasNext) &#123;</span></span><br><span class="line"><span class="comment">	   *    sth = iterator.next </span></span><br><span class="line"><span class="comment">	   *    ..</span></span><br><span class="line"><span class="comment">	   * &#125;</span></span><br><span class="line"><span class="comment">	   * 意味着 hasNext 和 next 会被交替调用</span></span><br><span class="line"><span class="comment">	   */</span></span><br><span class="line">	  <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> =</span><br><span class="line">        (currentMatchPosition != <span class="number">-1</span> &amp;&amp; currentMatchPosition &lt; currentHashMatches.size) ||</span><br><span class="line">          (streamIter.hasNext &amp;&amp; fetchNext())</span><br><span class="line">	  <span class="comment">// 在最初时，我们会先调用 hasNext，这里进入第二条条件判断式，fetchNext 被调用，获取到一个 currentHashMatches</span></span><br><span class="line">      <span class="comment">// 接下来，hasNext 在第一条条件判断式就会返回 true，第二条被短路。我们通过调用 next，让迭代器遍历 currentHashMatches</span></span><br><span class="line">      <span class="comment">// 当一个 currentHashMatches 被遍历完毕，第一条条件判断式会返回 false，这里就会进入第二条条件判断式，由 fetchNext 获取下一个 currentHashMatches</span></span><br><span class="line">	  <span class="comment">// 综上，当且仅当 fetchNext 或 streamIter.hasNext 返回 false 时（实际上 fetchNext 也只有在!streamIter.hasNext 时才会返回 false），这里会返回 false</span></span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">Row</span> = &#123;</span><br><span class="line">	    <span class="comment">// 遍历在 fetchNext 中拿到的 currentHashMatches，生成 JoinedRow</span></span><br><span class="line">        <span class="keyword">val</span> ret = buildSide <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">BuildRight</span> =&gt; joinRow(currentStreamedRow, currentHashMatches(currentMatchPosition))</span><br><span class="line">          <span class="keyword">case</span> <span class="type">BuildLeft</span> =&gt; joinRow(currentHashMatches(currentMatchPosition), currentStreamedRow)</span><br><span class="line">        &#125;</span><br><span class="line">        currentMatchPosition += <span class="number">1</span></span><br><span class="line">        ret</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 找到下一个 streamSide 中吻合的条目</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">fetchNext</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">        currentHashMatches = <span class="literal">null</span></span><br><span class="line">        currentMatchPosition = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找到一个吻合的条目并退出循环</span></span><br><span class="line">        <span class="keyword">while</span> (currentHashMatches == <span class="literal">null</span> &amp;&amp; streamIter.hasNext) &#123;</span><br><span class="line">          currentStreamedRow = streamIter.next()</span><br><span class="line">          <span class="keyword">if</span> (!joinKeys(currentStreamedRow).anyNull) &#123;</span><br><span class="line">            currentHashMatches = hashedRelation.get(joinKeys.currentValue)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentHashMatches == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="literal">false</span> <span class="comment">// streamIter 已完成遍历，故该迭代器也已完成遍历，返回 false</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		  <span class="comment">// 找到吻合的条目，迭代器再次初始化</span></span><br><span class="line">          currentMatchPosition = <span class="number">0</span></span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>嗯，这背后确实是个标准的 Hash Join 算法，但我必须得说，这写得实在是太巧妙了。</p>
<p><code>BroadcastHashJoin</code> 实际上和 <code>BroadcastLeftSemiJoinHash</code> 很像，但后者的 buildSide 结果的收集是在 <code>doExecute</code> 被调用时进行，而前者在实例化时就已经以一个异步计算的形式开始了。考虑到 SparkSQL 的各种 lazy 变量，实际上前者的计算的启动时机比后者要早很多。前者在 <code>planner.plan</code> 的时候就已经开始了，而后者则要等到 <code>QueryExecution#toRDD</code>。</p>
<h3 id="SortMergeJoin"><a href="#SortMergeJoin" class="headerlink" title="SortMergeJoin"></a>SortMergeJoin</h3><p>准入条件：Inner Join，ON 里有相等条件，sortMergeJoin 设置被开启</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">SortMergeJoin</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output ++ right.output</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputPartitioning</span></span>: <span class="type">Partitioning</span> = left.outputPartitioning</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildDistribution</span></span>: <span class="type">Seq</span>[<span class="type">Distribution</span>] =</span><br><span class="line">    <span class="type">ClusteredDistribution</span>(leftKeys) :: <span class="type">ClusteredDistribution</span>(rightKeys) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// this is to manually construct an ordering that can be used to compare keys from both sides</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> keyOrdering: <span class="type">RowOrdering</span> = <span class="type">RowOrdering</span>.forSchema(leftKeys.map(_.dataType))</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredOrders</span></span>(keys: <span class="type">Seq</span>[<span class="type">Expression</span>]): <span class="type">Seq</span>[<span class="type">SortOrder</span>] =</span><br><span class="line">    keys.map(<span class="type">SortOrder</span>(_, <span class="type">Ascending</span>))</span><br><span class="line">  <span class="comment">// 左右子树出现在 ON 相等表达式中的属性按升序排序</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputOrdering</span></span>: <span class="type">Seq</span>[<span class="type">SortOrder</span>] = requiredOrders(leftKeys)</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildOrdering</span></span>: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">SortOrder</span>]] =</span><br><span class="line">    requiredOrders(leftKeys) :: requiredOrders(rightKeys) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类似 HashJoin 的 key generator	</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> leftKeyGenerator = newProjection(leftKeys, left.output)</span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">protected</span> <span class="keyword">lazy</span> <span class="keyword">val</span> rightKeyGenerator = newProjection(rightKeys, right.output)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 或许到左右子树的结果 RDD</span></span><br><span class="line">    <span class="keyword">val</span> leftResults = left.execute().map(_.copy())</span><br><span class="line">    <span class="keyword">val</span> rightResults = right.execute().map(_.copy())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 左右子树的 Partition 们 zip 起来</span></span><br><span class="line">    leftResults.zipPartitions(rightResults) &#123; (leftIter, rightIter) =&gt;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">Row</span>] &#123;</span><br><span class="line">        <span class="comment">// Mutable per row objects.</span></span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> joinRow = <span class="keyword">new</span> <span class="type">JoinedRow5</span></span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> leftElement: <span class="type">Row</span> = _</span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> rightElement: <span class="type">Row</span> = _</span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> leftKey: <span class="type">Row</span> = _</span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> rightKey: <span class="type">Row</span> = _</span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> rightMatches: <span class="type">CompactBuffer</span>[<span class="type">Row</span>] = _</span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> rightPosition: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> stop: <span class="type">Boolean</span> = <span class="literal">false</span></span><br><span class="line">        <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">var</span> matchKey: <span class="type">Row</span> = _</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代器初始化</span></span><br><span class="line">        initialize()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将 leftElement 和 rightElement 分别指向左右侧第一个元素，并生成对应的 key</span></span><br><span class="line">		<span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>() = &#123;</span><br><span class="line">          fetchLeft()</span><br><span class="line">          fetchRight()</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 从左子树获取下一个 Row</span></span><br><span class="line">		<span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">fetchLeft</span></span>() = &#123;</span><br><span class="line">          <span class="keyword">if</span> (leftIter.hasNext) &#123;</span><br><span class="line">            leftElement = leftIter.next()</span><br><span class="line">            leftKey = leftKeyGenerator(leftElement)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            leftElement = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 从右子树获取下一个 Row</span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">fetchRight</span></span>() = &#123;</span><br><span class="line">          <span class="keyword">if</span> (rightIter.hasNext) &#123;</span><br><span class="line">            rightElement = rightIter.next()</span><br><span class="line">            rightKey = rightKeyGenerator(rightElement)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rightElement = <span class="literal">null</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 同样考虑刚刚提到的 Iterator 的使用方式</span></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = nextMatchingPair()</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 右迭代器搜索下一个与左侧匹配的条目 </span></span><br><span class="line">        <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">nextMatchingPair</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">          <span class="keyword">if</span> (!stop &amp;&amp; rightElement != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 两边的指针一起跑，以找到第一个配对</span></span><br><span class="line">            <span class="keyword">while</span> (!stop &amp;&amp; leftElement != <span class="literal">null</span> &amp;&amp; rightElement != <span class="literal">null</span>) &#123;</span><br><span class="line">              <span class="keyword">val</span> comparing = keyOrdering.compare(leftKey, rightKey)</span><br><span class="line">			  <span class="comment">// 找到配对，则 stop 为 true，退出当前循环</span></span><br><span class="line">              stop = comparing == <span class="number">0</span> &amp;&amp; !leftKey.anyNull			  </span><br><span class="line">              <span class="keyword">if</span> (comparing &gt; <span class="number">0</span> || rightKey.anyNull) &#123;</span><br><span class="line">                fetchRight() <span class="comment">// 左边比右边大，右边前进一步</span></span><br><span class="line">              &#125; <span class="keyword">else</span> <span class="keyword">if</span> (comparing &lt; <span class="number">0</span> || leftKey.anyNull) &#123;</span><br><span class="line">                fetchLeft() <span class="comment">// 右边比左边大，左边前进一步</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            rightMatches = <span class="keyword">new</span> <span class="type">CompactBuffer</span>[<span class="type">Row</span>]()</span><br><span class="line">            <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">              stop = <span class="literal">false</span></span><br><span class="line">			  <span class="comment">// 将右侧的所有 key 相同的 Row 放入 rightMatches，直到遇到第一个不同的 key</span></span><br><span class="line">              <span class="keyword">while</span> (!stop &amp;&amp; rightElement != <span class="literal">null</span>) &#123;</span><br><span class="line">                rightMatches += rightElement</span><br><span class="line">                fetchRight()</span><br><span class="line">                stop = keyOrdering.compare(leftKey, rightKey) != <span class="number">0</span></span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (rightMatches.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                rightPosition = <span class="number">0</span></span><br><span class="line">                matchKey = leftKey</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          rightMatches != <span class="literal">null</span> &amp;&amp; rightMatches.size &gt; <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">Row</span> = &#123;</span><br><span class="line">          <span class="keyword">if</span> (hasNext) &#123;</span><br><span class="line">            <span class="keyword">val</span> joinedRow = joinRow(leftElement, rightMatches(rightPosition))</span><br><span class="line">            rightPosition += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> (rightPosition &gt;= rightMatches.size) &#123;</span><br><span class="line">              rightPosition = <span class="number">0</span></span><br><span class="line">              fetchLeft() <span class="comment">// 右侧匹配条目收集完毕，左侧前进一步</span></span><br><span class="line">              <span class="keyword">if</span> (leftElement == <span class="literal">null</span> || keyOrdering.compare(leftKey, matchKey) != <span class="number">0</span>) &#123;</span><br><span class="line">                stop = <span class="literal">false</span> <span class="comment">// stop 置为 false，hasNext 继续寻找下一对配对</span></span><br><span class="line">                rightMatches = <span class="literal">null</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            joinedRow</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// no more result</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">NoSuchElementException</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然算法不相同，但迭代器的设计思想上，<code>SortMergeJoin</code> 和 <code>BroadcastHashJoin</code> 还是很像的，只是前者的迭代器在 <code>next</code> 方法里调用了 <code>hasNext</code>，这样的设计更为安全，而后者如果在 <code>next</code> 之前没有调用过 <code>hasNext</code> 则会直接出错。</p>
<h3 id="ShuffledHashJoin"><a href="#ShuffledHashJoin" class="headerlink" title="ShuffledHashJoin"></a>ShuffledHashJoin</h3><p>准入条件：Inner Join，ON 里有相等条件。以较小的一侧为 buildSide。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">ShuffledHashJoin</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    buildSide: <span class="type">BuildSide</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">BinaryNode</span> <span class="keyword">with</span> <span class="type">HashJoin</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputPartitioning</span></span>: <span class="type">Partitioning</span> = left.outputPartitioning</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildDistribution</span></span>: <span class="type">Seq</span>[<span class="type">ClusteredDistribution</span>] =</span><br><span class="line">    <span class="type">ClusteredDistribution</span>(leftKeys) :: <span class="type">ClusteredDistribution</span>(rightKeys) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    buildPlan.execute().zipPartitions(streamedPlan.execute()) &#123; (buildIter, streamIter) =&gt;</span><br><span class="line">      <span class="keyword">val</span> hashed = <span class="type">HashedRelation</span>(buildIter, buildSideKeyGenerator)</span><br><span class="line">      hashJoin(streamIter, hashed)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好像没什么需要说的，十分直观。</p>
<h3 id="HashOuterJoin"><a href="#HashOuterJoin" class="headerlink" title="HashOuterJoin"></a>HashOuterJoin</h3><p>准入条件：ON 里有相等条件</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">HashOuterJoin</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    leftKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    rightKeys: <span class="type">Seq</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    joinType: <span class="type">JoinType</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    condition: <span class="type">Option</span>[<span class="type">Expression</span>],</span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从这里看得出来，HashOuterJoin 同时接受三种 Outer Join，只要它们的 ON 里有相等条件</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">outputPartitioning</span></span>: <span class="type">Partitioning</span> = joinType <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">LeftOuter</span> =&gt; left.outputPartitioning</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RightOuter</span> =&gt; right.outputPartitioning</span><br><span class="line">    <span class="keyword">case</span> <span class="type">FullOuter</span> =&gt; <span class="type">UnknownPartitioning</span>(left.outputPartitioning.numPartitions)</span><br><span class="line">    <span class="keyword">case</span> x =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">s&quot;HashOuterJoin should not take <span class="subst">$x</span> as the JoinType&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">requiredChildDistribution</span></span>: <span class="type">Seq</span>[<span class="type">ClusteredDistribution</span>] =</span><br><span class="line">    <span class="type">ClusteredDistribution</span>(leftKeys) :: <span class="type">ClusteredDistribution</span>(rightKeys) :: <span class="type">Nil</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = &#123;</span><br><span class="line">    joinType <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">LeftOuter</span> =&gt;</span><br><span class="line">        left.output ++ right.output.map(_.withNullability(<span class="literal">true</span>))</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RightOuter</span> =&gt;</span><br><span class="line">        left.output.map(_.withNullability(<span class="literal">true</span>)) ++ right.output</span><br><span class="line">      <span class="keyword">case</span> <span class="type">FullOuter</span> =&gt;</span><br><span class="line">        left.output.map(_.withNullability(<span class="literal">true</span>)) ++ right.output.map(_.withNullability(<span class="literal">true</span>))</span><br><span class="line">      <span class="keyword">case</span> x =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">s&quot;HashOuterJoin should not take <span class="subst">$x</span> as the JoinType&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">DUMMY_LIST</span> = <span class="type">Seq</span>[<span class="type">Row</span>](<span class="literal">null</span>)</span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> <span class="type">EMPTY_LIST</span> = <span class="type">Seq</span>.empty[<span class="type">Row</span>]</span><br><span class="line"></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> leftNullRow = <span class="keyword">new</span> <span class="type">GenericRow</span>(left.output.length)</span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> rightNullRow = <span class="keyword">new</span> <span class="type">GenericRow</span>(right.output.length)</span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">lazy</span> <span class="keyword">val</span> boundCondition =</span><br><span class="line">    condition.map(newPredicate(_, left.output ++ right.output)).getOrElse((row: <span class="type">Row</span>) =&gt; <span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出于性能考虑，SparkSQL 自行实现了三种迭代器</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">leftOuterIterator</span></span>(</span><br><span class="line">  <span class="comment">// 注意：这里传入的 joinedRow 的 left 已经设定，key 就是 left 的 key。见 doExecute</span></span><br><span class="line">      key: <span class="type">Row</span>, joinedRow: <span class="type">JoinedRow</span>, rightIter: <span class="type">Iterable</span>[<span class="type">Row</span>]): <span class="type">Iterator</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> ret: <span class="type">Iterable</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">      <span class="keyword">if</span> (!key.anyNull) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = rightIter.collect &#123;</span><br><span class="line">          <span class="keyword">case</span> r <span class="keyword">if</span> boundCondition(joinedRow.withRight(r)) =&gt; joinedRow.copy()</span><br><span class="line">        &#125;  <span class="comment">// 收集右侧所有匹配的条目</span></span><br><span class="line">        <span class="keyword">if</span> (temp.size == <span class="number">0</span>) &#123;</span><br><span class="line">          joinedRow.withRight(rightNullRow).copy :: <span class="type">Nil</span> <span class="comment">// 没有收集到，直接返回个 NULL</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          temp <span class="comment">// 收集到了，就全部输出</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        joinedRow.withRight(rightNullRow).copy :: <span class="type">Nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.iterator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同上，轴对称一下而已</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">rightOuterIterator</span></span>(</span><br><span class="line">      key: <span class="type">Row</span>, leftIter: <span class="type">Iterable</span>[<span class="type">Row</span>], joinedRow: <span class="type">JoinedRow</span>): <span class="type">Iterator</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ret: <span class="type">Iterable</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">      <span class="keyword">if</span> (!key.anyNull) &#123;</span><br><span class="line">        <span class="keyword">val</span> temp = leftIter.collect &#123;</span><br><span class="line">          <span class="keyword">case</span> l <span class="keyword">if</span> boundCondition(joinedRow.withLeft(l)) =&gt; joinedRow.copy</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp.size == <span class="number">0</span>) &#123;</span><br><span class="line">          joinedRow.withLeft(leftNullRow).copy :: <span class="type">Nil</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          temp</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        joinedRow.withLeft(leftNullRow).copy :: <span class="type">Nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ret.iterator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意：这里传入的 key 先是左侧的 key，之后才是右侧的 key</span></span><br><span class="line">  <span class="comment">// leftIter 和 rightIter 则是与该 key 对应的左右侧的 Row。见 doExecute</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">fullOuterIterator</span></span>(</span><br><span class="line">      key: <span class="type">Row</span>, leftIter: <span class="type">Iterable</span>[<span class="type">Row</span>], rightIter: <span class="type">Iterable</span>[<span class="type">Row</span>],</span><br><span class="line">      joinedRow: <span class="type">JoinedRow</span>): <span class="type">Iterator</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!key.anyNull) &#123;</span><br><span class="line">      <span class="comment">// 尝试让传入的左右侧条目在 key 上 Join 一下</span></span><br><span class="line">      <span class="keyword">val</span> rightMatchedSet = scala.collection.mutable.<span class="type">Set</span>[<span class="type">Int</span>]()</span><br><span class="line">      leftIter.iterator.flatMap[<span class="type">Row</span>] &#123; l =&gt;</span><br><span class="line">        joinedRow.withLeft(l)</span><br><span class="line">        <span class="keyword">var</span> matched = <span class="literal">false</span></span><br><span class="line">        rightIter.zipWithIndex.collect &#123;</span><br><span class="line">          <span class="comment">// 1. For those matched (satisfy the join condition) records with both sides filled,</span></span><br><span class="line">          <span class="comment">//    append them directly</span></span><br><span class="line"></span><br><span class="line">		  <span class="comment">// 尝试找到吻合 Inner Join 的左右条目</span></span><br><span class="line">          <span class="keyword">case</span> (r, idx) <span class="keyword">if</span> boundCondition(joinedRow.withRight(r)) =&gt;</span><br><span class="line">            matched = <span class="literal">true</span> <span class="comment">// matched 置为 true，意为当前左条目找到对应的右条目了</span></span><br><span class="line">            <span class="comment">// if the row satisfy the join condition, add its index into the matched set</span></span><br><span class="line">			<span class="comment">// 匹配到的右条目 index 放入 set 里，避免重复输出</span></span><br><span class="line">            rightMatchedSet.add(idx)</span><br><span class="line">            joinedRow.copy()</span><br><span class="line"></span><br><span class="line">        &#125; ++ <span class="type">DUMMY_LIST</span>.filter(_ =&gt; !matched).map( _ =&gt; &#123;</span><br><span class="line">          <span class="comment">// 2. For those unmatched records in left, append additional records with empty right.</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// DUMMY_LIST.filter(_ =&gt; !matched) is a tricky way to add additional row,</span></span><br><span class="line">          <span class="comment">// as we don&#x27;t know whether we need to append it until finish iterating all</span></span><br><span class="line">          <span class="comment">// of the records in right side.</span></span><br><span class="line">          <span class="comment">// If we didn&#x27;t get any proper row, then append a single row with empty right.</span></span><br><span class="line">		  <span class="comment">// 当前左条目没有找到对应的右条目，放入一个 NULL</span></span><br><span class="line">          joinedRow.withRight(rightNullRow).copy()</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; ++ rightIter.zipWithIndex.collect &#123;</span><br><span class="line">        <span class="comment">// 3. For those unmatched records in right, append additional records with empty left.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Re-visiting the records in right, and append additional row with empty left, if its not</span></span><br><span class="line">        <span class="comment">// in the matched set.</span></span><br><span class="line">		<span class="comment">// 对于剩下的（不在之前那个 set 内）的右条目，也放入一个 NULL</span></span><br><span class="line">        <span class="keyword">case</span> (r, idx) <span class="keyword">if</span> !rightMatchedSet.contains(idx) =&gt;</span><br><span class="line">          joinedRow(leftNullRow, r).copy()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  <span class="comment">// key 本身就是个 NULL，那传入的左右侧条目肯定都不能 Join 起来了，直接输出</span></span><br><span class="line">      leftIter.iterator.map[<span class="type">Row</span>] &#123; l =&gt;</span><br><span class="line">        joinedRow(l, rightNullRow).copy()</span><br><span class="line">      &#125; ++ rightIter.iterator.map[<span class="type">Row</span>] &#123; r =&gt;</span><br><span class="line">        joinedRow(leftNullRow, r).copy()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据给定的数据以及 key generator，生成&lt;key, Row(s)&gt;映射。同之前的 hashedRelation</span></span><br><span class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="function"><span class="keyword">def</span> <span class="title">buildHashTable</span></span>(</span><br><span class="line">      iter: <span class="type">Iterator</span>[<span class="type">Row</span>], keyGenerator: <span class="type">Projection</span>): <span class="type">JavaHashMap</span>[<span class="type">Row</span>, <span class="type">CompactBuffer</span>[<span class="type">Row</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> hashTable = <span class="keyword">new</span> <span class="type">JavaHashMap</span>[<span class="type">Row</span>, <span class="type">CompactBuffer</span>[<span class="type">Row</span>]]()</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext) &#123;</span><br><span class="line">      <span class="keyword">val</span> currentRow = iter.next()</span><br><span class="line">      <span class="keyword">val</span> rowKey = keyGenerator(currentRow)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> existingMatchList = hashTable.get(rowKey)</span><br><span class="line">      <span class="keyword">if</span> (existingMatchList == <span class="literal">null</span>) &#123;</span><br><span class="line">        existingMatchList = <span class="keyword">new</span> <span class="type">CompactBuffer</span>[<span class="type">Row</span>]()</span><br><span class="line">        hashTable.put(rowKey, existingMatchList)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      existingMatchList += currentRow.copy()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hashTable</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> joinedRow = <span class="keyword">new</span> <span class="type">JoinedRow</span>()</span><br><span class="line">    left.execute().zipPartitions(right.execute()) &#123; (leftIter, rightIter) =&gt;</span><br><span class="line">	  <span class="comment">// 根据 Join 类型不同分成不同的处理方式</span></span><br><span class="line">      joinType <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">LeftOuter</span> =&gt; <span class="comment">// 左外连接和右外连接的代码可以一起看，感觉就是个逻辑上的轴对称而已 233</span></span><br><span class="line">          <span class="keyword">val</span> rightHashTable = buildHashTable(rightIter, newProjection(rightKeys, right.output))</span><br><span class="line">		  <span class="comment">// 生成右侧的 key row 映射</span></span><br><span class="line">          <span class="keyword">val</span> keyGenerator = newProjection(leftKeys, left.output)</span><br><span class="line">          leftIter.flatMap( currentRow =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> rowKey = keyGenerator(currentRow)</span><br><span class="line">            joinedRow.withLeft(currentRow) <span class="comment">// 它的 right 由 leftOuterIterator 设定</span></span><br><span class="line">            leftOuterIterator(rowKey, joinedRow, rightHashTable.getOrElse(rowKey, <span class="type">EMPTY_LIST</span>))</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="type">RightOuter</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> leftHashTable = buildHashTable(leftIter, newProjection(leftKeys, left.output))</span><br><span class="line">          <span class="keyword">val</span> keyGenerator = newProjection(rightKeys, right.output)</span><br><span class="line">          rightIter.flatMap ( currentRow =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> rowKey = keyGenerator(currentRow)</span><br><span class="line">            joinedRow.withRight(currentRow)</span><br><span class="line">            rightOuterIterator(rowKey, leftHashTable.getOrElse(rowKey, <span class="type">EMPTY_LIST</span>), joinedRow)</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="type">FullOuter</span> =&gt;</span><br><span class="line">          <span class="keyword">val</span> leftHashTable = buildHashTable(leftIter, newProjection(leftKeys, left.output))</span><br><span class="line">          <span class="keyword">val</span> rightHashTable = buildHashTable(rightIter, newProjection(rightKeys, right.output))</span><br><span class="line">          (leftHashTable.keySet ++ rightHashTable.keySet).iterator.flatMap &#123; key =&gt;</span><br><span class="line">            fullOuterIterator(key,</span><br><span class="line">              leftHashTable.getOrElse(key, <span class="type">EMPTY_LIST</span>),</span><br><span class="line">              rightHashTable.getOrElse(key, <span class="type">EMPTY_LIST</span>), joinedRow)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> x =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Exception</span>(<span class="string">s&quot;HashOuterJoin should not take <span class="subst">$x</span> as the JoinType&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看起来有点费劲，写得很是不面向对象，但总体来说并没有什么特别深奥的地方，慢慢看还是可以看得懂的。</p>
<h3 id="CartesianProduct"><a href="#CartesianProduct" class="headerlink" title="CartesianProduct"></a>CartesianProduct</h3><p>准入条件：Inner Join，有 ON 语句；没有 ON 语句</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CartesianProduct</span>(<span class="params">left: <span class="type">SparkPlan</span>, right: <span class="type">SparkPlan</span></span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">output</span></span>: <span class="type">Seq</span>[<span class="type">Attribute</span>] = left.output ++ right.output</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> leftResults = left.execute().map(_.copy())</span><br><span class="line">    <span class="keyword">val</span> rightResults = right.execute().map(_.copy())</span><br><span class="line"></span><br><span class="line">    leftResults.cartesian(rightResults).mapPartitions &#123; iter =&gt;</span><br><span class="line">      <span class="keyword">val</span> joinedRow = <span class="keyword">new</span> <span class="type">JoinedRow</span></span><br><span class="line">      iter.map(r =&gt; joinedRow(r._1, r._2))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是 RDD 的 <code>cartesian</code> 了。</p>
<h3 id="BroadcastNestedLoopJoin"><a href="#BroadcastNestedLoopJoin" class="headerlink" title="BroadcastNestedLoopJoin"></a>BroadcastNestedLoopJoin</h3><p>准入条件：剩下的所有 Join。以较小一侧为 buildSide。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastNestedLoopJoin</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="class">    left: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    right: <span class="type">SparkPlan</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    buildSide: <span class="type">BuildSide</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    joinType: <span class="type">JoinType</span>,</span></span></span><br><span class="line"><span class="params"><span class="class">    condition: <span class="type">Option</span>[<span class="type">Expression</span>]</span>) <span class="keyword">extends</span> <span class="title">BinaryNode</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个，最 General 的 Join Physical Plan 出现了</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doExecute</span></span>(): <span class="type">RDD</span>[<span class="type">Row</span>] = &#123;</span><br><span class="line">    <span class="comment">// 收集 buildSide 侧的计算结果并广播</span></span><br><span class="line">    <span class="keyword">val</span> broadcastedRelation =</span><br><span class="line">      sparkContext.broadcast(broadcast.execute().map(_.copy()).collect().toIndexedSeq)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** All rows that either match both-way, or rows from streamed joined with nulls. */</span></span><br><span class="line">    <span class="keyword">val</span> matchesOrStreamedRowsWithNulls = streamed.execute().mapPartitions &#123; streamedIter =&gt;</span><br><span class="line">      <span class="keyword">val</span> matchedRows = <span class="keyword">new</span> <span class="type">CompactBuffer</span>[<span class="type">Row</span>]</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Use Spark&#x27;s BitSet.</span></span><br><span class="line">      <span class="keyword">val</span> includedBroadcastTuples =</span><br><span class="line">        <span class="keyword">new</span> scala.collection.mutable.<span class="type">BitSet</span>(broadcastedRelation.value.size)</span><br><span class="line">      <span class="keyword">val</span> joinedRow = <span class="keyword">new</span> <span class="type">JoinedRow</span></span><br><span class="line">      <span class="keyword">val</span> leftNulls = <span class="keyword">new</span> <span class="type">GenericMutableRow</span>(left.output.size)</span><br><span class="line">      <span class="keyword">val</span> rightNulls = <span class="keyword">new</span> <span class="type">GenericMutableRow</span>(right.output.size)</span><br><span class="line"></span><br><span class="line">      streamedIter.foreach &#123; streamedRow =&gt;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> streamRowMatched = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 找出所有匹配的 Inner Join 条目</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; broadcastedRelation.value.size) &#123;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> One bitset per partition instead of per row.</span></span><br><span class="line">          <span class="keyword">val</span> broadcastedRow = broadcastedRelation.value(i)</span><br><span class="line">          buildSide <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">BuildRight</span> <span class="keyword">if</span> boundCondition(joinedRow(streamedRow, broadcastedRow)) =&gt;</span><br><span class="line">              matchedRows += joinedRow(streamedRow, broadcastedRow).copy()</span><br><span class="line">              streamRowMatched = <span class="literal">true</span></span><br><span class="line">              includedBroadcastTuples += i <span class="comment">// 记录 broadcast 侧已被匹配的条目</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">BuildLeft</span> <span class="keyword">if</span> boundCondition(joinedRow(broadcastedRow, streamedRow)) =&gt;</span><br><span class="line">              matchedRows += joinedRow(broadcastedRow, streamedRow).copy()</span><br><span class="line">              streamRowMatched = <span class="literal">true</span></span><br><span class="line">              includedBroadcastTuples += i</span><br><span class="line">            <span class="keyword">case</span> _ =&gt;</span><br><span class="line">          &#125;</span><br><span class="line">          i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 根据 Join 类型不同决定是否要把无法匹配的条目放进结果集中</span></span><br><span class="line">        (streamRowMatched, joinType, buildSide) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> (<span class="literal">false</span>, <span class="type">LeftOuter</span> | <span class="type">FullOuter</span>, <span class="type">BuildRight</span>) =&gt;</span><br><span class="line">            matchedRows += joinedRow(streamedRow, rightNulls).copy()</span><br><span class="line">          <span class="keyword">case</span> (<span class="literal">false</span>, <span class="type">RightOuter</span> | <span class="type">FullOuter</span>, <span class="type">BuildLeft</span>) =&gt;</span><br><span class="line">            matchedRows += joinedRow(leftNulls, streamedRow).copy()</span><br><span class="line">		  <span class="comment">// 这里还有 LeftOuter + BuildLeft 和 RightOuter + BuildRight 的情况没有处理 </span></span><br><span class="line">          <span class="keyword">case</span> _ =&gt;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Iterator</span>((matchedRows, includedBroadcastTuples))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> includedBroadcastTuples = matchesOrStreamedRowsWithNulls.map(_._2)</span><br><span class="line">    <span class="keyword">val</span> allIncludedBroadcastTuples = <span class="comment">// 所有已被匹配的 broadcast 侧条目</span></span><br><span class="line">      <span class="keyword">if</span> (includedBroadcastTuples.count == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">new</span> scala.collection.mutable.<span class="type">BitSet</span>(broadcastedRelation.value.size)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        includedBroadcastTuples.reduce(_ ++ _)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftNulls = <span class="keyword">new</span> <span class="type">GenericMutableRow</span>(left.output.size)</span><br><span class="line">    <span class="keyword">val</span> rightNulls = <span class="keyword">new</span> <span class="type">GenericMutableRow</span>(right.output.size)</span><br><span class="line">    <span class="comment">/** Rows from broadcasted joined with nulls. */</span></span><br><span class="line">    <span class="keyword">val</span> broadcastRowsWithNulls: <span class="type">Seq</span>[<span class="type">Row</span>] = &#123; <span class="comment">// 由 broadcast 侧未匹配条目与 NULL 组成的 Row</span></span><br><span class="line">      <span class="keyword">val</span> buf: <span class="type">CompactBuffer</span>[<span class="type">Row</span>] = <span class="keyword">new</span> <span class="type">CompactBuffer</span>()</span><br><span class="line">      <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">      <span class="keyword">val</span> rel = broadcastedRelation.value</span><br><span class="line">      <span class="keyword">while</span> (i &lt; rel.length) &#123; <span class="comment">// 遍历整个 broadcast 侧</span></span><br><span class="line">        <span class="keyword">if</span> (!allIncludedBroadcastTuples.contains(i)) &#123;</span><br><span class="line">          (joinType, buildSide) <span class="keyword">match</span> &#123; <span class="comment">// 未匹配的条目根据不同的 Join 类型生成带 NULL 的 Row</span></span><br><span class="line">            <span class="keyword">case</span> (<span class="type">RightOuter</span> | <span class="type">FullOuter</span>, <span class="type">BuildRight</span>) =&gt; buf += <span class="keyword">new</span> <span class="type">JoinedRow</span>(leftNulls, rel(i))</span><br><span class="line">            <span class="keyword">case</span> (<span class="type">LeftOuter</span> | <span class="type">FullOuter</span>, <span class="type">BuildLeft</span>) =&gt; buf += <span class="keyword">new</span> <span class="type">JoinedRow</span>(rel(i), rightNulls)</span><br><span class="line">            <span class="keyword">case</span> _ =&gt;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      buf.toSeq</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Breaks lineage.</span></span><br><span class="line">    sparkContext.union(</span><br><span class="line">      matchesOrStreamedRowsWithNulls.flatMap(_._1), sparkContext.makeRDD(broadcastRowsWithNulls))</span><br><span class="line">	  <span class="comment">// 将两个结果集 union 起来并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也算是比较直观啦，并没有什么特别神奇的东西。至此，我们就探索完 SparkSQL 为 JOIN 操作设计的 9 种 Physical Plan 了，相信在这个操作上对 SparkSQL 知根知底为以后的工作也能带来莫大的好处。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Spark Catalyst 进阶：Join</p><p><a href="https://mr-dai.github.io/sparksql_catalyst_source_8/">https://mr-dai.github.io/sparksql_catalyst_source_8/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Robert Peng</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2015-08-24</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2015-08-24</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Spark/">Spark</a><a class="link-muted mr-2" rel="tag" href="/tags/SparkSQL/">SparkSQL</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay-qrcode.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat-qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/spark_core_source_1/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Spark Core 源码解析：RDD</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/sparksql_catalyst_source_7/"><span class="level-item">Spark Catalyst 进阶：CacheManager</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://mr-dai.github.io/sparksql_catalyst_source_8/';
            this.page.identifier = 'sparksql_catalyst_source_8/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'robertpsblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="呆呆"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">呆呆</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/robert.peng" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/robert.peng"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bigtable/"><span class="tag">Bigtable</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GC/"><span class="tag">GC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gradle/"><span class="tag">Gradle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Groovy/"><span class="tag">Groovy</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hive-ThriftServer/"><span class="tag">Hive ThriftServer</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-824/"><span class="tag">MIT 6.824</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mesos/"><span class="tag">Mesos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paxos/"><span class="tag">Paxos</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raft/"><span class="tag">Raft</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark-SQL/"><span class="tag">Spark SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SparkSQL/"><span class="tag">SparkSQL</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD/"><span class="tag">主从备份</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/"><span class="tag">分布式共识</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98/"><span class="tag">分布式内存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"><span class="tag">分布式存储</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式系统</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"><span class="tag">分布式计算</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"><span class="tag">团队协作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"><span class="tag">集群资源调度</span><span class="tag">2</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#什么是-Join-？"><span class="level-left"><span class="level-item">1</span><span class="level-item">什么是 Join ？</span></span></a></li><li><a class="level is-mobile" href="#Parser"><span class="level-left"><span class="level-item">2</span><span class="level-item">Parser</span></span></a></li><li><a class="level is-mobile" href="#Analyzer"><span class="level-left"><span class="level-item">3</span><span class="level-item">Analyzer</span></span></a></li><li><a class="level is-mobile" href="#Optimizer"><span class="level-left"><span class="level-item">4</span><span class="level-item">Optimizer</span></span></a></li><li><a class="level is-mobile" href="#Planner"><span class="level-left"><span class="level-item">5</span><span class="level-item">Planner</span></span></a></li><li><a class="level is-mobile" href="#Physical-Plan"><span class="level-left"><span class="level-item">6</span><span class="level-item">Physical Plan</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#BroadcastLeftSemiJoinHash"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">BroadcastLeftSemiJoinHash</span></span></a></li><li><a class="level is-mobile" href="#LeftSemiJoinHash"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">LeftSemiJoinHash</span></span></a></li><li><a class="level is-mobile" href="#LeftSemiJoinBN"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">LeftSemiJoinBN</span></span></a></li><li><a class="level is-mobile" href="#BroadcastHashJoin"><span class="level-left"><span class="level-item">6.4</span><span class="level-item">BroadcastHashJoin</span></span></a></li><li><a class="level is-mobile" href="#SortMergeJoin"><span class="level-left"><span class="level-item">6.5</span><span class="level-item">SortMergeJoin</span></span></a></li><li><a class="level is-mobile" href="#ShuffledHashJoin"><span class="level-left"><span class="level-item">6.6</span><span class="level-item">ShuffledHashJoin</span></span></a></li><li><a class="level is-mobile" href="#HashOuterJoin"><span class="level-left"><span class="level-item">6.7</span><span class="level-item">HashOuterJoin</span></span></a></li><li><a class="level is-mobile" href="#CartesianProduct"><span class="level-left"><span class="level-item">6.8</span><span class="level-item">CartesianProduct</span></span></a></li><li><a class="level is-mobile" href="#BroadcastNestedLoopJoin"><span class="level-left"><span class="level-item">6.9</span><span class="level-item">BroadcastNestedLoopJoin</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Robert Peng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>