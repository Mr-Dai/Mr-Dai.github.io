---
layout: post_original
title: 《快学Scala》第2章（下）：函数
author: Robert Peng
category: Scala
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushBash.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushCpp.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<h2 class="jump">前情提要</h2>
<p>
	在<a href="{{ site.url }}{% post_url 2015-08-08-Scala-for-the-Impatient-2-1 %}">上一篇文章</a>中，
	我们完成了第二章上半部分的学习，学习了如何使用Scala的控制结构语句，其中包括Scala的<code>if</code>和<code>for</code>语句，
	以及Scala的控制台输入输出。
</p>
<p>
	接下来我们将进入《快学Scala》第二章的下半部分，学习Scala的函数声明以及异常。
</p>

<h2 class="jump">2.7 函数</h2>
<p>
	Scala中的函数声明与Java的函数有所不同。通常而言，我们在Scala中这样来声明一个函数：
</p>
<pre class="brush: scala">
def fac(n: Int): Int = {
	var r = 1
	for (i &lt;- 1 to n)
		r = r * i
	r
}
</pre>
<p>
	在Scala中，我们用<code>def</code>关键字来声明一个函数。函数签名依然是由<code>函数名(函数参数)</code>组成，
	只是函数参数的类型声明方式改为了Scala风格。同样，我们也可以像Java那样显式地声明函数返回值的类型，同样是以Scala风格在函数签名末尾声明。
	但大多数时候，函数返回值的类型声明是不必要的，编译器可以通过后面的代码块推断出函数返回值的类型。不过如果你返回的是该函数的递归调用，
	恐怕你就必须显式声明函数的返回值类型了，因为这个时候编译器无法自动帮你判断类型了。
</p>
<p>
	在实现上，Scala函数在函数签名后通过一个等号指代该函数的返回值等于后续的代码块。这个地方我们再一次见到了Scala代码的块结构，
	因此不难想象块中最后一个语句的返回值便是该函数的结果。有了这种默认的设定，实际上大多数时候我们都不再需要在Scala函数中使用
	<code>return</code>关键字，但我们仍然可以在代码块的中间位置使用它。
	不过要注意的是，Scala的<code>return</code>不只是退出当前函数那么简单。它是直接跳出到包含它的待命函数中。
	我希望你们能够谨记这一点，因为当你们以后学习到匿名函数并开始大量使用时，了解Scala<code>return</code>的这个特性便变得至关重要。
</p>
<h2 class="jump">2.8 默认参数和带名参数</h2>
<p>与Java相比，Scala重新支持了C/C++中设定函数默认参数的功能。我们可以通过如下形式声明参数的默认值：</p>
<pre class="brush: scala">
def decorate(str: String, left: String = "[", right: String = "]") =
	left + str + right
</pre>
<p>除了支持了C/C++的这项老功能以外，Scala还支持了Python中通过带名参数调用函数的功能。比如，上述函数还可以通过如下这种方式调用：</p>
<pre class="brush: scala">
decorate("Hello", right = " World!")
</pre>
<p>
	那么这是怎么实现的呢？首先Java是不支持默认参数和带名参数的，那Scala实现这种功能的方法其实很好猜，这种设（jiao）计（shui）模（dai）式（ma）在Java中也十分常见：
	我们通过声明各个版本的同名函数并在内部使用默认参数调用该函数即可。比如说我们有了<code>public String decorate(String str, String left, String right)</code>，
	要实现上述功能我们要这么写：
</p>
<pre class="brush: java">
public String decorate(String str) {
	return decorate(str, "[", "]");
}

public String decorate(String str, String left) {
	return decorate(str, left, "]");
}

public String decorate(String str, String left, String right) {
	return left + str + right;
}
</pre>
<p>
	实现带名参数调用则需要用其他名字来声明胶水函数，但原理上是类似的。要在Java中实现类似的功能当然是会相当麻烦，所以这也是Scala的优势之一。
	那事实又是否是如此呢？我们可以写一段这样的Scala代码：
</p>
<pre class="brush: scala">
class Method {
	def decorate(str: String, left: String = "[", right: String = "]") =
		left + str + right
		
	println(decorate("Hello", "~", "~"))
	println(decorate("Hello", "~"))
	println(decorate("Hello"))
	println(decorate("Hello", left = "~"))
	println(decorate("Hello", right = "~"))
	println(decorate("Hello", left = "~", right = "~"))
}
</pre>
<p>上述代码的反编译结果为：</p>
<pre class="brush: java">import scala.Predef$;
import scala.collection.mutable.StringBuilder;

public class Method {

	public Method() {
        Predef$.MODULE$.println(decorate("Hello", "~", "~"));
        Predef$.MODULE$.println(decorate("Hello", "~", decorate$default$3()));
        Predef$.MODULE$.println(decorate("Hello", decorate$default$2(), decorate$default$3()));
        Predef$.MODULE$.println(decorate("Hello", "~", decorate$default$3()));
        String x$1;
        String x$2;
        String x$3;
        Predef$.MODULE$.println(decorate(x$1 = "Hello", x$3 = decorate$default$2(), x$2 = "~"));
        Predef$.MODULE$.println(decorate("Hello", "~", "~"));
    }

    public String decorate(String str, String left, String right) {
        return (new StringBuilder()).append(left).append(str).append(right).toString();
    }

    public String decorate$default$2() {
        return "[";
    }

    public String decorate$default$3() {
        return "]";
    }
}
</pre>
<p>
	看起来，Scala的编译器与我们想象的有所不同，不过这样也不失为一种有效的实现手段。用这种手段实现这种功能可以使字节码的体积更小，
	但实际上却会多出1~2次函数调用。不过我想在绝大多数时候，这一点点细微差别都是无关紧要的。
</p>

<h2 class="jump">2.9 变长参数</h2>
<p>
	Scala函数同样支持Java函数所支持的变长参数（如果Scala不支持某项Java支持的功能那可真是大新闻了）。但与Java相比，
	变长参数的声明方式在Scala中有所不同。在Scala中，我们这样声明一个带变长参数的函数：
</p>
<pre class="brush: scala">
def sum(args: Int*) = {
	var result = 0
	for (arg &lt;- args)
		result += arg
	result
}
</pre>
<p>
	这里Scala实际上会将用户给出的参数转变为一个<code>Seq</code>类型的参数。<code>Seq</code>是Scala独有的collection之一，我们会在13章对其进行详述，
	现在你完全可以把它当做Java中的<code>List</code>来看待。但神奇的是，在调用的时候你不能真的只传入一个<code>Seq</code>对象作为函数参数。
	如果你要真想这么做，你需要在参数后面追加<code>: _*</code>来声明它需要被当做参数序列处理。比如这样：
</p>
<pre class="brush: scala">
val s = sum(1 to 5: _*)		// 注：Range类是Seq的子类之一
</pre>
<p>
	当你调用带变长参数且参数类型为<code>Object</code>的Java方法，如<code>PrintStream.printf</code>或<code>MessageFormat.format</code>时，
	你需要手工对数据基本类型进行转换。例如：
</p>
<pre class="brush: scala">
val str = MessageFormat.format("The answer to {0} is {1}",
	"everything", 42.asInstanceOf[AnyRef])
</pre>
<p>
	与Java中的Object类似，AnyRef是Scala中所有对象引用变量的父类。不过要注意的是，AnyRef不是Int的父类。
	Int等数据基本类型的父类是AnyVal，而AnyRef和AnyVal的父类Any才是Scala类型系统的最高父类。
	很多人倾向于将<code>asInstanceOf</code>等同于Java中的强制类型转换，但起码从上述代码就能看出，
	尽管<code>asInstanceOf</code>确实用于强制类型转换，但它和Java中的强制类型转换并不完全相同。
</p>

<h2 class="jump">2.10 过程</h2>
<p>
	对于没有返回值的函数，我们习惯称它为过程（procedure）。在Java中，这样的函数被标记为<code>void</code>，
	而在Scala中，我们将它的返回值类型设定为<code>Unit</code>，就像这样：
</p>
<pre class="brush: scala">
def echo(s: String): Unit = {
	Console println s
}
</pre>
<p>
	对于这样的函数，我们也可以把它的返回值类型声明和等号同时省去，写成以下形式：
</p>
<pre class="brush: scala">
def echo(s: String) {
	Console println s
}
</pre>
<p>但从编程习惯上来讲，并不推荐这样做。</p>
<h2 class="jump" id="lazy-value">2.11 懒值</h2>
<p>当<code>val</code>被声明为<code>lazy</code>时，它的初始化将被推迟，直到我们首次对它取值。例如：</p>
<pre class="brush: scala">
lazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString
</pre>
<p>
	当需要加载一个比较大的对象或者从外部读入大量数据时，懒加载在大多数时候都会显得十分有用。
	在Java中，我们可以通过代理模式实现这样的功能。用于实现对象懒加载的代理模式和单例模式面临着同样的问题，
	那就是多线程并发访问，因此为了实现懒加载是需要付出线程同步的性能损失的。那么Scala又是怎么做的呢？我们编写如下Scala代码：
</p>
<pre class="brush: scala">
class LazyVal {
	lazy val words = scala.io.Source.fromFile("/usr/share/dict/words").mkString
	
	println(words)
}
</pre>
<p>反编译的结果为：</p>
<pre class="brush: java">
import scala.Predef$;
import scala.io.*;
import scala.runtime.BoxedUnit;

public class LazyVal {

    private String words;
    private volatile boolean bitmap$0;

    private String words$lzycompute() {
        synchronized(this) {
            if(!bitmap$0) {
                words = Source$.MODULE$.fromFile("/usr/share/dict/words", Codec$.MODULE$.fallbackSystemCodec()).mkString();
                bitmap$0 = true;
            }
            BoxedUnit _tmp = BoxedUnit.UNIT;
        }
        return words;
    }

    public String words() {
        return bitmap$0 ? words : words$lzycompute();
    }

    public LazyVal() {
        Predef$.MODULE$.println(words());
    }
}
</pre>
<p>这次Scala倒没有出乎我们的意料，它确实使用了一个带同步机制的代理函数来实现变量的懒加载。</p>

<h2 class="jump">2.12 异常</h2>
<p>Scala作为运行在JVM之上的语言，其异常处理机制自然是与Java完全相同，差别仅存在于语句的写法上。</p>
<p>
	首先，在Scala中<code>throw</code>关键字的功能与Java完全相同，用于抛出一个<code>java.lang.Throwable</code>子类。
	不过，与Java不同的是，Scala没有“受检”异常，也就是说你不需要通过类似<code>throws</code>关键字声明函数可能会抛出的异常类型。
	这一点改变实际上是比较好的，因为Java的“受检”异常在很多情况下确实带来了很多的限制。
</p>
<p>
	在Scala中，<code>throw</code>表达式实际上是有返回类型的，它的返回类型是<code>Nothing</code>。如此返回类型在<code>if/else</code>
	表达式中十分有用，因为当一个分支的返回类型是<code>Nothing</code>时，<code>if/else</code>表达式的类型就是另一个分支的类型。
</p>
<p>在Scala中，我们仍然使用<code>catch</code>关键字捕捉错误，不过捕捉的方法与Java有所不同：</p>
<pre class="brush: scala">
try {
	process(new URL("http://horstmann.com/fred-tiny.gif"))
} catch {
	case _: MalformedURLException => println("Bad URL: " + url)
	case ex: IOException => ex.printStackTrace()
}
</pre>
<p>
	Scala在<code>catch</code>语句中使用了它的模式匹配机制（参见14章），这样我们就不需要像Java那样为每个不同类型的错误都写一次<code>catch</code>了。
	当我们不需要在错误处理逻辑中使用捕捉到的<code>Throwable</code>对象时，我们使用<code>_</code>占位符来表示我们不在乎这个对象叫什么名字。
</p>
<p>
	除去<code>try</code>和<code>catch</code>，Scala当然也支持<code>finally</code>关键字，它的用法和功能与Java完全一致。通过在<code>try</code>
	或<code>try/catch</code>后添加<code>finally</code>代码块，可以用来在无论是否有捕捉到错误的情况下都执行某些代码。这样的代码很适合用来释放某些资源。
	比如你可以这样写：
</p>
<pre class="brush: scala">
var in = new URL("http://horstmann.com/fred-tiny.gif").openStream()
try {
	process(in)
} catch {
	case ex: Throwable => ex.printStackTrace()
} finally {
	in.close()
}
</pre>

<h2 class="jump">章末结语</h2>
<p>
	恭喜你，你已经完成了《快学Scala》第二章的全部内容。在第二章的上半部分中，我们学会了如<code>if</code>、<code>for</code>等Scala常用控制结构，
	在下半部分我们学会了Scala函数声明以及错误捕捉机制。
</p>
<p>在接下来的第三章中，我们将学习Scala中的数组相关操作，敬请期待。</p>
<hr />
<p>下一篇：<a href="{{ site.url }}{% post_url 2015-09-04-Scala-for-the-Impatient-5 %}">《快学Scala》第5章：类</a></p>
