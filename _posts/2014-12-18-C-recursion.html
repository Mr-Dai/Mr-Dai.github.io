---
layout: posts
title: 递归与尾递归
author: Mr.Dai
categories: languages
---

<script type="text/javascript" src="/js/syntaxhighlighters/shBrushCpp.js"></script>

<p>原文出处：<a href="http://www.cnblogs.com/archimedes/p/rescuvie-tailrescuvie.html">codingwu 的博客</a>，转载请注明出处</p>
<br />

<p>在计算机科学领域中，递归式通过递归函数来实现的。程序调用自身的编程技巧称为递归（ recursion）。</p>
<p>一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p>
<p>一般来说，递归需要有：边界条件、递归前进段和递归返回段。</p>
<p>当边界条件不满足时，递归前进；当边界条件满足时，递归返回。</p>
<p>注意：</p>
<p>(1) 递归就是在过程或函数里调用自身；</p>
<p>(2) 在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</p>

<h2 id="jump1">基本递归</h2>
<p>问题：计算n！</p>
<p>数学上的计算公式为：n！=n×(n-1)×(n-2)……2×1</p>
<p>使用递归的方式，可以定义为：</p>
<p><img alt="" src="/img/recursion@1.jpg" width="234" height="48" /></p>
<p>以递归的方式计算4！</p>
<p>F(4)=4×F(3)&emsp;&emsp;&emsp;递归阶段</p>
<p>F(3)=3×F(2)</p>
<p>F(2)=2×F(1)</p>
<p>F(1)=1&emsp;&emsp;&emsp;&emsp;&emsp;终止条件</p>
<p>F(2)=(2)×(1)&emsp;&emsp;&emsp;回归阶段</p>
<p>F(3)=(3)×(2)</p>
<p>F(4)=(4)×(6)</p>
<p>24&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;递归完成</p>
<p>以递归方式实现阶乘函数的实现：</p>
<pre class="brush: c; gutter: true">int fact(int n) {
    if(n &lt; 0)
        return 0;
    else if (n == 0 || n == 1)
        return 1;
    else
        return n * fact(n - 1);
}</pre>

<h2 id="jump2">尾递归</h2>
<h3>定义</h3>
<p>如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多数现代的编译器会利用这种特点自动生成优化的代码。</p>
<h3>原理</h3>
<p>当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。虽然编译器能够优化尾递归造成的栈溢出问题，但是在编程中，我们还是应该尽量避免尾递归的出现，因为所有的尾递归都是可以用简单的goto循环替代的。</p>
<h3>实例</h3>
<p>为了理解尾递归是如何工作的，让我们再次以递归的形式计算阶乘。首先，这可以很容易让我们理解为什么之前所定义的递归不是尾递归。回忆之前对计算n!的定义：在每个活跃期计算n倍的(n－1)!的值，让n=n－1并持续这个过程直到n=1为止。这种定义不是尾递归的，因为每个活跃期的返回值都依赖于用n乘以下一个活跃期的返回值，因此每次调用产生的栈帧将不得不保存在栈上直到下一个子调用的返回值确定。现在让我们考虑以尾递归的形式来定义计算n!的过程。</p>
<p>这种定义还需要接受第二个参数a，除此之外并没有太大区别。a（初始化为1）维护递归层次的深度。这就让我们避免了每次还需要将返回值再乘以n。然而，在每次递归调用中，令a=na并且n=n－1。继续递归调用，直到n=1，这满足结束条件，此时直接返回a即可。</p>
<p>代码实例给出了一个C函数facttail，它接受一个整数n并以尾递归的形式计算n!。这个函数还接受一个参数a，a的初始值为1。facttail使用a来维护递归层次的深度，除此之外它和fact很相似。读者可以注意一下函数的具体实现和尾递归定义的相似之处。</p>
<pre class="brush: c; gutter: true">int facttail(int n, int a)
{
    if (n &lt; 0)
        return 0;
    else if (n == 0)
        return 1;
    else if (n == 1)
        return a;
    else
        return facttail(n - 1, n * a);
}</pre>
<p>示例中的函数是尾递归的，因为对facttail的单次递归调用是函数返回前最后执行的一条语句。在facttail中碰巧最后一条语句也是对facttail的调用，但这并不是必需的。换句话说，在递归调用之后还可以有其他的语句执行，只是它们只能在递归调用没有执行时才可以执行。</p>
<p>尾递归是极其重要的，不用尾递归，函数的堆栈耗用难以估量，需要保存很多中间函数的堆栈。比如f(n, sum) = f(n-1) + value(n) + sum; 会保存n个函数调用堆栈，而使用尾递归f(n, sum) = f(n-1, sum+value(n)); 这样则只保留后一个函数堆栈即可，之前的可优化删去。</p>
<p>也许在C语言中有很多的特例，但编程语言不只有C语言，在函数式语言Erlang中（亦是栈语言），如果想要保持语言的高并发特性，就必须用尾递归来替代传统的递归。</p>