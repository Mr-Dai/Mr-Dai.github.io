---
layout: posts
title: 《快学Scala》第7章：包
author: Robert Peng
---

<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<h2 class="jump">前情提要</h2>
<p>
	在上一期的<a href="">内容</a>中，我们学习了Scala中的单例对象，了解到如何通过<code>object</code>关键字来声明一个单例。
	至此我们已经结束了Scala类和对象的学习。那么今天，我们就开始学习Scala的包，学习如何科学地组织我们的项目。
</p>
<p>那么有人就要问了，到底是豆沙包还是莲蓉包？其实，是我最喜欢的叉烧包~</p>
<hr />
<h2 class="jump">7.1 包</h2>
<p>
	Scala中的包的概念，固然是和Java中的是一致的。如果你没有学习过Java，你可以把包理解成C++中的命名空间。
</p>
<p>
	在Java中，由于一个Java文件只能写一个类，因此我们只能通过在文件首部写上如<code>package com.robert</code>这样的语句来声明该Java类所属的包。
	Java对于包和类的位置安排是十分严格的，其中类所处的Java文件必须与该类同名，类所处的Java文件必须位于其所声明Java包对应的路径之下，
	胡乱地放置Java文件和Java类将会导致编译错误。
</p>
<p>
	Java这种严格的规范，你很难说它不好，但有时候做起来真的是很麻烦，尤其是现在的IDE技术如此的发达，这样的规范显得有些没必要。
	在Scala中就不存在这样的约束。一个Scala文件可以包含任意数量的Scala类，Scala文件名本身也没有任何约束，文件所处的路径也没有约束。
	你同样可以通过在Scala文件首部写上像<code>package com.robert</code>这样的语句来一次性声明该文件中所有类所处的包，
	但如果想要在一个文件中声明处于不同包的类，你可以这样写：
</p>
<pre class="brush: scala">
package com {
	package robert {
		class Robert
		...
	}
	
	package emily {
		class Emily
		...
	}
}
</pre>
<p>这样你就同时声明了<code>com.robert.Robert</code>和<code>com.emily.Emily</code>了。</p>
<p class="bg-danger" style="padding: 10px">
	<b>注意</b>：尽管我确实觉得像Java那样严格的规范有点不必要，但毋庸置疑那样的做法是更好的习惯。尽管在Scala中这样的约束已经全部消失，
	但随意地放置类和文件确实会极大地降低项目的可读性，尤其是当某些情况下你无法使用IDE的时候。因此，更好的做法是，继续自觉遵循Java对包与文件路径的约束，
	仅在Scala文件首部通过声明<code>package</code>来声明文件中所有类所属的包，而不要使用像上面出现的那种写法。
	同时，应确保在同一个文件中代码行数较多（如超过50行）的类不超过一个。
</p>
<hr />
<h2 class="jump">7.2 作用域规则</h2>
<p>
	Scala中的包作用域规则与Java是完全一致的，子包可以访问上层作用域中的名称。这一点没什么好说的。
</p>
<p>
	值得注意的是，在Scala中，包名实际上是相对的。在包<code>com.robert</code>中，你完全可以通过书写<code>robert.subrobert.Robert</code>
	来直接访问未进行<code>import</code>的包。
</p>
<p>
	这要怎么理解呢？我们可以理解为在import时，Scala便在文件内部维护了一个包别名，该别名与包的最后一个名字相同。比如，我们<code>import scala.collection.mutable</code>，
	那么实际上文件内部就可以通过访问包别名<code>mutable</code>来访问<code>scala.collection.mutable</code>下面的类了，
	比如我们可以直接<code>new mutable.HashMap</code>了。
</p>
<p>
	在了解过Scala的这个特性以后，我们就需要避免让一个文件同时引入两个拥有相同别名的包。比如，一个文件被声明为<code>package com.robert.collection</code>的话，
	你再<code>import scala.collection</code>，恐怕就会造成一定程度的混淆，使得编译器做出难以预料的行为了。
</p>
<p>
	在Java中，这样的问题不会出现，因为Java的包名总是绝对的。如果要在Scala中使用绝对的报名，我们需要从<b>_root_</b>出发：
</p>
<p>
	<code>new _root_.scala.collection.mutable.ArrayBuffer[String]</code>
</p>
<p>
	由此可见，我们<code>import scala.*</code>的时候这个<code>scala</code>也是一个包的别名，全名为<code>_root_.scala</code>。
	实际上是由于<code>_root_.scala</code>包总是会被自动引入，所以我们才能使用这样的引入语句。由此可见，除非包名以<code>_root_</code>开头，
	否则实际上所有的包名都是相对的。
</p>
<p class="bg-danger" style="padding: 10px">
	依赖Scala的包相对性当然可以写出简短的引入语句，但滥用这个特性必然会导致可读性的下降。因此，引入时写上除<code>_root_</code>
	外的完整包名依然是更好的做法。
</p>
<hr />
<h2 class="jump">7.3 串联式包语句</h2>
<p>除了像第一节中的那种写法，我们还可以使用串联式包语句：</p>
<pre class="brush: scala">
package com.robert.impatient {
  package people {
    // 实际上在这个位置我们将无法访问com和com.robert的成员
	// 但com.robert.impatient的成员仍然是可见的
    class Person
	...
  }
}
</pre>
<p class="bg-danger" style="padding: 10px">
	同理，我并不推荐使用这样的写法。接下来我将为大家讲解推荐的写法。
</p>
<hr />
<h2 class="jump">7.4 文件顶部标记法</h2>
<p>
	文件顶部标记法也就是最常规的，在文件首部添加<code>package</code>声明的做法了。但这样的方法在Scala中会有一点点不同，
	这同样也是Scala的包相对性所引入的：
</p>
<pre class="brush: scala">
package com.robert.impatient
package people

class Person
...
</pre>
<p>
	实际上，该语句的作用与第三节中的语句完全相同，因此我更推荐这种写法，因为这种写法约束了该文件中的所有Scala类必须处于相同的包中，
	这样的做法实际上是更好的。
</p>
<hr />
<h2 class="jump">7.5 包对象</h2>

	