---
layout: posts
title: Java8 时间 API
author: Robert Peng
category: Java
---

<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>

<h2 class="jump" id="intro">前言</h2>
<p>
  Java8 中最为人津津乐道的新改变恐怕当属函数式 API 的加入。但实际上，Java8 所加入的新功能远不止这个。
  本文将基于《<a href="http://t.cn/R4ZQRBh" target="_blank">Java SE8 for the Really Impatient</a>》的第 5 章，归纳一下 Java8 加入的位于<code>java.time</code>包下的日期和时间 API。
</p>
<hr />

<h2 class="jump" id="instant-and-duration">时间点与时间间隔</h2>
<p>
  在我们常说的四维空间体系中，时间轴往往作为除长宽高三轴以外的第四轴。时间轴由无穷多个时间点组成，而两个时间点之间的距离组成一个时间间隔。相较于我们常说的日期、时间，时间点本身所携带的信息是很少的，不会携带如时区等冗余的信息。作为时间轴上的一个点，我们可以将它称为绝对时间。
</p>
<p>
  Java8 引入了 <code>Instant</code> 类（瞬时）来表示时间轴上的一个点。<code>Instant</code> 的构造方法是 <code>private</code> 的，我们只能通过调用它的静态工厂方法来产生一个
  <code>Instant</code> 实例。其中最常用的是 <code>Instant.now()</code> 方法，返回当前的时间点。<code>Instant</code> 类也实现了 <code>comparesTo</code> 和
  <code>equals</code> 方法来对比两个瞬时点。
</p>
<p>
  通过调用 <code>Duration.between()</code> 方法我们便可以计算两个时间点之间的时间间隔：
</p>
<pre class="brush: java">
Instant start = Instant.now();

runAlgorithm();

Instant end = Instant.now();

Duration timeElapsed = Duration.between(start, end);
long millis = timeElapsed.toMillis();
</pre>
<p>
  <code>between</code> 方法返回一个 <code>Duration</code> 实例。<code>Duration</code> 内部以 <code>long</code> 成员来存储时间间隔信息，最小单位可去到纳秒，同时提供了如 <code>toMillis</code>、<code>toSeconds</code> 等方法。
</p>
<p>
  <code>Instant</code> 和 <code>Duration</code> 类常用的方法包括如下：
</p>
<table class="table">
  <tr>
    <th>方法</th>
    <th>描述</th>
  </tr>
  <tr>
    <td><code>plus</code>、<code>minus</code></td>
    <td>对当前 <code>Instant</code> 或 <code>Duration</code> 增加或减少一段时间</td>
  </tr>
  <tr>
    <td>
      <code>plusNanos</code>、<code>plusMillis</code>、<code>plusSeconds</code>、<br /><code>plusMinutes</code>、<code>plusHours</code>、<code>plusDays</code>
    </td>
    <td>根据指定的时间单位，对当前 <code>Instant</code> 或者 <code>Duration</code> 添加一段时间。</td>
  </tr>
  <tr>
    <td><code>minusNanos</code>、<code>minusMillis</code>、<code>minusSeconds</code>、<br /><code>minusMinutes</code>、<code>minusHours</code>、<code>minusDays</code></td>
    <td>根据指定的时间单位，对当前 <code>Instant</code> 或者 <code>Duration</code> 减少一段时间。</td>
  </tr>
  <tr>
    <td><code>multipliedBy</code>、<code>dividedBy</code>、<code>negated</code></td>
    <td>返回当前 <code>Duration</code> 与指定 <code>long</code> 值相乘或相除得到的时间间隔</td>
  </tr>
  <tr>
  	<td><code>isZero</code>、<code>isNegative</code></td>
  	<td>检查 <code>Duration</code> 是否为0或负数</td>
  </tr>
</table>
<p class="bg-info">
  <b>注意</b>：<code>Instant</code> 类和 <code>Duration</code> 类都是不可变的，上述方法都会返回一个新的实例。
</p>
<hr />
<h2 class="jump" id="local-date-time">本地日期</h2>
<p>
  在新的时间 API 中，Java 提供了两种时间格式：不带时区信息的本地时间和带时区的时间。本地日期表示一个日期，而本地时间还包含（一天中的）时间，但它们都不包含任何有关时区的信息。
  例如，June 14, 1903 就是一个本地日期。由于日期不含一天中的时间，也不含时区信息，所以它无法与一个准确的瞬时点对应。相反，July 16, 1969, 09:32:00 EDT 就是一个带时区的时间，
  它表示了时间轴上准确的一点。但有很多计算是不需要考虑时区的，在某些情况下考虑时区甚至可能导致错误的结果。出于此原因，API 设计者们更推荐使用不带时区的时间，除非你真的需要这个时区信息。
</p>
<p>
  <code>LocalDate</code>就是一个不带时区的本地日期：它只带有年份、月份和当月的天数。你可以通过<code>LocalDate</code>的静态工厂方法<code>now</code>或<code>of</code>来创建一个实例：
</p>
<pre class="brush: java">
LocalDate alonzosBirthday = LocalDate.of(1903, 6, 14);
alonzosBirthday = LocalDate.of(1903, Month.JUNE, 14);
</pre>
<p>
	这里我们看到，静态工厂方法中指示月份的数字是以1开始的，因此6就代表着六月。如果你实在是太喜欢以0开始，无法接受这种设定，你也可以使用枚举类型<code>Month</code>来指定月份。
</p>
<p>
	下表中列出了<code>LocalDate</code>对象的一些常用方法。详细的方法说明请参考<code>LocalDate</code>的
	<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">JavaDoc</a>。
</p>
<table class="table">
	<tr>
		<th>方法</th>
		<th>描述</th>
	</tr>
	<tr>
		<td><code>now</code>、<code>of</code></td>
		<td>静态工厂方法，可以根据当前时间或指定的年月日来创建一个<code>LocalDate</code>对象</td>
	</tr>
	<tr>
		<td>
			<code>plusDays</code>、<code>plusWeeks</code>、<code>plusMonths</code>、<code>plusYears</code>
		</td>
		<td>返回在当前<code>LocalDate</code>的基础上加上几天、几周、几个月或者几年后的新的<code>LocalDate</code>对象，原有的<code>LocalDate</code>对象保持不变</td>
	</tr>
	<tr>
		<td>
			<code>minusDays</code>、<code>minusWeeks</code>、<code>minusMonths</code>、<code>minusYears</code>
		</td>
		<td>返回在当前<code>LocalDate</code>的基础上减去几天、几周、几个月或者几年后的新的<code>LocalDate</code>对象，原有的<code>LocalDate</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>plus</code>、<code>minus</code></td>
		<td>返回在当前<code>LocalDate</code>的基础上加上或减去一个<code>Duration</code>或者<code>Period</code>的新的<code>LocalDate</code>对象，原有的<code>LocalDate</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>withDayOfMonth</code>、<code>withDayOfYear</code>、<code>withMonth</code>、<code>withYear</code></td>
		<td>返回一个月份天数、年份天数、月份、年份修改为指定的值的新的<code>LocalDate</code>对象，原有的<code>LocalDate</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>getDayOfMonth</code></td>
		<td>获取月份天数（在 $[1,31]$ 之间）</td>
	</tr>
	<tr>
		<td><code>getDayOfYear</code></td>
		<td>获取年份天数（在 $[1,366]$ 之间）</td>
	</tr>
	<tr>
		<td><code>getDayOfWeek</code></td>
		<td>获取星期几（返回一个<code>DayOfWeek</code>枚举值）</td>
	</tr>
	<tr>
		<td><code>getMonth</code>、<code>getMonthValue</code></td>
		<td>获取月份，返回一个<code>Month</code>枚举的值，或者是 $[1,12]$ 之间的一个数字</td>
	</tr>
	<tr>
		<td><code>getYear</code></td>
		<td>获取年份，在 $[-999999999,999999999]$ 之间</td>
	</tr>
	<tr>
		<td><code>until</code></td>
		<td>获取两个日期之间的<code>Period</code>对象，或者以指定<code>ChronoUnits</code>为单位的数值</td>
	</tr>
	<tr>
		<td><code>isBefore</code>、<code>isAfter</code></td>
		<td>比较两个<code>LocalDate</code></td>
	</tr>
	<tr>
		<td><code>isLeapYear</code></td>
		<td>是否为闰年</td>
	</tr>
</table>
<p class="bg-info">
  <b>注意</b>：<code>LocalDate</code> 类是不可变的，上述方法都会返回一个新的实例。
</p>
<p>
	在上一节中我们提到，两个瞬时点<code>Instant</code>之间的是一个持续时间<code>Duration</code>。对于本地时间，对应的对象就是时段<code>Period</code>，
	它表示一段逝去的年月日。
</p>
<hr />
<h2 class="jump" id="local-time">本地时间</h2>
<p>
	<code>LocalTime</code>代表一天中的某个时间，例如下午3点30分。
	同样，你可以通过<code>LocalTime</code>的静态工厂方法<code>now</code>和<code>of</code>来创建一个实例。
</p>
<pre class="brush: java">
LocalTime rightNow = LocalTime.now();
LocalTime bedtime= LocalTime.of(22, 30)
</pre>
<p>
	下表中列出了<code>LocalTime</code>对象的一些常用方法。详细的方法说明请参考<code>LocalTime</code>的
	<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html">JavaDoc</a>。
</p>
<table class="table">
	<tr>
		<th>方法</th>
		<th>描述</th>
	</tr>
	<tr>
		<td><code>now</code>、<code>of</code></td>
		<td>静态工厂方法，可以根据当前时间或指定的时分秒来创建一个<code>LocalTime</code>对象</td>
	</tr>
	<tr>
		<td>
			<code>plusHours</code>、<code>plusMinutes</code>、<code>plusSeconds</code>、<code>plusNanos</code>
		</td>
		<td>返回在当前<code>LocalTime</code>的基础上加上几小时、几分钟、几秒或者几纳秒后的新的<code>LocalTime</code>对象，原有的<code>LocalTime</code>对象保持不变</td>
	</tr>
	<tr>
		<td>
			<code>minusHours</code>、<code>minusMinutes</code>、<code>minusSeconds</code>、<code>minusNanos</code>
		</td>
		<td>返回在当前<code>LocalTime</code>的基础上减去几小时、几分钟、几秒或者几纳秒后的新的<code>LocalTime</code>对象，原有的<code>LocalTime</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>plus</code>、<code>minus</code></td>
		<td>返回在当前<code>LocalTime</code>的基础上加上或减去一个<code>Duration</code>的新的<code>LocalTime</code>对象，原有的<code>LocalTime</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>withHour</code>、<code>withMinute</code>、<code>withSecond</code>、<code>withNano</code></td>
		<td>返回一个小时数、分钟数、秒数、纳秒数修改为指定的值的新的<code>LocalTime</code>对象，原有的<code>LocalTime</code>对象保持不变</td>
	</tr>
	<tr>
		<td><code>getHour</code>、<code>getMinute</code>、<code>getSecond</code>、<code>getNano</code></td>
		<td>返回该<code>LocalTime</code>的小时、分钟、秒钟及纳秒值</td>
	</tr>
	<tr>
		<td><code>isBefore</code>、<code>isAfter</code></td>
		<td>比较两个<code>LocalTime</code></td>
	</tr>
</table>
<p class="bg-info">
  <b>注意</b>：<code>LocalTime</code> 类是不可变的，上述方法都会返回一个新的实例。
</p>
<p>
	<code>LocalDateTime</code>类则可看作是<code>LocalDate</code>和<code>LocalTime</code>的结合。它用于存储本地时区中的某个时间点，包含当前的年月日等日期信息，
	同时也包含了时钟、分钟、秒钟等时间信息。同样，<code>LocalDateTime</code>也是不可变的。
</p>
<p>
	详细的方法说明请参考<code>LocalDateTime</code>的
	<a href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">JavaDoc</a>。
</p>
<hr />
<h2 class="jump" id="zoned-date-time">带时区的时间</h2>
<p>
	Java8 的时间 API 当然也加入了对时区的支持。分别对应着<code>LocalDate</code>、<code>LocalTime</code>和<code>LocalDateTime</code>，带时区的时间类为<code>ZonedDate</code>、
	<code>ZonedTime</code>、<code>ZonedDateTime</code>。
</p>
<p>
	Java 中的时区信息来自于 IANA（Internet Assigned Numbers Authority）的数据库，其中每个时区都有着对应的 ID，例如<code>America/New_York</code>或者<code>Europe/Berlin</code>。
	调用<code>ZoneId.getAvailableIds</code>方法即可获取所有可用的时区信息。
</p>
<p>
	你还可以使用<code>ZoneId.of(id)</code>方法，用指定的时区 ID 来获取对应的<code>ZoneId</code>对象。通过调用<code>local.atZone(zoneId)</code>方法，
	你可以将一个<code>LocalDateTime</code>转换成一个<code>ZonedDateTime</code>对象，或者通过调用静态方法<code>ZonedDateTime.of</code>来创建一个对象。
</p>
<p>
	<code>ZonedDateTime</code>的许多方法都与<code>LocalDateTime</code>一致。下表中列出了<code>ZonedDateTime</code>特有的常用方法，详细的方法说明请参考<code>ZonedDateTime</code>的
	<a href="http://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">JavaDoc</a>。
</p>
<table class="table">
	<tr>
		<th>方法</th>
		<th>描述</th>
	</tr>
	<tr>
		<td><code>now</code>、<code>of</code>、<code>ofInstant</code></td>
		<td>根据当前时间或指定的年月日时分秒、纳秒和<code>ZoneId</code>，或者一个<code>Instant</code>和一个<code>ZoneId</code>来创建一个<code>ZonedDateTime</code>对象</td>
	</tr>
	<tr>
		<td><code>withZoneSameInstant</code>、<code>withZoneSameLocal</code></td>
		<td>返回时区失去中的一个新的<code>ZonedDateTime</code>对象，它表示相同的瞬时点或本地时间</td>
	</tr>
	<tr>
		<td><code>getOffset</code></td>
		<td>获得与 UTC 之间的时差，返回一个<code>ZoneOffset</code>对象</td>
	</tr>
	<tr>
		<td><code>toLocalDate</code>、<code>toLocalTime</code>、<code>toInstant</code></td>
		<td>返回对应的本地日期、本地时间或瞬时点</td>
	</tr>
</table>
<p>
	除此之外，Java8 还提供了一个<code>OffsetDateTime</code>类，用来表示带有（与 UTC 相比的）偏移量的时间。这个类专门用于一些不需要时区规则的业务场景，
	比如某些网络协议。对于人类可读的时间，<code>ZonedDateTime</code>是更好的选择。
</p>
<p>详情请查阅<code>OffsetDateTime</code>的 <a href="http://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html">JavaDoc</a>。</p>
<hr />
<h2 class="jump" id="temporal-adjuster">日期校正器</h2>
<hr />