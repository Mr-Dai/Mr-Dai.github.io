---
layout: posts
title: 安卓Service生命周期
author: Mr.Dai
categories: Application
---

<h2 class="jump">背景</h2>
<p>
    由于本人实在是没有经过系统的安卓学习，因此到了最近才真正懂得Service的一些本质。
    于是，今天我便要写下这篇博客来让自己以后能快速地复习起这些知识。
</p>

<h2 class="jump">Service是什么</h2>
<blockquote>
 <p>Most confusion about the Service class actually revolves around what
 it is <em>not</em>:</p>
 
 <ul>
 <li> A Service is <b>not</b> a separate process.  The Service object itself
 does not imply it is running in its own process; unless otherwise specified,
 it runs in the same process as the application it is part of.
 <li> A Service is <b>not</b> a thread.  It is not a means itself to do work off
 of the main thread (to avoid Application Not Responding errors).
 </ul>
 
 <p>Thus a Service itself is actually very simple, providing two main features:</p>
 
 <ul>
 <li>A facility for the application to tell the system <em>about</em>
 something it wants to be doing in the background (even when the user is not
 directly interacting with the application).  This corresponds to calls to
 <code><a href="/reference/android/content/Context.html#startService(android.content.Intent)">Context.startService()</a></code>, which
 ask the system to schedule work for the service, to be run until the service
 or someone else explicitly stop it.
 <li>A facility for an application to expose some of its functionality to
 other applications.  This corresponds to calls to
 <code><a href="/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int)">Context.bindService()</a></code>, which
 allows a long-standing connection to be made to the service in order to
 interact with it.
 </ul>
 
 <p>When a Service component is actually created, for either of these reasons,
 all that the system actually does is instantiate the component
 and call its <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> and any other appropriate callbacks on the
 main thread.  It is up to the Service to implement these with the appropriate
 behavior, such as creating a secondary thread in which it does its work.</p>
 
 <p>Note that because Service itself is so simple, you can make your
 interaction with it as simple or complicated as you want: from treating it
 as a local Java object that you make direct method calls on (as illustrated
 by <a href="#LocalServiceSample">Local Service Sample</a>), to providing
 a full remoteable interface using AIDL.</p>
 <footer>http://developer.android.com/reference/android/app/Service.html#WhatIsAService</footer>
</blockquote>

<p>
    总结起来其实就是：Service既不是一个新的线程也不是一个新的进程，它直接运行在那个通过startService或者bindService启动它的线程上。
    为了让Service运行在一个独立的线程而不是主线程上，你可以先新建一个线程，在新线程里通过调用startService或者bindService启动它，
    也可以在主线程上启动它，然后在Service新建一个线程来运行Service的业务逻辑。个人更加推荐前一种方法，因为前一种方法关闭新线程的唯一途径只能是
    通过stopService或者unbindService关闭Service，这样会使得线程更加可控。
</p>

<h2 class="jump">Service生命周期</h2>
<blockquote>
     <p>There are two reasons that a service can be run by the system.  If someone
 calls <code><a href="/reference/android/content/Context.html#startService(android.content.Intent)">Context.startService()</a></code> then the system will
 retrieve the service (creating it and calling its <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> method
 if needed) and then call its <code><a href="/reference/android/app/Service.html#onStartCommand(android.content.Intent, int, int)">onStartCommand(Intent, int, int)</a></code> method with the
 arguments supplied by the client.  The service will at this point continue
 running until <code><a href="/reference/android/content/Context.html#stopService(android.content.Intent)">Context.stopService()</a></code> or
 <code><a href="/reference/android/app/Service.html#stopSelf()">stopSelf()</a></code> is called.  Note that multiple calls to
 Context.startService() do not nest (though they do result in multiple corresponding
 calls to onStartCommand()), so no matter how many times it is started a service
 will be stopped once Context.stopService() or stopSelf() is called; however,
 services can use their <code><a href="/reference/android/app/Service.html#stopSelf(int)">stopSelf(int)</a></code> method to ensure the service is
 not stopped until started intents have been processed.
 
 <p>For started services, there are two additional major modes of operation
 they can decide to run in, depending on the value they return from
 onStartCommand(): <code><a href="/reference/android/app/Service.html#START_STICKY">START_STICKY</a></code> is used for services that are
 explicitly started and stopped as needed, while <code><a href="/reference/android/app/Service.html#START_NOT_STICKY">START_NOT_STICKY</a></code>
 or <code><a href="/reference/android/app/Service.html#START_REDELIVER_INTENT">START_REDELIVER_INTENT</a></code> are used for services that should only
 remain running while processing any commands sent to them.  See the linked
 documentation for more detail on the semantics.
 
 <p>Clients can also use <code><a href="/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int)">Context.bindService()</a></code> to
 obtain a persistent connection to a service.  This likewise creates the
 service if it is not already running (calling <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> while
 doing so), but does not call onStartCommand().  The client will receive the
 <code><a href="/reference/android/os/IBinder.html">IBinder</a></code> object that the service returns from its
 <code><a href="/reference/android/app/Service.html#onBind(android.content.Intent)">onBind(Intent)</a></code> method, allowing the client to then make calls back
 to the service.  The service will remain running as long as the connection
 is established (whether or not the client retains a reference on the
 service's IBinder).  Usually the IBinder returned is for a complex
 interface that has been <a href="/guide/components/aidl.html">written
 in aidl</a>.
 
 <p>A service can be both started and have connections bound to it.  In such
 a case, the system will keep the service running as long as either it is
 started <em>or</em> there are one or more connections to it with the
 <code><a href="/reference/android/content/Context.html#BIND_AUTO_CREATE">Context.BIND_AUTO_CREATE</a></code>
 flag.  Once neither
 of these situations hold, the service's <code><a href="/reference/android/app/Service.html#onDestroy()">onDestroy()</a></code> method is called
 and the service is effectively terminated.  All cleanup (stopping threads,
 unregistering receivers) should be complete upon returning from onDestroy().
 <footer>http://developer.android.com/reference/android/app/Service.html#ServiceLifecycle</footer>
</blockquote>

<p>总结起来其实就是下图：</p>
<p class="center"><img alt="" src="/img/service-lifecycle@1.png"></p>
<p>其中还提到onStartCommand()和onBind()函数的返回值可以影响Service的特性。这个以后再慢慢了解</p>

