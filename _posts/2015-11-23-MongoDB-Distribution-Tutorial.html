---
layout: posts
title: MongoDB 分布式部署教程
author: Robert Peng
category: MongoDB
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJScript.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushBash.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<h2 class="jump">Replica Set 部署</h2>
<p>
	我们先从部署一个三节点的Replica Set开始。
</p>
<p class="center"><img src="https://docs.mongodb.org/manual/_images/replica-set-read-write-operations-primary.png" /></p>
<p>首先，我们要为每个<code>mongod</code>实例创建它自己的<code>dbpath</code>：</p>
<pre class="brush: bash">
mkdir 1
mkdir 2
mkdir 3
</pre>
<p>然后，我们便可以开始启动这三个<code>mongod</code>实例了：</p>
<pre class="brush: bash">
mongod --dbpath 1 --port 27001 --replSet myRS
mongod --dbpath 2 --port 27002 --replSet myRS
mongod --dbpath 3 --port 27003 --replSet myRS
</pre>
<p>
	注意，这里我是为了在同一台机器上运行三个<code>mongod</code>实例，所以需要为它们分别指定不同的端口。如果是真实的分布式Replica Set，
	在每台机器上使用默认的<code>27017</code>端口是完全可行的。
</p>
<p>
	除此之外，我使用<code>--replSet</code>参数指定了<code>mongod</code>实例所属Replica Set的名字。这个名字是可以随意起的，
	但必须确保属于同一个Replica Set的<code>mongod</code>实例设置了相同的<code>--replSet</code>，否则可能会产生一些不可预期的后果。
</p>
<p>
	在顺利打开这些<code>mongod</code>实例后以后，不出意外的话我们应该能在输出的日志信息中看到如下记录：
</p>
<pre>
2015-11-14T16:25:46.060+0800 I JOURNAL  [initandlisten] journal dir=3\journal
2015-11-14T16:25:46.061+0800 I JOURNAL  [initandlisten] recover : no journal files present, no recovery needed
2015-11-14T16:25:46.078+0800 I JOURNAL  [durability] Durability thread started
2015-11-14T16:25:46.078+0800 I JOURNAL  [journal writer] Journal writer thread started
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] MongoDB starting : pid=9812 port=27003 dbpath=3 64-bit host=mrdai-Laptop
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R2
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] db version v3.0.7
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] git version: 6ce7cbe8c6b899552dadd907604559806aa2e9bd
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] build info: windows sys.getwindowsversion(major=6, minor=1, build=7601, platform=2, service_pack='Service Pack 1') BOOST_LIB_VERSION=1_49
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] allocator: tcmalloc
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] options: { net: { port: 27003 }, replication: { replSet: "myRS" }, storage: { dbPath: "3" } }
2015-11-14T16:25:46.615+0800 I INDEX    [initandlisten] allocating new ns file 3\local.ns, filling with zeroes...
2015-11-14T16:25:47.542+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.0, filling with zeroes...
2015-11-14T16:25:47.543+0800 I STORAGE  [FileAllocator] creating directory 3\_tmp
2015-11-14T16:25:47.544+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.0, size: 64MB,  took 0 secs
2015-11-14T16:25:47.551+0800 I REPL     [initandlisten] Did not find local replica set configuration document at startup;  NoMatchingDocument Did not find replica set configuration document in local.system.replset
2015-11-14T16:25:47.552+0800 I NETWORK  [initandlisten] waiting for connections on port 27003
</pre>
<p>
	可以注意到，倒数第二条记录显示<code>mongod</code>未能在本地数据中找到Replica Set的设置信息。这是正常的，因为这是第一次创建的Replica Set。
	最后一条信息显示<code>mongod</code>启动完毕，等待外界连接它的端口。
</p>
<p>
	那么，我们开始启动Replica Set。使用<code>mongo</code>连入随便一个<code>mongod</code>实例，并进行设置：
</p>
<pre class="brush: js">
var conf = {
  _id : "myRS",
  members : [
    { _id : 1, host : "localhost:27001" },
    { _id : 2, host : "localhost:27002" },
    { _id : 3, host : "localhost:27003" }
  ]
}

rs.initiate(conf)
</pre>
<p>
	在<code>conf</code>中，我们将<code>_id</code>设置为Replica Set的名称，并在<code>members</code>中设置了Replica Set所有成员的信息，其中包括成员的名称<code>_id</code>以及成员的主机名<code>host</code>。
</p>
<p class="bg-danger">
	<b>注意</b>，尽管这里可以直接使用了<code>IP:端口</code>的形式来指定<code>mongod</code>实例，但在真实环境中，<b>不要</b>这么做，这种做法十分糟糕。
	不过现在搭建分布式，大家的做法似乎更倾向于为每台机器修改<code>hosts</code>文件。同样，<b>不要</b>这么做，这两种做法都属于bad practice。最好的做法，是在你的集群环境中配置一台DNS服务器。
	这样，当你的某一个结点的IP发生变化时，你就只需要修改DNS服务器中的那条解析条目，而不需要修改每个结点的<code>hosts</code>文件了。
</p>
<p class="bg-danger">
	直接以数字作为每个结点的名称也是不好的做法，因为这个名称在<code>mongod</code>的日志信息中会经常出现。使用更加可读的名称是更好的做法。
</p>
<p>一切正常的话，你应该会在其中一个结点上看到如下日志信息：</p>
<pre>
2015-11-14T16:41:54.946+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61875 #1 (1 connection now open)
2015-11-14T16:41:54.951+0800 I NETWORK  [conn1] end connection 127.0.0.1:61875 (0 connections now open)
2015-11-14T16:41:54.953+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61877 #2 (1 connection now open)
2015-11-14T16:41:55.013+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61882 #3 (2 connections now open)
2015-11-14T16:41:55.018+0800 I NETWORK  [conn3] end connection 127.0.0.1:61882 (1 connection now open)
2015-11-14T16:41:55.078+0800 I REPL     [WriteReplSetConfig] Starting replication applier threads
2015-11-14T16:41:55.082+0800 I REPL     [ReplicationExecutor] New replica set config in use: { _id: "myRS", version: 1, members: [ { _id: 1, host: "localhost:27001", arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id: 2, host: "localhost:27002", arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id:3, host: "localhost:27003", arbiterOnly: false, buildIndexes: true, hidden: false, priority...(line truncated)...
2015-11-14T16:41:55.086+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61884 #4 (2 connections now open)
2015-11-14T16:41:55.115+0800 I REPL     [ReplicationExecutor] This node is localhost:27003 in the config
2015-11-14T16:41:55.128+0800 I REPL     [ReplicationExecutor] transition to STARTUP2
2015-11-14T16:41:55.134+0800 I REPL     [rsSync] ******
2015-11-14T16:41:55.136+0800 I REPL     [rsSync] creating replication oplog of size: 6172MB...
2015-11-14T16:41:55.137+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.1, filling with zeroes...
2015-11-14T16:41:55.139+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state STARTUP2
2015-11-14T16:41:55.151+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.1, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:55.153+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.2, filling with zeroes...
2015-11-14T16:41:55.161+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.2, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:55.170+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.3, filling with zeroes...
2015-11-14T16:41:55.171+0800 I REPL     [ReplicationExecutor] Member localhost:27002 is now in state STARTUP2
2015-11-14T16:41:55.186+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.3, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:56.198+0800 I REPL     [rsSync] ******
2015-11-14T16:41:56.198+0800 I REPL     [rsSync] initial sync pending
2015-11-14T16:41:56.200+0800 I REPL     [rsSync] no valid sync sources found in current replset to do an initial sync
2015-11-14T16:41:57.139+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state SECONDARY
2015-11-14T16:41:57.206+0800 I REPL     [rsSync] initial sync pending
2015-11-14T16:41:57.206+0800 I REPL     [ReplicationExecutor] syncing from: localhost:27001
2015-11-14T16:41:57.221+0800 I REPL     [rsSync] initial sync drop all databases
2015-11-14T16:41:57.222+0800 I STORAGE  [rsSync] dropAllDatabasesExceptLocal 1
2015-11-14T16:41:57.222+0800 I REPL     [rsSync] initial sync clone all databases
2015-11-14T16:41:57.229+0800 I REPL     [rsSync] initial sync data copy, starting syncup
2015-11-14T16:41:57.234+0800 I REPL     [rsSync] oplog sync 1 of 3
2015-11-14T16:41:57.239+0800 I REPL     [rsSync] oplog sync 2 of 3
2015-11-14T16:41:57.254+0800 I REPL     [rsSync] initial sync building indexes
2015-11-14T16:41:57.258+0800 I REPL     [rsSync] oplog sync 3 of 3
2015-11-14T16:41:57.265+0800 I REPL     [rsSync] initial sync finishing up
2015-11-14T16:41:57.268+0800 I REPL     [rsSync] replSet set minValid=5646f3d4:1
2015-11-14T16:41:57.274+0800 I REPL     [rsSync] initial sync done
2015-11-14T16:41:57.290+0800 I REPL     [ReplicationExecutor] transition to RECOVERING
2015-11-14T16:41:57.292+0800 I REPL     [ReplicationExecutor] transition to SECONDARY
2015-11-14T16:41:58.136+0800 I REPL     [ReplicationExecutor] could not find member to sync from
2015-11-14T16:41:58.971+0800 I REPL     [ReplicationExecutor] replSetElect voting yea for localhost:27001 (1)
2015-11-14T16:41:59.140+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state PRIMARY
2015-11-14T16:41:59.171+0800 I REPL     [ReplicationExecutor] Member localhost:27002 is now in state SECONDARY
</pre>
<p>
	从日志中，我们可以很清晰地看到，发起<code>rs.initiate</code>的<code>mongod</code>向其他<code>mongod</code>开启了连接，其他<code>mongod</code>获取到了我们配置的<code>conf</code>信息。
	而后，Replica Set开始启动。首先是各结点进行初始化同步，从发起<code>rs.initiate</code>的<code>mongod</code>处同步了oplog，并进入<code>Secondary</code>状态。然后，
	3个<code>Secondary</code>发现Replica Set中没有<code>Primary</code>，于是发起选举。日志里，我们甚至可以看到这个<code>mongod</code>把票投给了谁。最后，选举结束，<code>localhost:27001</code>成为了<code>Primary</code>。
</p>
<hr />
<h2 class="jump">使用Java驱动连接至Replica Set</h2>
<p>我们通过如下语句连接至单一的MongoDB实例：</p>
<pre class="brush: java">
MongoClient client = new MongoClient("localhost", 27001);
</pre>
<p>
	我们为<code>MongoClient</code>对象指定了一个MongoDB实例的主机名和端口号。
	以这种方式初始化的<code>MongoClient</code>会假设目标MongoDB实例只是一个standalone的实例，如果该实例不是<code>Primary</code>时，
	客户端执行写操作则可能被该MongoDB实例拒绝。
</p>
<p>通过如下语句可使<code>MongoClient</code>进入Replica Set模式：</p>
<pre class="brush: java">
MongoClient client = new MongoClient(asList(
                         new ServerAddress("localhost", 27001)
				     ));
</pre>
<p>
	我们通过<code>Arrays#asList</code>方法为<code>MongoClient</code>传入了一个<code>List</code>，
	<code>MongoClient</code>便会进入Replica Set模式。在这种模式下，客户端会利用给定的主机（seedlist）来发现Replica Set的其他所有结点，其中就包括了<code>Primary</code>。
	因此，即使<code>localhost:27001</code>不是<code>Primary</code>也没关系，客户端会通过它获知<code>Primary</code>的地址并自动连接至<code>Primary</code>。
</p>
<p>
	但以上做法仍不全面：如果<code>localhost:27001</code>进程已经挂了，或者它并不是Replica Set的成员，我们便无法通过上述语句连接至Replica Set。
	我们可以为构造函数传入更多的MongoDB实例的地址来降低这种情况发生的几率：
</p>
<pre class="brush: java">
MongoClient client = new MongoClient(asList(
                         new ServerAddress("localhost", 27001),
                         new ServerAddress("localhost", 27002),
                         new ServerAddress("localhost", 27003)
					 ));
</pre>
<p>当然，也有可能正好你指定的这多个结点都同时挂掉，那样自然是防不胜防了。不过，提高Replica Set拓扑可用性就是网络架构的问题了。</p>
<p>当我们在执行写操作时，我们还需要考虑<code>Primary</code>会突然挂掉。比如说，我们正在执行这样的写操作：</p>
<pre class="brush: java">
MongoCollection collection = client.getDatabase("foo").getCollection("bar");

for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
    collection.insertOne(new Document("_id", new ObjectId()).append("i", i));
	Thread.sleep(500);
}
</pre>
<p>
	在执行插入时，如果<code>Primary</code>突然失效（如调用了<code>rs.stepDown()</code>），
	那么上述代码中的<code>insertOne</code>方法会抛出一个错误。因此，更为健壮的做法，是为该<code>insertOne</code>语句加上<code>try/catch</code>块：
</p>
<pre class="brush: java">
for (int i = 0; i &lt; Integer.MAX_VALUE; i++) {
	try {
        collection.insertOne(new Document("_id", new ObjectId()).append("i", i));
	} catch (MongoException e) {
	    // Handle the exception
	}
	Thread.sleep(500);
}
</pre>
<p>
	遗憾的是，抛出错误的<code>insertOne</code>操作恐怕无法由MongoDB驱动自动重试。实际上，不只是触发错误的那一次操作，在Replica Set自动选举出新的<code>Primary</code>前，
	所有写操作都会抛出错误。但幸运的是，由于加上了<code>try/catch</code>块，应用程序不会因为单次写入失败便直接退出。
	在触发错误后，下一次插入前驱动都会重新尝试利用seedlist来获取新的<code>Primary</code>的地址。当Replica Set重新选举出新的<code>Primary</code>后，
	驱动便可以再次进行写操作了。
</p>
<p>通过观察MongoDB Java驱动输出的日志信息，你可以更细致地观察驱动的行为。这里就不直接给出了，有兴趣可自己尝试。</p>
<hr />
<h2 class="jump">Shard 集群部署</h2>
<p>
	在本节中，我们将会在本机上部署一个完整的生产级别的MongoDB Shard集群。集群由4个Shard负责存储数据，其中每个Shard都是包含三个结点的Replica Set。
	除此之外，集群还包括4个<code>mongos</code>和3个Config Server。
</p>
<p class="bg-danger">
	<b>注意</b>，用于生产环境的Shard集群必须遵循如下几个原则：<b>必须</b>使用Replica Set来作为Shard，任何一个Shard的不可用都会导致集群出现异常；
	<b>必须</b>使用正好3个Config Server，Config Server不可用将导致整个集群不可用。除此之外，使用两个以上的<code>mongos</code>实例可以更好地分散压力。
</p>
<p>4个Replica Set的信息分别如下：</p>
<pre class="brush: js">
{
  _id : "a",
  members : [
    { _id : "a1", host : "localhost:27001" },
    { _id : "a2", host : "localhost:27002" },
    { _id : "a3", host : "localhost:27003" }
  ]
}

{
  _id : "b",
  members : [
    { _id : "b1", host : "localhost:27101" },
    { _id : "b2", host : "localhost:27102" },
    { _id : "b3", host : "localhost:27103" }
  ]
}

{
  _id : "c",
  members : [
    { _id : "c1", host : "localhost:27201" },
    { _id : "c2", host : "localhost:27202" },
    { _id : "c3", host : "localhost:27203" }
  ]
}


{
  _id : "d",
  members : [
    { _id : "d1", host : "localhost:27301" },
    { _id : "d2", host : "localhost:27302" },
    { _id : "d3", host : "localhost:27303" }
  ]
}
</pre>
<h3>集群各成员启动</h3>
<p>首先我们分别启动集群的各个成员，分别是Shard、Config Server和Query Router。其中前两种成员均为<code>mongod</code>，而Query Router则是<code>mongos</code>。</p>
<p>
	单个Replica Set的配置方式大致上无太大变化，只是作为Shard Server在启动<code>mongod</code>时需要加上<kbd>--shardsvr</kbd>选项。
	以Replica Set <code>a</code>为例：
</p>
<pre class="brush: bash">
mkdir a{1,2,3}

mongod --shardsvr --replSet a --dbpath a1 --logpath log.a1 --port 27001 --fork
mongod --shardsvr --replSet a --dbpath a2 --logpath log.a2 --port 27002 --fork
mongod --shardsvr --replSet a --dbpath a3 --logpath log.a3 --port 27003 --fork
</pre>
<p class="bg-info">
	<b>注</b>：当<code>--shardsvr</code>选项被打开时，<code>mongod</code>的默认端口号变为<b>27018</b>。
</p>
<p>
	再使用<code>mongo</code>连接至任意一个<code>mongod</code>实例，启动Replica Set：
</p>
<pre class="brush: js">
var conf = {
  _id : "a",
  members : [
    { _id : "a1", host : "localhost:27001" },
    { _id : "a2", host : "localhost:27002" },
    { _id : "a3", host : "localhost:27003" }
  ]
}

rs.initiate(conf)
</pre>
<p>重复上述操作即可启动其余三个Replica Set。</p>
<p>
	接下来开始启动Config Server：
</p>
<pre class="brush: bash">
mkdir cfg{1,2,3}

mongod --configsvr --dbpath cfg1 --logpath log.cfg1 --port 26050 --fork
mongod --configsvr --dbpath cfg2 --logpath log.cfg2 --port 26051 --fork
mongod --configsvr --dbpath cfg3 --logpath log.cfg3 --port 26052 --fork
</pre>
<p class="bg-info">
	<b>注</b>：当<code>--configvr</code>选项被打开时，<code>mongod</code>的默认端口号变为<b>27019</b>。
</p>
<p>最后，启动Query Router：</p>
<pre class="brush: bash">
mongos --configdb localhost:26050,localhost:26051,localhost:26052 --logpath log.mongos1 --fork
mongos --configdb localhost:26050,localhost:26051,localhost:26052 --logpath log.mongos2 --port 26061 --fork
mongos --configdb localhost:26050,localhost:26051,localhost:26052 --logpath log.mongos3 --port 26062 --fork
mongos --configdb localhost:26050,localhost:26051,localhost:26052 --logpath log.mongos4 --port 26063 --fork
</pre>
<p class="bg-info">
	<b>注</b>：<code>mongos</code>的默认端口号为<b>27017</b>，与<code>mongod</code>、<code>mongo</code>的默认端口号相同。
</p>
<p>如此一来，集群的各个成员都启动完毕了，可以开始配置集群了。</p>
<h3>添加Shard</h3>
<p>
	实际上，在启动<code>mongos</code>时，我们已经指定了集群所使用的Config Server的地址。接下来就是为集群指定每个Shard的地址了。
</p>
<p>
	打开<code>mongo</code>连接至任意一个<code>mongos</code>，并执行如下指令：
</p>
<pre class="brush: bash">
sh.addShard("a/localhost:27001")
sh.addShard("b/localhost:27101")
sh.addShard("c/localhost:27201")
sh.addShard("d/localhost:27301")
</pre>
<p>
	注意到，我们添加Shard时，输入了Replica Set的名称以及其中一个成员的地址。该成员并不一定得是<code>Primary</code>，只要它是该Replica Set的成员，
	<code>mongos</code>就能自动发现Replica Set的其他所有成员。
</p>
<p>在添加了4个Shard以后，整个Shard集群便配置完毕，可以开始使用了。</p>

