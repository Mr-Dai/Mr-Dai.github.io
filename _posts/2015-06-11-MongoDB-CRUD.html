---
layout: posts
title: MongoDB CRUD Cookbook
author: Robert Peng
categories: applications
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJScript.js"></script>

<h2 class="jump">Overview</h2>
<p>
This post is just a cookbook for me to look up all those MongoDB operations, so there won't be too many basic concepts about MongoDB or advanced usage.
I'll try to make this post perfect for those who don't know MongoDB at all to get the hang of it as fast as they can.
</p>
<p>
This post is just a parody of the official manual, but I'll try my best to draw out all those really matters and keep those confusing concepts away.
</p>
<p>
In this post, I'll show you MongoDB's basic CRUD operations, and after that, you may agree with me that MongoDB can be a better alternatives of those relation database.
</p>
<p class="bg-danger">
<b>Warning</b>: This post will not teach you how to install MongoDB on your computer or how to open its shell. For these basic knowledges, you can check out on the official tutorial.
</p>

<h2 class="jump">What is MongoDB?</h2>
<p>
So, first of all, what is MongoDB? I guess some of you may have already learned that MongoDB is a NoSQL database, it is somehow faster than traditional relation database
like MySQL and Oracle, and maybe some of you even know that MongoDB store data in key-value pairs. But does it make sense? If it truly stores data in key-value pairs, then
it probably looks just like the <code>HashMap</code> in Java. Is it a data structure that is good enough to support all those complex computations in relation database?
Absolutely not, and MongoDB is absolutely more than that.
</p>
<p>
Before MongoDB, we know there are different types of database systems. Like there is <code>Memcached</code> who focus on caching all those frequently-used data in the server's memory.
Although Memcached has its remarkable speed, Memcached provides way less functions compared to all those relation databases. Speaking of relation databases, MySQL provides lots of
useful functionalities, like <code>count(*)</code>, <code>JOIN</code>, and all those engines. But you may have already known that relation databases are pretty slow and they can
hardly meet the requirement of high-performance computing like Big Data Processing.
</p>
<p>
After all these, here comes the MongoDB. Unlike Memcached and all those relation databases, MongoDB always try to achieve a win-win situation on both performance and functionality.
You may have alreay known that MongoDB is much faster than relation database, but you still don't know that MongoDB also provides lots of functions, which make it a totally sufficient
substitution for all those relation database.
</p>

<h2 class="jump">CRUD - C</h2>
<p>
First of all, you have to know, MongoDB stores data in <code>JSON</code> format, and its shell operation bases on <code>JavaScript</code>. 
Instead of storing many <code>record</code>s in many <code>table</code>s like relation database does, MongoDB stores data as <code>document</code>s in <code>collection</code>s. 
So in this section, I'll teach you how to insert documents in a collection.
</p>

<h3>Insert a Document</h3>
<p>Insert a document into a collection named <code>inventory</code>. <span class="bg-info">The opertion will create the collection if the collection does not currently exist.</span></p>
<pre class="brush: js">
db.inverntory.insert(
    {
        item: "ABC1",
        details: {
            model: "14Q3",
            manufacturer: "XYZ Company",
        },
        stock: [ { size: "S", qty: 25 }, { size: "M", qty: 50 } ],
        category: "clothing"
    }
);
</pre>
<p>The operation returns a <code>WriteResult</code> object with the status of the operation. A successful insert of the document returns the following object:</p>
<pre class="brush: js">
WriteResuls({ "nInserted" : 1 })
</pre>
The <code>nInserted</code> field specified the number of documents inserted. If the operation encounters an error, the <code>WriteResult</code> object will contain the error information.</p>

<h3>Insert an Array of Documents</h3>
<pre class="brush: js">
var myDocuments=
    [
        {
            item: "ABC2",
            details: { model: "14Q3", manufacturer: "M1 Corporation" },
            stock: [ { size: "M", qty: 50 } ],
            category: "clothing"
        },
        {
            item: "MNO2",
            details: { model: "14Q3", manufacturer: "ABC Company" },
            stock: [ { size: "S", qty: 5 }, { size: "M", qty: 5 }, { size: "L", qty: 1 } ],
            category: "clothing"
        },
        {
            item: "IJK2",
            details: { model: "14Q2", manufacturer: "M5 Corporation" },
            stock: [ { size: "S", qty: 5 }, { size: "L", qty: 3 } ],
            category: "houseware"
        }
    ];
db.inventory.insert(myDocuments);
</pre>
<p>The method returns a <code>BulkWriteResult</code> object with the status of the operation. A successful insert of the documents returns the following object:</p>
<pre class="brush: js">
BulkWriteResult({
    "writeErrors" : [ ],
    "writeConcernErrors" : [ ],
    "nInserted" : 3,
    "nUpserted" : 0,
    "nMatched" : 0,
    "nModified" : 0,
    "nRemoved" : 0,
    "upserted" : [ ]
})
</pre>
<p>The <code>nInserted</code> field specifies the number of documents inserted. If the operation encounters an eror, the <code>BulkWriteResult</code> object will contain information regarding the error.</p>

<h3>Insert Multiple Documents with Bulk</h3>
<pre class="brush: js">
var bulk = db.inventory.initializeUnorderedBulkOp();
</pre>
By "unordered opertion", it means that <span class="bg-info">MongoDB can execute all those operations in parallel as well as in nondeterministic order.</span> If an error occurs during the process of one of the write operations, MongoDB will continue to process remaining write operations in the list.</p>
<pre class="brush: js">
bulk.insert(
    {
        item: "BE10",
        details: { model: "14Q2", manufacturer: "XYZ Company" },
        stock: [ { size: "L", qty: 5 } ],
        category: "clothing"
    }
);
bulk.insert(
    {
        item: "ZYT1",
        details: { model: "14Q1", manufacturer: "ABC Company" },
        stock: [ { size: "S", qty: 5 }, { size: "M", qty: 5 } ],
        category: "houseware"
    }
);
bulk.execute();
</pre>
<p>The method returns a <code>BuildWriteResult</code> object.</p>

<h2 class="jump">CRUD - R</h2>
<h3>Select All Documents in a Collection</h3>
<pre class="brush: js">
db.inventory.find( {} );
db.inventory.find();
</pre>
<p>Both commands do the same thing.</p>

<h3>Specify Equality Condition</h3>
<pre class="brush: js">
db.inventory.find( { type: "snacks" } );
</pre>

<h3>Specify Conditions Using Query Operators</h3>
<pre class="brush: js">
db.inventory.find( { type: { $in: [ "food", "snacks" ] } } );
</pre>
<p>Although you can express this query using the <code>$or</code> operator, use the <code>$in</code> operator rather than the <code>$or</code> operator when performing equality checks on the same field.</p>

<h3>Specify AND Conditions</h3>
<pre class="brush: js">
db.inventory.find( { type: 'food', price: { $lt: 9.95 } } );
</pre>

<h3>Specify OR Conditions</h3>
<pre class="brush: js">
db.inventory.find(
    {
        $or: [ { qty: { $gt: 100 } }, { price: { $lt: 9.95 } } ]
    }
);
</pre>

<h3>Specify AND as well as OR Conditions</h3>
<pre class="brush: js">
db.inventory.find(
    {
        type: "food",
        $or: [ { qty: { $gt: 100 } }, { price: { $lt: 9.95 } } ]
    }
);
</pre>

<h3>Embedded Documents</h3>
<p>
As you've already seen that documents can be hierarchical, meaning document contains documents, which is also called embedded documents. When the field holds an embedded document,
a query can either specify an exact match on the embedded document or specify a match by individual fields in the embedded document using the <i>dot notation</i>.
</p>
<h4>Exact Match on the Embedded Document</h4>
<p>
To specify an equality match on the whole embedded document, use the query document <code>{ &lt;field&gt;: &lt;value&gt; }</code> where <code>&lt;value&gt;</code> is 
the document to match. Equality matches on an embedded document require an <i>exact</i> match of the specified <code>&lt;value&gt;</code>, <span class="bg-info">including the field order</span>.
</p>
<pre class="brush: js">
db.invntory.find(
    {
        producer:
            {
                company: "ABC123",
                address: "123 Street"
            }
    }
);
</pre>
<h4>Equality Match on Fields within an Embedded Document</h4>
<p>
Use the <i>dot notation</i> to match by specific fields in an embedded document. Equality matches for specific fields in an embedded document will select documents in the collection 
where the embedded document contains the specified fields with the specified values. <span class="bg-info">The embedded document can contain additional fields.</span>
</p>
<pre class="brush: js">
db.inventory.find( { "producer.company": "ABC123" } );
</pre>

<h3>Arrays</h3>
<p>
When the field holds an array, you can query for an exact array match or for specific values in the array. If the array holds embedded documents, you can query for specific fields in the embedded documents using <i>dot notation</i>.
</p>
<p>If you specify multiple conditions using the <code>$elemMatch</code> operator, the array must contain at least one element that satisfies all the conditions.</p>
<p>
If you specify multiple conditions without using the <code>$elemMatch</code> operator, then some combination of the array elements, not necessarily a single element, must satisfy all the conditions; 
i.e. different elements in the array can satisfy different parts of the conditions.
</p>
<p>Consider an <code>inventory</code> collection that contains the following documents:</p>
<pre class="brush: js">
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ]}
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ]}
</pre>
<h4>Exact Match on an Array</h4>
<p>
To specify an equality match on an array, use the query document <code>{ &lt;field&gt;: &lt;value&gt; }</code> where <code>&lt;value&gt;</code> is 
the array to match. Equality matches on the array require an <i>exact</i> match of the specified <code>&lt;value&gt;</code>, <span class="bg-info">including the element order</span>.
</p>
<pre class="brush: js">
db.inventory.find( { ratings: [ 5, 8, 9 ] } );

// The operation returns the following document:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
</pre>
<h4>Match an Array Element</h4>
<p>Equality matches can specify a single element in the array to match. These specifications match if the array contains at least <i>one</i> element with the specified value.</p>
<pre class="brush: js">
db.inventory.find( { ratings : 5 } );

// The operation returns the following documents:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ]}
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ]}
</pre>
<h4>Match a Specific Element of an Array</h4>
<p>Equality matches can specify equality matches for an element at a particular index or position of the array using the <i>dot notation</i>.</p>
<pre class="brush: js">
db.inventory.find( { "ratings.0": 5 } );

// The operation returns the following documents:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ]}
</pre>
<h4>Specify Multiple Criteria for Array Elements</h4>
<p><b>Single Element Satisfies the Criteria</b>&nbsp;&nbsp;&nbsp;Use <code>$elemMatch</code> to specify multiple criteria on the elements of an array such that at least one array element satisfies all the specified criteria.</p>
<pre class="brush: js">
db.inventory.find( { ratings: { $elemMatch: { $gt: 5, $lt: 9 } } } );

// The operation returns the following documents:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ]}
</pre>
<p><b>Combination of Elements Satisfies the Criteria</b>&nbsp;&nbsp;&nbsp; The following example queries for documents where the <code>ratings</code> array contains elements that in some combination satisfy the query conditions; 
e.g., one element can satisfy the greater than 5 condition and another element can satisfy the less than 9 condition, or a single element can satisfy both:</p>
<pre class="brush: js">
db.inventory.find( { ratings: { $gt: 5, $lt: 9 } } );

// The operation returns the following documents:
{ _id: 5, type: "food", item: "aaa", ratings: [ 5, 8, 9 ]}
{ _id: 6, type: "food", item: "bbb", ratings: [ 5, 9 ]}
{ _id: 7, type: "food", item: "ccc", ratings: [ 9, 5, 8 ]}
</pre>
<h4>Array of Embedded Documents</h4>
<p>Consider that the <code>inventory</code> collection includes the following documents:</p>
<pre class="brush: js">
{
    _id: 100,
    type: "food",
    item: "xyz",
    qty: 25,
    price: 2.5,
    ratings: [ 5, 8, 9 ]
    memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]
}

{
    _id: 101,
    type: "fruit",
    item: "jkl",
    qty: 10,
    price: 4.25,
    ratings: [ 5, 9 ]
    memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]
}
</pre>
<p><b>Match a Field in the Embedded Document Using the Array Index</b>&nbsp;&nbsp;&nbsp; If you know the array index of the embedded document, you can specify the document using the embedded document's position using the <i>dot notation</i></p>
<pre class="brush: js">
db.inventory.find( { "memos.0.by": "shiping" } );

// The operation returns the following document:
{
    _id: 100,
    type: "food",
    item: "xyz",
    qty: 25,
    price: 2.5,
    ratings: [ 5, 8, 9 ],
    memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]
}
</pre>
<p><b>Match a Field Without Specifying Array Index</b>&nbsp;&nbsp;&nbsp; If you do not know the index position of the document in the array, concatenate the name of the field that contains the array, with a dot (.) and the name of the field in the embedded document.</p>
<pre class="brush: js">
db.inventory.find( { "memos.by": "shipping" } );

// The operation returns the following documents:
{
    _id: 100,
    type: "food",
    item: "xyz",
    qty: 25,
    price: 2.5,
    ratings: [ 5, 8, 9 ],
    memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]
}
{
    _id: 101,
    type: "fruit",
    item: "jkl",
    qty: 10,
    price: 4.25,
    ratings: [ 5, 9 ],
    memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]
}
</pre>
<h4>Specify Multiple Criteria for Array of Documents</h4>
<p><b>Single Element Satisfies the Criteria</b>&nbsp;&nbsp;&nbsp; Use <code>$elemMatch</code> operator to specify multiple criteria on an array of embedded documents such that at least one embedded document satisfies all the specified criteria.</p>
<pre class="brush: js">
db.inventory.find(
    {
        memos:
            {
                $elemMatch:
                    {
                        memo: "on time",
                        by: "shipping"
                    }
            }
    }
);

// The operation returns the following document:
{
    _id: 100,
    type: "food",
    item: "xyz",
    qty: 25,
    price: 2.5,
    ratings: [ 5, 8, 9 ],
    memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]
}
</pre>
<p><b>Combination of Elements Satisfies the Criteria</b>&nbsp;&nbsp;&nbsp; The following example queries for documents where the <code>memos</code> array contains elements that in some combination satisfy the query conditions; 
e.g. one element satisfies the field <code>memo</code> equal to <code>'on time'</code> condition and another element satisfies the field <code>by</code> equal to <code>'shipping'</code> condition. or a single element can satisfy both criteria:</p>
<pre class="brush: js">
db.inventory.find(
    {
        "memos.memo": "on time",
        "memos.by": "shipping"
    }
);

// The query returns the following documents:
{
    _id: 100,
    type: "food",
    item: "xyz",
    qty: 25,
    price: 2.5,
    ratings: [ 5, 8, 9 ],
    memos: [ { memo: "on time", by: "shipping" }, { memo: "approved", by: "billing" } ]
}
{
    _id: 101,
    type: "fruit",
    item: "jkl",
    qty: 10,
    price: 4.25,
    ratings: [ 5, 9 ],
    memos: [ { memo: "on time", by: "payment" }, { memo: "delayed", by: "shipping" } ]
}
</pre>

<h3>Limit Fields to Return from a Query</h3>
<p>The <i>projection</i> document limits the fields to return for all matching documents. The projection document can specify 
the inclusion of fields or the exclusion of fields.</p>
<pre class="brush: js">
db.users.find(
    { age: { $gt: 18 } },
    { name: 1, age: 1, id_: 0 }
).limit(5);
</pre>
<p>
Projection includes inclusive mode and exclusive mode, in which you can specify which fields to include and which fields to exclude
respectively. <span class="bg-danger">Except for excluding the <code>_id</code> field in inclusive projections, you cannot mix exclusive and inclusive
projections.</span>
</p>
<h4>Return All Fields in Matching Documents</h4>
<pre class="brush: js">
db.inventory.find( { type: 'food' } )
</pre>
<h4>Return the Specified Fields and the _id Field Only</h4>
<pre class="brush: js">
db.inventory.find( { type: 'food' }, { item: 1, qty: 1 } )
</pre>
<h4>Return Specified Fields Only (Inclusive Mode)</h4>
<pre class="brush: js">
db.inventory.find( { type: 'food' }, { item: 1, qty: 1, _id:0 } )
</pre>
<h4>Return All But the Excluded Field (Exclusive Mode)</h4>
<pre class="brush: js">
db.inventory.find( { type: 'food' }, { type:0 } )
</pre>
<h4>Projection for Array Fields</h4>
<p>For fields that contain arrays, MongoDB provides the following projection operators: <code>$elemMatch</code>, <code>$slice</code>, and <code>$</code>.</p>
<p>For example, the <code>inventory</code> collection contains the following document:</p>
<pre class="brush: js">{ "_id" : 5, "type" : "food", "item" : "aaa", "ratings" : [ 5, 8, 9 ] }</pre>
<p>Then the following operation uses the <code>$slice</code> projection operator to return just the first two elements in the ratings array.</p>
<pre class="brush: js">db.inventory.find( { _id: 5 }, { ratings: { $slice: 2 } } )</pre>
<p>
<code>$elemMatch</code>, <code>$slice</code>, and <code>$</code> are the only way to project portions of an array. For instance, you cannot project a 
portion of an array using the array index; e.g. <code>{ "ratings.0": 1 }</code> projection will not project the array with 
the first element.
</p>

<h2 class="jump">CRUD - U</h2>
<p>MongoDB provides the <code>update()</code> method to update the documents of a collection. The method accepts as its parameter:</p>
<ul>
    <li>an update conditions document to match the documents to update,</li>
    <li>an update operations document to specify the modification to perform, and</li>
    <li>an options document.</li>
</ul>
<p class="bg-info">To specify the update condition, use the sam structure and syntax as the query conditions.</p>
<p class="bg-info">By default, <code>update()</code> updates a single document. To update multiple documents, use the <i>multi</i> option.</p>

<h3>Update Specific Fields in a Document</h3>
<h4>Use update operators to change field values</h4>
<p>For the document with item equal to "MNO2", use the <code>$set</code> operator to update the category field and the 
details field to the specified values and the <code>$currentDate</code> operator to update the field lastModified with 
the current date.</p>
<pre class="brush: js">
db.inventory.update(
    { item: "MNO2" },
    {
        $set: {
            category: "apparel",
            details: { model: "14Q3", manufacturer: "XYZ Company" }
        },
        $currentDate: { lastModified: true }
    }
);
</pre>
<p>
The update operation returns a <code>WriteResult</code> object which contains the status of the operation. A successful update of the document returns the following object:
</p>
<pre class="brush: js">
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
</pre>
<p>
The <code>nMatched</code> field specifies the number of existing documents matched for the update, and <code>nModified</code> specifies the number of existing documents modified.
</p>
<h4>Update an embedded field</h4>
<p>
To update a field within an embedded document, use the <i>dot notation</i>. When using the dot notation, enclose the whole dotted field name in quotes.
</p>
<pre class="brush: js">
db.inventory.update(
    { item: "ABC1" },
    { $set: { "details.model": "14Q2" } }
);
</pre>
<h4>Update multiple documents</h4>
<p>
By default, the <code>update()</code> method updates a single document. To update multiple documents, use the <code>multi</code> option in the <code>update()</code> method.
</p>
<pre class="brush: js">
db.inventory.update(
    { category: "clothing" },
    {
        $set: { category: "apparel" },
        $currentDate: { lastModified: true }
    },
    { multi: true }
);
</pre>

<h3>Replace the Document</h3>
<p>To replace the entire content of a document except for the <code>_id</code> field, pass an entirely new document as the second argument to <code>update()</code>.</p>
<p class="bg-danger">
The replacement document can have different fields from the original document. In the replacement document, you 
can omit the <code>_id</code> field since the <code>_id</code> field is immutable. If you do include the <code>_id</code> field, it must be the same value as 
the existing value.
</p>
<h4>Replace a document</h4>
<pre class="brush: js">
db.inventory.update(
    { item: "BE10" },
    {
        item: "BE05",
        stock: [ { size: "S", qty: 20 }, { size: "M", qty: 5 } ],
        category: "apparel"
    }
);
</pre>

<h3>upsert Option</h3>
<p>By default, if no document matches the update query, the <code>update()</code> method does nothing.</p>
<p>
However, by specifying <code>upsert: true</code>, the <code>update()</code> method either updates matching document or documents, or
inserts a new document using the update specification if no matching document exists.
</p>
<h4>Specify upsert: true for the update replacement operation</h4>
<p>
When you specify <code>upsert: true</code> for an update operation to replace a document and no matching documents 
are found, MongoDB creates a new document using the equality conditions in the update conditions document, and 
replaces this document, except for the <code>_id</code> field if specified, with the update document. 
</p>
<pre class="brush: js">
db.inventory.update(
    { item: "TBD1" },
    {
        item: "TBD1",
        details: { "model" : "14Q4", "manufacturer" : "ABC Company" },
        stock: [ { "size" : "S", "qty" : 25 } ],
        category: "houseware"
    },
    { upsert: true }
)
</pre>
<p>
The update operation returns a <code>WriteResult</code> object which contains the status of the operation, including whether
the <code>db.collection.update()</code> method modified an existing document or added a new document.
</p>
<pre class="brush: js">
WriteResult({
    "nMatched" : 0,
    "nUpserted" : 1,
    "nModified" : 0,
    "_id" : ObjectId("53dbd684babeaec6342ed6c7")
});
</pre>
<p>The <code>nMatched</code> field shows that the operation matched 0 documents.</p>
<p>The <code>nUpserted</code> of 1 shows that the update added a document.</p>
<p>The <code>nModified</code> of 0 specifies that no existing documents were updated.</p>
<p>The <code>_id</code> field shows the generated <code>_id</code> field for the added document.</p>

<h4>Specify upsert: true for the update specific fields operation</h4>
<p>
When you specify <code>upsert: true</code> for an update operation that modifies specific fields and no matching documents 
are found, MongoDB creates a new document using the equality conditions in the update conditions document, and 
applies the modification as specified in the update document.
</p>
<pre class="brush: js">
db.inventory.update(
    { item: "TBD2" },
    {
        $set: {
            details: { "model" : "14Q3", "manufacturer" : "IJK Co." },
            category: "houseware"
        }
    },
    { upsert: true }
);
</pre>
<p>The update operation returns a <code>WriteResult</code> object.</p>

<h2 class="jump">CRUD - D</h2>
<p>
In MongoDB, the <code>db.collection.remove()</code> method removes documents from a collection. You can remove
all documents from a collection, remove all documents that match a condition, or limit the operation to remove just a
single document.
</p>
<h3>Remove All Documents</h3>
<p>
To remove all documents from a collection, pass an empty query document <code>{}</code> to the <code>remove()</code> method. The
<code>remove()</code> method does not remove the indexes.
</p>
<pre class="brush: js">
db.inventory.remove( {} )
</pre>
<p class="bg-info">
To remove all documents from a collection, it may be more efficient to use the <code>drop()</code> method to drop the entire
collection, including the indexes, and then recreate the collection and rebuild the indexes.
</p>

<h3>Remove Documents that Match a Condition</h3>
<p>To remove the documents that match a deletion criteria, call the <code>remove()</code> method with the <code>&lt;query&gt;</code> parameter.</p>
<pre class="brush: js">
db.inventory.remove( { type : "food" } )
</pre>
<p>To remove a single document, call the <code>remove()</code> method with the <code>justOne</code> parameter set to true or 1.</p>
<pre class="brush: js">
db.inventory.remove( { type : "food" }, 1 )
</pre>
<p class="bg-info">To delete a single document sorted by some specified order, use the <code>findAndModify()</codeSpecific Fields> method.</p>
