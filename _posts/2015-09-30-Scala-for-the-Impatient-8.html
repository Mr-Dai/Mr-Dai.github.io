---
layout: posts
title: 《快学Scala》第8章：继承
author: Robert Peng
category: Scala
---

<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<h2 class="jump">前情提要</h2>
<p>
	在<a href="/scala/2015/09/28/Scala-for-the-Impatient-7.html">上一期</a>的内容中，我们学习了Scala中的包，
	了解了如何通过不同形式的<code>package</code>和<code>import</code>语句来管理Scala项目的包结构和包引入。
</p>
<p>
	在项目开发中，光是懂得如何使用<code>package</code>和<code>import</code>是远远不够的。今天我们就来学习Scala面向对象最常用的功能——类的继承。
</p>
<hr />
<h2 class="jump">8.1 扩展类</h2>
<p>Scala使用<code>extends</code>关键字来扩展类，与Java相同：</p>
<pre class="brush: scala">
class Employee extends Person {
  var salary = 0.0
  ...
}
</pre>
<p>
	和Java一样，你可以将类声明为<code>final</code>，这样它就不能被扩展了。你还可以将单个方法或字段声明为<code>final</code>，以确保它们不能被重写。
	注意，在Java中，<code>final</code>字段是不可重写且不可变的，相当于Scala中的<code>val</code>字段。但在Scala中，<code>final</code>字段仅仅意味着它不能被重写，
	<code>final var</code>字段仍然是可变的。
</p>
<hr />
<h2 class="jump">8.2 重写方法</h2>
<p>在Scala中重写一个非抽象方法<b>必须</b>使用<code>override</code>修饰符：</p>
<pre class="brush: scala">
class Person {
  ...
  override def toString = getClass.getName = "[name=" + name + "]"
}
</pre>
<p>
	在这一点上，<code>override</code>修饰符与Java中的<code>@Overrides</code>注解功能相似，它主要用于确保你在子类写的方法确实重写了超类的方法，
	并在你因打错字或使用了错误的参数类型等原因没能成功重写超类方法时给出有用的错误提示。
</p>
<p>
	在子类中重写了方法以后，子类中对该方法的调用自然调用的是子类中重写后的版本。当需要调用超类的版本时，和Java一样，我们使用<code>super</code>关键字：
</p>
<pre class="brush: scala">
class Employee extends Person {
  ...
  override def toString = super.toString + "[salary=" + salary + "]"
}
</pre>
<hr />
<h2 class="jump">8.3 类型检查和转换</h2>
<p>
	要测试某个对象是否属于某个给定的类或其子类时，可以用<code>isInstanceOf</code>方法。如果测试成功，
	你就可以用<code>asInstanceOf</code>方法将引用转换为子类的引用：
</p>
<pre class="brush: scala">
if (p.isInstanceOf[Employee]) {
  val s = p.asInstanceOf[Employee]  // s的类型为Employee
  ...
}
</pre>
<p>
	如果<code>p</code>指向的是<code>Employee</code>类及其子类的对象，则<code>p.isInstanceOf[Employee]</code>将会成功。
	在功能上，<code>asInstanceOf</code>和Java的<code>instanceof</code>关键字是相同的。
</p>
<p>
	如果<code>p</code>是<code>null</code>，则<code>p.isInstanceOf[Employee]</code>将返回<code>false</code>，
	且<code>p.asInstanceOf[Employee]</code>将返回<code>null</code>。
</p>
<p>
	如果<code>p</code>不是一个<code>Employee</code>，则<code>p.asInstanceOf[Employee]</code>将抛出<code>ClassCastException</code>异常。
	在功能上，<code>asInstanceOf</code>和Java中的强制类型转换是相同的。
</p>
<p>
	如果你想要测试<code>p</code>指向的是一个<code>Employee</code>对象但又不是其子类的话，可以用：
</p>
<p><code>if (p.getClass == classOf[Employee])</code></p>
<p>其中<code>classOf[Employee]</code>相当于Java中的<code>Employee.class</code>。</p>
<p class="bg-info" style="padding: 10px">
	个人来讲，我很欣赏<code>asInstanceOf</code>的功能，因为Java的强制类型转换语法写在链式语句里时往往需要添加大量的括号，很影响代码的可读性。
	Scala的<code>asInstanceOf</code>语法与方法调用相同，使得在链式操作中出现强制类型转换时，语句仍能简洁清晰。<br />
	<code>isInstanceOf</code>的作用不好评判，因为Java中的<code>instanceof</code>关键字已经够简洁了。我想，少写两个空格也许对某些人来说还是挺受欢迎的吧。<br />
	至于<code>classOf</code>，我个人觉得这个设计并不好。在链式调用中，Java的<code>Employee.class</code>吻合方法调用的语法，也吻合人们从左到右的阅读习惯。
	Scala的<code>classOf[Employee]</code>则更像是函数的调用，而且也违背了人们习惯的阅读顺序。
</p>
<hr />
<h2 class="jump" id="protected">8.4 受保护字段和方法</h2>
<p>
	Scala可以和Java一样，将类的字段或方法声明为<code>protected</code>。和Java有所不同，Scala的<code>protected</code>成员只能被所属类及其子类所访问，
	而Java的<code>protected</code>在此基础上还允许同一个包内的其他任意类所访问。个人认为Scala的设计更好，因为这样的<code>protected</code>与我们熟知的C++中的<code>protected</code>保持了一致。
	如果我们确实需要像Java的<code>protected</code>那样的包可见性，我们也可以通过Scala的<a href="/scala/2015/09/28/Scala-for-the-Impatient-7.html#package-visibility" target="_blank">包修饰符</a>来指定任意粒度的包可见性。
</p>
<p>
	Scala还提供了<code>protected[this]</code>这样的写法。包修饰符限定了该成员只可被<a href="/scala/2015/09/04/Scala-for-the-Impatient-5.html#private-this" target="_blank">当前对象</a>访问，比Java的<code>private</code>可见范围更小。
	实际上，<code>protected[this]</code>和<code>private[this]</code>的功能是一样的。
</p>
<p>
	有关Scala类和成员的包可见性，我会在<a href="/scala/2015/12/03/Scala-Package-Visibility.html" target="_blank">另一篇博文</a>中进行详述。
</p>
<hr />
<h2 class="jump" id="constructing-super-class">8.5 超类的构造</h2>
<p>
	在之前的<a href="/scala/2015/09/04/Scala-for-the-Impatient-5.html#primary-and-auxiliary-constructor" target="_blank">章节</a>中，我们提到过，一个类有一个主构造器和任意数量的辅助构造器，而每个辅助构造器都必须以对先前定义的辅助构造器或主构造器的调用开始。
</p>
<p>
	同时，考虑到子类对超类构造器的调用是写在<code>extends</code>子句中的，如下面一段示例：
</p>
<pre class="brush: scala">
class Employee(name: String, age: Int, val salary: Double) extends
  Person(name, age)
</pre>
<p>
	上述代码实际上由子类<code>Employee</code>的主构造器调用了超类<code>Person</code>的构造器。因此，
	实际上子类的辅助构造器<b>永远都不可能</b>直接调用超类的构造器。子类的辅助构造器最终都会调用子类的主构造器，而只有子类的主构造器可以调用超类的构造器。
</p>
<p>
	尽管对于Java程序员来讲，这样的写法可能不是那么的直接，但它显然是简洁的。与上述代码等价的Java大致如下：
</p>
<pre class="brush: java">
public class Employee extends Person {
  public String name;
  public int age;
  private final double salary;
  
  public Employee(String name, int age, double salary) {
    super(name, age);
	this.salary = salary;
  }
}
</pre>
<p>
	Scala类也可以扩展Java类，扩展时的写法不变，同样是在主构造器里调用Java超类的一个构造器：
</p>
<pre class="brush: scala">
class Square(x: Int, y: Int, width: Int) extends
  java.awt.Rectable(x, y, width, width)
</pre>
<hr />
<h2 class="jump" id="overriding-field">8.6 重写字段</h2>
<p>
	<a href="/scala/2015/09/04/Scala-for-the-Impatient-5.html#getter-and-setter" target="_blank">之前</a>我们提到过，
	Scala的字段由一个私有字段和它的Getter、Setter方法组成。
</p>
<p>
	在子类中，你可以用一个同名的<code>val</code>字段重写超类的一个<code>val</code>（或不带参数的<code>def</code>）。
	实际的效果是，子类中将多出一个私有字段（该字段不会重写超类的字段）和一个公有的Getter方法，该Getter方法重写了超类的Getter方法。
</p>
<p>例如：</p>
<pre class="brush: scala">
abstract class Person(val name: String) {
  def id: Int
  override def toString = getClass.getName + "[name=" + name + "]"
}

class Student(override val id: Int) extends Person

class SecretAgent(codename: String) extends Person(codename) {
  override val name = "secret"
  override val toString = "secret"
}
</pre>
<p>
	其中，<code>Student</code>类用一个<code>val</code>重写了超类<code>Person</code>中的无参数<code>def</code>方法<code>id</code>，
	<code>SecretAgent</code>用<code>val name</code>重写了超类<code>Person</code>中的<code>val</code>，
	并用<code>val toString</code>重写了超类<code>Person</code>中的无参数<code>def</code>方法。
</p>
<p>简单来讲，子类对超类字段的重写有如下规律：</p>
<table class="table">
  <tr>
    <th></th>
	<th>用<code>val</code></th>
	<th>用<code>def</code></th>
	<th>用<code>var</code></th>
  </tr>
  <tr>
    <th>重写<code>val</code></th>
	<td>
	  <ul>
	    <li>子类产生一个与超类字段同名的私有字段</li>
		<li>子类字段的Getter方法重写超类的Getter方法</li>
	  </ul>
	</td>
	<td>错误</td>
	<td>错误</td>
  </tr>
  <tr>
    <th>重写<code>def</code></th>
	<td>
	  <ul>
	    <li>子类产生一个与超类字段同名的私有字段</li>
		<li>子类字段的Getter方法重写超类的Getter方法</li>
	  </ul>
	</td>
	<td>子类方法重写父类方法，与Java相同</td>
	<td><code>var</code>将同时重写Getter/Setter对。只重写Getter将出错</td>
  </tr>
  <tr>
    <th>重写<code>var</code></th>
	<td>错误</td>
	<td>错误</td>
	<td>只可以重写抽象的<code>var</code></td>
  </tr>
</table>
<p>
	由此可见，在类中用<code>var</code>没有什么问题，但实际上这样会使得类的可扩展性下降，因为只有抽象的<code>var</code>可以被子类的<code>var</code>重写，
	如果你使用的是非抽象的<code>var</code>，子类将无法重写该字段。
</p>
<hr />
<h2 class="jump" id="anonymous-subclass">8.7 匿名子类</h2>
<p>
	和Java一样，Scala可以以同样的方式在创建对象时构建一个匿名子类：
</p>
<pre class="brush: scala">
val alien = new Person("Fred") {
  def greeting = "Grettings, Earthling! My name is Fred."
}
</pre>
<p>
	实际上，这会产生出一个结构类型（structural type）对象，记作<code>Person{def greeting: String}</code>。
	你甚至可以用这个类型作为参数的类型：
</p>
<pre class="brush: scala">
def meet(p: Person{def greeting: String}) {
  println(p.name + "says: " + p.greeting)
}
</pre>
<hr />
<h2 class="jump" id="abstract-class">8.8 抽象类</h2>
<p>和Java一样，你可以用<code>abstract</code>关键字来把某个没有完整定义所有方法的类标记为不能实例化的虚类：</p>
<pre class="brush: scala">
abstract class Person(val name: String) {
  def id: Int
}
</pre>
<p>其中方法<code>id</code>没有方法体，自动被识别为抽象方法。</p>
<p>在子类中重写超类的抽象方法时，你不需要使用<code>override</code>关键字：</p>
<pre class="brush: scala">
class Employee(name: String) extends Person(name) {
  def id = name.hashCode
}
</pre>
<hr />
<h2 class="jump" id="abstract-field">8.9 抽象字段</h2>