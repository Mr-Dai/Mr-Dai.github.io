---
layout: post_original
title: 《快学Scala》第5章：类
author: Robert Peng
category: Scala
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<h2 class="jump">前情提要</h2>
<p>
	在<a href="{{ site.url }}{% post_url 2015-08-13-Scala-for-the-Impatient-2-2 %}">上一篇文章</a>中，我们完成了《快学Scala》第二章的学习，了解了Scala的控制结构与函数声明。
</p>
<p>
	这里我决定跳过《快学Scala》的第3、4章，这两章分别讲解的是Scala中的Array、ArrayBuffer、Seq、List、Map、Set的用法。
	我认为这些动态容器并不属于Scala语言本身，它们更像是随Scala附带的工具，讲解它们就像是在Java教程中讲解Spring的使用方法一般无谓，因此我不打算在这个系列文章中浪费口舌讲解这些容器的使用方法。
	但这并不代表它们不重要，它们共同组成了Scala的Collection Framework，与Java中的ArrayList、HashSet等同等重要。
	毋庸置疑它们的使用方法是每一个Scala程序员都必须掌握的，但我认为它们使用的难度实在太低，没什么可讲的。
	有兴趣的读者可以自行学习《快学Scala》的第3、4章或是查看这些容器的ScalaDoc。
</p>
<p>
	接下来我们就进入《快学Scala》第5章的，学习Scala中的面向对象编程。
</p>
<h2 class="jump">5.1 简单类和无参方法</h2>
<p>Scala类最简单的形式看上去和Java或C++中的很相似：</p>
<pre class="brush: scala">
class Counter {
  private var value = 0 // 你必须初始化字段
  def increment() {		// 未声明为private或protected的类、域和方法都默认是public的
	value += 1          // （实际上是因为Scala已经删掉了public关键字）
  }
}
</pre>
<p>实例化这样一个类的方式与Java类似：</p>
<pre class="brush: scala">
val myCount = new Counter // 或new Counter()
</pre>
<p>
	这里就出现了Scala的一个特性。调用无参方法，比如<code>Counter</code>的构造方法或<code>increment</code>时，你可以写上圆括号，也可以不写。
	这种可写可不写的自由容易导致代码变得难以理解，毕竟如果不写上圆括号很容易把这个方法误解为一个变量。但我们不妨将错就错。
	实际上，推荐的做法是我们仅在类似于 Getter 这样不会改变对象自身的取值方法上使用无括号的写法，如<code>Iterator#next</code>等方法，
	让阅读者将其“暂时地”理解为一个变量，反而可以有效地避免阅读者陷入复杂的取值逻辑之中。
	而对于像<code>increment</code>这样确实会改变对象自身的 Setter 方法，我们最好还是加上一对圆括号提醒阅读者，这个方法会导致对象发生改变。
</p>
<p>在声明无参函数时，我们同样可以不加上圆括号：</p>
<pre class="brush: scala">
class MyIterator extends Iterator {
	override def next = super.next
}
</pre>
<p>
	但声明无括号的无参函数与声明有括号的无参函数是不同的。将无参函数声明为无括号形式则强制所有该函数的调用都不能加上括号，
	而声明为有括号形式的话，调用者则可以自由选择是否写上圆括号。
</p>
<p>那么这两种声明有什么差异呢？我们编写这样一段代码：</p>
<pre class="brush: scala">
class ParenOrNot {
	def iHaveParens(): Unit = println("Hello Parentheses!")
	def iDontHaveParens: Unit = println("Goodbye Parentheses!")
	
	def main(): Unit = {
		iHaveParens
		iHaveParens()
		iDontHaveParens
	}
}
</pre>
<p>反编译结果如下：</p>
<pre class="brush: java">
import scala.Predef$;

public class ParenOrNot {

    public ParenOrNot() {}

    public void iHaveParens() {
        Predef$.MODULE$.println("Hello Parentheses!");
    }

    public void iDontHaveParens() {
        Predef$.MODULE$.println("Goodbye Parentheses!");
    }

    public void main() {
        iHaveParens();
        iHaveParens();
        iDontHaveParens();
    }
}
</pre>
<p>看起来，声明无参函数时圆括号的有无并不会改变编译得出的Java字节码，圆括号的约束完全由Scala的编译器所定义。</p>
<h2 class="jump" id=" Getter -and- Setter ">5.2 Getter与Setter</h2>
<p>注：本节包括原书的5.2与5.3节的内容</p>
<p>
	我们在编写Java类的时候，我们并不喜欢使用public字段。我们更加倾向于使用private或protected字段，并为他们加上public的 Getter 和 Setter ，
	就像这样：
</p>
<pre class="brush: java">
public class Person {

	private String name;
	private int age;
	
	public String getName() {
		return name;
	}
	
	public void setName(String name) {
		this.name = name;
	}
	
	public int getAge() {
		return age;
	}
	
	public void setAge(int age) {
		this.age = age;
	}

}
</pre>
<p>
	为什么要这样写？为什么不直接把变量置为public？当然，在如此简单的情况下，把变量置为private然后加上public的 Getter 和 Setter 当然是一种相当无聊的做法，
	但实际上 Getter 方法和 Setter 方法的存在使得为这两个操作添加复杂逻辑提供了可能。比如说上面的<code>setAge</code>，我们可以将其设定为不能使一个人变年轻：
</p>
<pre class="brush: java">
public void setAge(int age) {
	if (age > this.age)
		this.age = age;
}
</pre>
<p>
	要实现这样的功能只能通过 Setter 方法。即使你原本是public的变量，当你需要实现这样的功能时，你还是得将其重写为这种繁杂的形式。尽管这种形式也是Java规范的面向对象特性之一，
	但这样写起来确实是很费事。那有没有一些折衷的办法呢？
</p>
<p>
	在Scala中，编译器会为每个public的字段自动生成 Getter 和 Setter 方法（注：必须谨记Scala中不存在<code>public</code>关键字）。
	我们可以这样定义一个字段：
</p>
<pre class="brush: scala">
class Person {
	var age = 0
}
</pre>
<p>
	而后，Scala便会生成一个private的变量，并添加上public的 Getter 和 Setter 。像上述的<code>age</code>变量，Scala为其生成的 Getter 和 Setter 分别名为
	<code>age</code>和<code>age_=</code>。当我们把变量声明为<code>val</code>时，Scala则只会为该变量生成 Getter ，不会生成 Setter 。
</p>
<p>
	我们不妨来试验一下：
</p>
<pre class="brush: scala">
class GetAndSet {

	var iAmPublicVar: Int = 1
	protected var iAmProtectedVar: Int = 2
	private var iAmPrivateVar: Int = 3
	
	val iAmPublicVal: Int = 4
	protected val iAmProtectedVal: Int = 5
	private val iAmPrivateVal: Int = 6

}
</pre>
<p>反编译的结果为：</p>
<pre class="brush: java">
public class GetAndSet {

	public GetAndSet() {
        iAmPublicVar = 1;
        iAmProtectedVar = 2;
        iAmPrivateVar = 3;
    }

	
    private int iAmPublicVar;
    public int iAmPublicVar() {
        return iAmPublicVar;
    }
    public void iAmPublicVar_$eq(int x$1) {
        iAmPublicVar = x$1;
    }

	
    private int iAmProtectedVar;
    public int iAmProtectedVar() {
        return iAmProtectedVar;
    }
    public void iAmProtectedVar_$eq(int x$1) {
        iAmProtectedVar = x$1;
    }
	
	
    private int iAmPrivateVar;
    private int iAmPrivateVar() {
        return iAmPrivateVar;
    }
    private void iAmPrivateVar_$eq(int x$1) {
        iAmPrivateVar = x$1;
    }

	
    private final int iAmPublicVal = 4;
    public int iAmPublicVal() {
        return iAmPublicVal;
    }
	
	
    private final int iAmProtectedVal = 5;
    public int iAmProtectedVal() {
        return iAmProtectedVal;
    }

	
    private final int iAmPrivateVal = 6;
    private int iAmPrivateVal() {
        return iAmPrivateVal;
    }
}
</pre>
<p>
	我们看到，对于<code>private</code>的变量，Scala同样会生成<code>private</code>的 Getter 和 Setter ，但<code>protected</code>变量的 Getter 和 Setter 却被声明为了
	<code>public</code>。
</p>
<p>
	但为了给Setter添加更多的逻辑，我们仍然需要显式地给出Setter的实现。考虑刚才的<code>Person</code>类，我们又想对<code>age</code>的 Setter 加入较为复杂的逻辑。
	这个时候我们仍然需要将<code>age</code>置为<code>private</code>并改名，并写上 Getter ：
</p>
<pre class="brush: scala">
class Person {
	private var privateAge = 0
	
	def age = privateAge
	def age_=(newValue: Int) {
		if (newValue > privateAge) privateAge = newValue
	}
}
</pre>
<p>我们仍然可以如同访问<code>public</code>的<code>age</code>变量那般改变<code>privateAge</code>变量：</p>
<pre class="brush: scala">
val fred = new Person
fred.age = 30 // 有效，Fred的privateAge变为30
fred.age = 21 // 无效，Fred的privateAge大于21，因此不会发生改变
println(fred.age) // 30
</pre>
<p>
	实际上，Scala这样的设计是为了遵循一个名为“统一访问原则”的设计原则：
</p>
<blockquote>
<p>All services offered by a module should be available through a uniform notation, which does not betray whether they are implemented through storage or through computation.</p>
<footer>Uniform Access Principle</footer>
</blockquote>
<p>
	这样的设定对Scala类来讲是很有益处的。试想你是一个库开发者，你开发的库中的一个接口类中有一个变量<code>a</code>，库的使用者们开发了大量的客户端代码，依赖于变量<code>a</code>。
	终于，随着版本的更新，你觉得<code>a</code>的设定很不好，你决定从类中移除它，但又考虑到有那么多的客户端代码依赖着它。这时，你可能会想将它设置为<code>@Deprecated</code>并在未来某个版本中移除它。
	<code>@Deprecated</code>可以给客户端代码的开发者一段时间，警告他们不要再使用这个变量，但在你真正删除了这个变量的时候，总是会有那么一些客户端代码还没来得及更新。
	由此，与其只是删掉它，你可以显式地继续提供它对应的Getter和Setter：<code>a()</code>和<code>a_=(newVal)</code>。如此一来，即使<code>a</code>变量事实上已经被删除，客户端代码仍然不会受到任何影响。
</p>
<h2 class="jump" id="private-this">5.3 对象私有字段</h2>
<p>
	与Java/C++相同，通过为字段添加上<code>private</code>即可将其声明为类私有字段。类私有字段可以被属于同一个类的任意对象所访问，
	这意味着<code>A</code>类对象<code>a</code>实际上可以访问同为<code>A</code>类对象的<code>b</code>的类私有字段。
</p>
<p>
	这种设定其实很奇怪，有些时候我们会希望<code>private</code>字段只能由当前对象访问，即使是同一个类的其他对象也不能访问。
	这样的设定在Scala中是支持的，我们把这样的字段称为对象私有字段。通过将字段声明为<code>private[this]</code>即可将其设为对象私有字段。
</p>
<p>
	那么这样的字段和普通的类私有字段有什么不同呢？
</p>
<pre class="brush: scala">
class Privacy {
	private val iAmPrivateVal = 1
	private[this] val iAmPrivateThisVal = 2
}
</pre>
<p>反编译结果为：</p>
<pre class="brush: java">
public class Privacy {

    public Privacy() {}

    private final int iAmPrivateVal = 1;
    private final int iAmPrivateThisVal = 2;

    private int iAmPrivateVal() {
        return iAmPrivateVal;
    }
}
</pre>
<p>
	我们看到，Scala像往常一样为类私有字段生成了一个 Getter ，但并没有对对象私有字段生成任何 Getter 。可见，尽管Java中的private仅能做到类私有，
	考虑到Scala会把所有类字段的访问转换为对其 Getter 的调用，不为对象私有字段生成 Getter 和 Setter 便能确保其无法被其他对象所访问。
</p>
<h2 class="jump">5.4 Bean属性</h2>
<p>
	正如我们之前所学的那样，Scala会为类的字段自动生成 Getter 和 Setter 方法，但从这些方法的命名上看，很明显这样的方法不是Java工具所预期的，
	这样的方法无法被Spring、Hibernate等依赖于JavaBean规范的工具所使用。
</p>
<p>
	Scala提供了一个<code>@BeanProperty</code>注解。当你为某个字段添加上该注解时，Scala会在原有 Getter / Setter 的基础上再加上一对满足JavaBean规范的 Getter 和 Setter ：
</p>
<pre class="brush: scala">
import scala.beans.BeanProperty

class Bean {
	@BeanProperty
	var name: String = _
}
</pre>
<p>反编译的结果为：</p>
<pre class="brush: java">
public class Bean {

    private String name;
    
	public Bean() {}

    public String name() {
        return name;
    }

    public void name_$eq(String x$1) {
        name = x$1;
    }

    public void setName(String x$1) {
        name = x$1;
    }

    public String getName() {
        return name();
    }
}
</pre>
<p>如此可见，Scala确实为一个<code>BeanProperty</code>生成了4个方法。</p>
<p>
	除了<code>BeanProperty</code>以外实际上还有一个<code>BooleanBeanProperty</code>。它和<code>BeanProperty</code>的功能基本相同，
	但它为变量生成的 Getter 的名称为<code>isXXX</code>。
</p>
<h2 class="jump" id="primary-and-auxiliary-constructor">5.5 主构造器与辅助构造器</h2>
<p>注：这里整合了原书的5.6节与5.7节，并改变了编写顺序。</p>
<p>
	Scala和Java或C++相同，一个类可以拥有任意数量的构造器。不过，Scala类会拥有一个<b>主构造器</b>（Primary Constructor），
	它比其他构造器更加重要。
</p>
<p>在Scala中，我们通过这样的方式来声明类的主构造器：</p>
<pre class="brush: scala">
class Person(val name: String, val age: Int) {
	println("Just constructed another person")
}
</pre>
<p>
	我们通过在声明类时在类名后加入参数列表，便能以该参数列表自动生成一个主构造器；当我们不加入参数列表，或者说没有为类显式定义主构造器时，Scala便会自动为类生成一个无参的主构造器。
	而类定义体内的所有语句都将被放入到主构造器中。像上述的代码，反编译的结果为：
</p>
<pre class="brush: java">
import scala.Predef$;

public class Person {

    private final String name;
    private final int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        super();
        Predef$.MODULE$.println("Just constructed another person");
    }

    public String name() {
        return name;
    }

    public int age() {
        return age;
    }
}
</pre>
<p>
	这里我们就能看到，写在类定义体中的<code>println</code>语句确实被放入了构造器之中，Scala也将主构造器的参数作为类的<code>public</code>字段，
	按照类字段的规则为它们生成 Getter 和 Setter 。由于<code>Person</code>类主构造器的两个参数被定义为了<code>val</code>，那么不难想象，通过将它们定义为<code>var</code>
	或加上<code>BeanProperty</code>注解便能让Scala为我们生成我们想要的 Getter 和 Setter 了。
</p>
<p>
	如此看来，Scala一小行代码便能完成Java好几十行才能写完的功能，可谓便捷至极。
</p>
<p>如果我们需要改变主构造器或者主构造器参数所对应字段的可访问范围，我们也可以在它们之前加上<code>private</code>关键字：</p>
<p><code>class Person private(val name: String, private val age: Int)</code></p>
<p>如此一来，<code>Person</code>类的主构造器便会被声明为<code>private</code>，而<code>age</code>的 Getter 也不会被生成。</p>
<p>我们还可以选择不为主构造器的参数声明<code>var</code>或<code>val</code>：</p>
<p><code>class Person(name: String, age: Int)</code></p>
<p>
	这种做法使得主构造器参数可以变为单纯的方法参数，而不会在类中生成同名字段以及 Getter 和 Setter 。但即便如此，如果参数被类中其他方法所引用的话，它依然会被升格为字段，
	但这样的字段是等同于被声明为<code>private[this]</code>的对象私有字段，它的 Getter 和 Setter 方法均不会被生成。
</p>
<p>
	除了主构造器以外，Scala类还能拥有任意数量的<b>辅助构造器</b>（Auxilary Constructor）。我们通过在类中<code>def</code>一个名为<code>this</code>的方法来定义一个辅助构造器：
</p>
<pre class="brush: scala">
class Person(val name: String, val age: Int) {
	def this() {
		this("Robert", 18)
	}
}
</pre>
<p>
	在辅助构造器中，我们通过调用其他<code>this</code>方法来将构造工作委托给其他构造器，所有辅助构造器都必须以对主构造器和其他已定义的辅助构造器的调用开始。
	相比于Java，Scala使用<code>this</code>来为一个类声明更多的构造器，而Java需要让构造器的名字与类名保持一致，这样一来当你需要修改类名的时候就不那么方便了。
</p>
<h2 class="jump">5.6 嵌套类</h2>
<p>在Java中，我们可以在类中定义方法，可以在类或方法中定义类（嵌套类），而Scala更进一步，还可以在方法中定义方法。我们一步一步来，先从嵌套类开始。</p>
<p>Scala嵌套类的声明方式实际上和Java完全一致：</p>
<pre class="brush: scala">
class Network {
	class Member(val name: String) {
		// 嵌套类Member的定义...
	}
	
	// 外部类Network的定义...
}
</pre>
<p>
	和Java不同的在于，Scala的每个外部类实例都有着它自己独有的嵌套类。考虑两个不同的<code>Network</code>对象：<code>weibo</code>和<code>weChat</code>，
	那么<code>weibo.Member</code>和<code>weChat.Member</code>则是不同的两个类。这样的设定实际上相比于Java的设定更加合理，毕竟对于社交网络而言，
	微博的用户和微信的用户本来就不应该是同一种类型。
</p>
<p>
	实例化一个嵌套类的方法也有所不同。在Scala中，我们可以直接通过<code>new weChat.Member</code>来实例化一个微信用户，而Java则需要用<code>weChat.new Member()</code>这种古怪的语法。
</p>
<p>
	对于不同的外部类对象有着完全不同类型的嵌套类的这一特性，对于社交网络这样的案例当然说得通，但对于某些其他场景，这样的特性也可能是不妥的。当你不需要这样的特性的时候，
	有两种方式可以解决。
</p>
<p>
	一是将内部类<code>Member</code>移到别的地方，如外部类<code>Network</code>的伴生对象：
</p>
<pre class="brush: scala">
class Network {
	// 类Network的定义...
}

object Network {
	class Member(val name: String) {
		// 嵌套类Member的定义...
	}
	
	// Network伴生对象的定义...
}
</pre>
<p>
	我们知道（或即将知道），任何声明在类的伴生对象中的方法或字段都将成为该类的静态成员，因此将嵌套类<code>Member</code>声明在<code>Network</code>类的伴生对象中相当于在Java中声明了一个静态嵌套类。
</p>
<p>
	除了使用静态嵌套类，我们还可以使用类型投影（Type Projection）：<code>Network#Member</code>即指“任何<code>Network</code>类的<code>Member</code>”。
	声明一个<code>ArrayBuffer[Network#Member]</code>对象我们就可以在其中同时放入微博和微信的用户了。
</p>
<p>我们可以写一段这样的测试代码：</p>
<pre class="brush: scala">
class Outer {
	private val outerX = 3
	class Inner {
		private val innerX = 4
		def getOuterX() = outerX
	}
}

object Outer {
	private val staticOuterX = 5
	class StaticInner {
		private val staticInnerX = 6
		def getStaticOuterX() = staticOuterX
	}
	
	def main(args: Array[String]) {
		val outer1 = new Outer
		val outer2 = new Outer
		
		val inner1 = new outer1.Inner
		val inner2 = new outer2.Inner
		
		println(inner1.getClass == inner2.getClass) // true
		
		val staticInner1 = new Outer.StaticInner
		val staticInner2 = new Outer.StaticInner
		
		println(staticInner1.getClass == staticInner2.getClass) // true
	}
}
</pre>
<p>
	从运行结果上看，Scala的内部类自然是不可能突破JVM的限制，<code>inner1</code>和<code>inner2</code>对象仍然属于同一个类，尽管它们属于不同的外部类对象。
	这个问题我们先保留一下，先来看看静态嵌套类。静态嵌套类对象<code>staticInner1</code>和<code>staticInner2</code>属于相同的类，考虑到如果声明在伴生对象中的嵌套类确实等同于Java的静态嵌套类的话，
	有这样的返回结果是完全可以理解的。我们不妨来看一下反编译的结果。实际上上述代码会生成两个类：<code>Outer</code>和<code>Outer$</code>，其中<code>Outer$</code>即为<code>Outer</code>的伴生对象类。
	我们先来看看<code>Outer</code>类：
</p>
<pre class="brush: java">
public class Outer {

    private final int Outer$$outerX = 3;
	// 为了区别外部类的outerX以及内部类中可能出现的同样叫做outerX的变量，
	// Scala为外部类的outerX在原有的变量名前加上了Outer$$使之能与内部类中可能出现的outerX变量有所区分。
	// 这里加上的前缀不能只是Outer$，因为Outer$指代的是Outer的伴生对象类。待会我们就会看到为什么。

    public Outer() {}

    public int Outer$$outerX() {
        return Outer$$outerX;
    }
	// 在确定Outer.outerX的实际变量名后，同样生成了对应的 Getter 
	
    public class Inner {

        private final int innerX;
        public final Outer $outer;
		// 这里多了一个外部类对象的引用
		// 实际上这点上Scala和Java是相同的，Java的内部类也会带有一个指向外部对象的引用

        public Inner() {
            if (Outer.this == null) {
                throw null;
            } else {
                this.$outer = Outer.this;
                super();
                innerX = 4;
                return;
            }
			// 在构造器内部将$outer变量指向了具体的外部类对象
        }

        private int innerX() {
            return innerX;
        }

        public int getOuterX() {
            return Outer$Inner$$$outer().Outer$$outerX();
        }
		// 调用了$outer的 Getter 取得外部类对象的引用
		// 再调用了Outer$$outerX的 Getter 来获得外部类对象的outerX

        public Outer Outer$Inner$$$outer() {
            return $outer;
        }
    }

	// 声明在伴生对象中的StaticInner以静态嵌套类的形式出现在了这里
    public static class StaticInner {

        private int staticInnerX() {
            return staticInnerX;
        }

        public int getStaticOuterX() {
            return Outer$.MODULE$.Outer$$staticOuterX();
			// 这里看到了伴生对象类Outer$的静态成员MODULE$。
			// 实际上在之前我们也有看到过这个静态成员
        }

        private final int staticInnerX = 6;

        public StaticInner() {}
    }

	// Outer类的PSVM调用了伴生对象的main方法
    public static void main(String args[]) {
        Outer$.MODULE$.main(args);
    }
}
</pre>
<p>接下来我们看看伴生对象类<code>Outer$</code>：</p>
<pre class="brush: java">
// 该类实际上无法被jad工具正确反编译，因此有些地方看起来可能有点奇怪
import scala.Predef$;
import scala.runtime.BoxesRunTime;

// Outer$类被标记为final。伴生对象类Outer$确实只应该属于Outer类，使之无法被继承也完全可以理解
public final class Outer$ {

    public static final Outer$ MODULE$ = this;
	// 这段Java代码实际上有问题，静态成员MODULE$不应该引用非静态变量this
    static {
        new Outer$();
    }
	// 结合这段奇怪的static代码块，我们可以把上面这段代码理解成：
	// public static final Outer$ MODULE$ = new Outer$();

    private Outer$() {}
	// 构造器是private的，而static逻辑在类被ClassLoader载入时便会执行
	// 也就是说在ClassLoader载入类Outer$时，它的单例就已经被生成并放入到静态变量MODULE$中
	
	
    private final int Outer$$staticOuterX = 5;

    public int Outer$$staticOuterX() {
        return Outer$$staticOuterX;
    }

	// Outer$的main方法，在Outer的PSVM中被调用
    public void main(String args[]) {
        Outer.Inner inner1;
        Outer.Inner inner2;
        Outer outer1 = new Outer();
        Outer outer2 = new Outer();
        inner1 = new Outer.Inner(outer1);	// 这里调用了嵌套类的一个带参构造器，实际上Inner类并没有这样的构造器
        inner2 = new Outer.Inner(outer2);	// 考虑是Outer类或者Outer$类的这段代码在反编译时出现了一些问题
		
		
		// println(inner1.getClass == inner2.getClass)
        Predef$.MODULE$;
        Class class1;
        Class class3 = inner1.getClass();
        class3;
        class3;
        class1 = inner2.getClass();
        JVM INSTR ifnonnull 64;
           goto _L1 _L2
_L1:
        JVM INSTR pop ;
        if(class1 == null) goto _L4; else goto _L3
_L2:
        class1;
        equals();
        JVM INSTR ifeq 76;
           goto _L4 _L3
_L4:
        true;
          goto _L5
_L3:
        false;
_L5:
        BoxesRunTime.boxToBoolean();
        println();
		
		
        Outer.StaticInner staticInner1;
        Outer.StaticInner staticInner2;
        staticInner1 = new Outer.StaticInner();
        staticInner2 = new Outer.StaticInner();
		
		
		// println(staticInner1.getClass == staticInner2.getClass)
        Predef$.MODULE$;
        Class class2;
        Class class4 = staticInner1.getClass();
        class4;
        class4;
        class2 = staticInner2.getClass();
        JVM INSTR ifnonnull 129;
           goto _L6 _L7
_L6:
        JVM INSTR pop ;
        if(class2 == null) goto _L9; else goto _L8
_L7:
        class2;
        equals();
        JVM INSTR ifeq 141;
           goto _L9 _L8
_L9:
        true;
          goto _L10
_L8:
        false;
_L10:
        BoxesRunTime.boxToBoolean();
        println();
    }
}
</pre>
<p>
	通过查看反编译的结果我们可以得出结论，Scala在编译嵌套类时所得出的字节码无法对应成某种特定模式Java代码，反编译工具无法理解这样的字节码导致了反编译结果出现一些错误的Java代码。
	Scala的非静态嵌套类与Java的相同，都带有一个外部对象的引用，这使得不同外部对象的非静态嵌套类对象在某种程度上存在着不同，它们却是从属于不同的外部类对象，
	但这并不能解释为什么在Scala中<code>outer1.Inner</code>和<code>outer2.Inner</code>是不同的类型，毕竟Scala运行上述代码结果显示<code>inner1.getClass</code>和<code>inner2.getClass</code>的结果相同，
	也就是说<code>inner1</code>和<code>inner2</code>都是<code>Outer.Inner</code>类。但确实如果我们将一个容器声明为<code>ArrayBuffer[outer1.Inner]</code>，<code>inner2</code>是无法被放入其中的。
	而这样的差别并不只局限于Scala容器，在Scala代码中声明类似<code>ArrayList</code>这样的Java容器会有相同的结果。
</p>
<p>
	那我们不妨继续试一下：
</p>
<pre class="brush: scala">
import java.util.ArrayList
import scala.collection.mutable.ArrayBuffer

class Outer {
	class Inner {}
}

object Outer {
	def main(args: Array[String]) {
		val outer1 = new Outer
		val outer2 = new Outer
		
		val jArr1 = new ArrayList[outer1.Inner]
		val jArr2 = new ArrayList[outer2.Inner]
		val sArr1 = new ArrayBuffer[outer1.Inner]
		val sArr2 = new ArrayBuffer[outer2.Inner]
		
		sArr1 += new outer1.Inner
		sArr2 += new outer2.Inner
		
		jArr1.add(new outer1.Inner)
		jArr2.add(new outer2.Inner)
	}
}
</pre>
<p><code>main</code>函数的反编译结果如下：</p>
<pre class="brush: java">
public void main(String args[]) {
    Outer outer1 = new Outer();
    Outer outer2 = new Outer();

    ArrayList jArr1 = new ArrayList();
    ArrayList jArr2 = new ArrayList();
    ArrayBuffer sArr1 = new ArrayBuffer();
    ArrayBuffer sArr2 = new ArrayBuffer();

	sArr1.$plus$eq(new Outer.Inner(outer1));
    sArr2.$plus$eq(new Outer.Inner(outer2));
    jArr1.add(new Outer.Inner(outer1));
    jArr2.add(new Outer.Inner(outer2));
}
</pre>
<p>
	这里我们就可以看到，声明在Scala源代码中的类型信息并不会被保留到字节码中。Scala这种行为实际上和Java是相同的，Java的类型参数同样不会被保留到字节码中，
	所有的容器在运行时所存储的元素都会被视为<code>Object</code>对象。如此可见，Scala有着与Java截然不同的类型系统，而该类型系统的林林总总是只存在于Scala的编译器中的，
	其中就包括了<code>outer1.Inner</code>和<code>outer2.Inner</code>的区别，也就是说这个类型区别仅存在于编译期。这一点上与Java的编译器相同，所有的类型检查都只会在编译时发生。
	在运行期，这两个对象都是属于<code>Outer.Inner</code>类的，这个从它们的<code>getClass</code>返回的运行时类结果相同即可看出。
</p>
<h2 class="jump">总结</h2>
<p>
	在本章中，我们学习了Scala类的基本定义方法，其中包括定义它们的字段、方法和构造器。除此之外，通过学习Scala嵌套类与Java的区别，我们也了解到了Scala有着和Java截然不同的类型系统，
	也算是见微知著吧~
</p>
<p>
	下一次，我们将进入《快学Scala》第六章的学习，开始研究Scala中的对象。
</p>
<hr />
<p>下一篇：<a href="{{ site.url }}{% post_url 2015-09-05-Scala-for-the-Impatient-6 %}">《快学Scala》第6章：对象</a></p>