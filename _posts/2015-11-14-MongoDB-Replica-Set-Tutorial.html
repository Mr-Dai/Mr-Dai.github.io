---
layout: posts
title: MongoDB Replica Set 部署教程
author: Robert Peng
category: MongoDB
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJScript.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushBash.js"></script>
<h2 class="jump">Replica Set 部署</h2>
<p>
	我们先从部署一个三节点的Replica Set开始。
</p>
<p class="center"><img src="https://docs.mongodb.org/manual/_images/replica-set-read-write-operations-primary.png" /></p>
<p>首先，我们要为每个<code>mongod</code>实例创建它自己的<code>dbpath</code>：</p>
<pre class="brush: bash">
mkdir 1
mkdir 2
mkdir 3
</pre>
<p>然后，我们便可以开始启动这三个<code>mongod</code>实例了：</p>
<pre class="brush: bash">
mongod --dbpath 1 --port 27001 --replSet myRS
mongod --dbpath 2 --port 27002 --replSet myRS
mongod --dbpath 3 --port 27003 --replSet myRS
</pre>
<p>
	注意，这里我是为了在同一台机器上运行三个<code>mongod</code>实例，所以需要为它们分别指定不同的端口。如果是真实的分布式Replica Set，
	在每台机器上使用默认的<code>27017</code>端口是完全可行的。
</p>
<p>
	除此之外，我使用<code>--replSet</code>参数指定了<code>mongod</code>实例所属Replica Set的名字。这个名字是可以随意起的，
	但必须确保属于同一个Replica Set的<code>mongod</code>实例设置了相同的<code>--replSet</code>，否则可能会产生一些不可预期的后果。
</p>
<p>
	在顺利打开这些<code>mongod</code>实例后以后，不出意外的话我们应该能在输出的日志信息中看到如下记录：
</p>
<pre>
2015-11-14T16:25:46.060+0800 I JOURNAL  [initandlisten] journal dir=3\journal
2015-11-14T16:25:46.061+0800 I JOURNAL  [initandlisten] recover : no journal files present, no recovery needed
2015-11-14T16:25:46.078+0800 I JOURNAL  [durability] Durability thread started
2015-11-14T16:25:46.078+0800 I JOURNAL  [journal writer] Journal writer thread started
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] MongoDB starting : pid=9812 port=27003 dbpath=3 64-bit host=mrdai-Laptop
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] targetMinOS: Windows 7/Windows Server 2008 R2
2015-11-14T16:25:46.613+0800 I CONTROL  [initandlisten] db version v3.0.7
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] git version: 6ce7cbe8c6b899552dadd907604559806aa2e9bd
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] build info: windows sys.getwindowsversion(major=6, minor=1, build=7601, platform=2, service_pack='Service Pack 1') BOOST_LIB_VERSION=1_49
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] allocator: tcmalloc
2015-11-14T16:25:46.614+0800 I CONTROL  [initandlisten] options: { net: { port: 27003 }, replication: { replSet: "myRS" }, storage: { dbPath: "3" } }
2015-11-14T16:25:46.615+0800 I INDEX    [initandlisten] allocating new ns file 3\local.ns, filling with zeroes...
2015-11-14T16:25:47.542+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.0, filling with zeroes...
2015-11-14T16:25:47.543+0800 I STORAGE  [FileAllocator] creating directory 3\_tmp
2015-11-14T16:25:47.544+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.0, size: 64MB,  took 0 secs
2015-11-14T16:25:47.551+0800 I REPL     [initandlisten] Did not find local replica set configuration document at startup;  NoMatchingDocument Did not find replica set configuration document in local.system.replset
2015-11-14T16:25:47.552+0800 I NETWORK  [initandlisten] waiting for connections on port 27003
</pre>
<p>
	可以注意到，倒数第二条记录显示<code>mongod</code>未能在本地数据中找到Replica Set的设置信息。这是正常的，因为这是第一次创建的Replica Set。
	最后一条信息显示<code>mongod</code>启动完毕，等待外界连接它的端口。
</p>
<p>
	那么，我们开始启动Replica Set。使用<code>mongo</code>连入随便一个<code>mongod</code>实例，并进行设置：
</p>
<pre class="brush: js">
var conf = {
  _id : "myRS",
  members : [
    { _id : 1, host : "localhost:27001" },
    { _id : 2, host : "localhost:27002" },
    { _id : 3, host : "localhost:27003" }
  ]
}

rs.initiate(conf)
</pre>
<p>
	在<code>conf</code>中，我们将<code>_id</code>设置为Replica Set的名称，并在<code>members</code>中设置了Replica Set所有成员的信息，其中包括成员的名称<code>_id</code>以及成员的主机名<code>host</code>。
</p>
<p class="bg-danger" style="padding-left: 3px">
	<b>注意</b>，尽管这里可以直接使用了<code>IP:端口</code>的形式来指定<code>mongod</code>实例，但在真实环境中，<b>不要</b>这么做，这种做法十分糟糕。
	不过现在搭建分布式，大家的做法似乎更倾向于为每台机器修改<code>hosts</code>文件。同样，<b>不要</b>这么做，这两种做法都属于bad practice。最好的做法，是在你的集群环境中配置一台DNS服务器。
	这样，当你的某一个结点的IP发生变化时，你就只需要修改DNS服务器中的那条解析条目，而不需要修改每个结点的<code>hosts</code>文件了。
</p>
<p class="bg-danger" style="padding-left: 3px">
	直接以数字作为每个结点的名称也是不好的做法，因为这个名称在<code>mongod</code>的日志信息中会经常出现。使用更加可读的名称是更好的做法。
</p>
<p>一切正常的话，你应该会在其中一个结点上看到如下日志信息：</p>
<pre>
2015-11-14T16:41:54.946+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61875 #1 (1 connection now open)
2015-11-14T16:41:54.951+0800 I NETWORK  [conn1] end connection 127.0.0.1:61875 (0 connections now open)
2015-11-14T16:41:54.953+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61877 #2 (1 connection now open)
2015-11-14T16:41:55.013+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61882 #3 (2 connections now open)
2015-11-14T16:41:55.018+0800 I NETWORK  [conn3] end connection 127.0.0.1:61882 (1 connection now open)
2015-11-14T16:41:55.078+0800 I REPL     [WriteReplSetConfig] Starting replication applier threads
2015-11-14T16:41:55.082+0800 I REPL     [ReplicationExecutor] New replica set config in use: { _id: "myRS", version: 1, members: [ { _id: 1, host: "localhost:27001", arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id: 2, host: "localhost:27002", arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 }, { _id:3, host: "localhost:27003", arbiterOnly: false, buildIndexes: true, hidden: false, priority: 1.0, tags: {}, slaveDelay: 0, votes: 1 } ], settings: { chainingAllowed: true, heartbeatTimeoutSecs: 10, getLastErrorModes: {}, getLastErrorDefaults: { w: 1, wtimeout: 0 } } }
2015-11-14T16:41:55.086+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:61884 #4 (2 connections now open)
2015-11-14T16:41:55.115+0800 I REPL     [ReplicationExecutor] This node is localhost:27003 in the config
2015-11-14T16:41:55.128+0800 I REPL     [ReplicationExecutor] transition to STARTUP2
2015-11-14T16:41:55.134+0800 I REPL     [rsSync] ******
2015-11-14T16:41:55.136+0800 I REPL     [rsSync] creating replication oplog of size: 6172MB...
2015-11-14T16:41:55.137+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.1, filling with zeroes...
2015-11-14T16:41:55.139+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state STARTUP2
2015-11-14T16:41:55.151+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.1, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:55.153+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.2, filling with zeroes...
2015-11-14T16:41:55.161+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.2, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:55.170+0800 I STORAGE  [FileAllocator] allocating new datafile 3\local.3, filling with zeroes...
2015-11-14T16:41:55.171+0800 I REPL     [ReplicationExecutor] Member localhost:27002 is now in state STARTUP2
2015-11-14T16:41:55.186+0800 I STORAGE  [FileAllocator] done allocating datafile 3\local.3, size: 2047MB,  took 0.001 secs
2015-11-14T16:41:56.198+0800 I REPL     [rsSync] ******
2015-11-14T16:41:56.198+0800 I REPL     [rsSync] initial sync pending
2015-11-14T16:41:56.200+0800 I REPL     [rsSync] no valid sync sources found in current replset to do an initial sync
2015-11-14T16:41:57.139+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state SECONDARY
2015-11-14T16:41:57.206+0800 I REPL     [rsSync] initial sync pending
2015-11-14T16:41:57.206+0800 I REPL     [ReplicationExecutor] syncing from: localhost:27001
2015-11-14T16:41:57.221+0800 I REPL     [rsSync] initial sync drop all databases
2015-11-14T16:41:57.222+0800 I STORAGE  [rsSync] dropAllDatabasesExceptLocal 1
2015-11-14T16:41:57.222+0800 I REPL     [rsSync] initial sync clone all databases
2015-11-14T16:41:57.229+0800 I REPL     [rsSync] initial sync data copy, starting syncup
2015-11-14T16:41:57.234+0800 I REPL     [rsSync] oplog sync 1 of 3
2015-11-14T16:41:57.239+0800 I REPL     [rsSync] oplog sync 2 of 3
2015-11-14T16:41:57.254+0800 I REPL     [rsSync] initial sync building indexes
2015-11-14T16:41:57.258+0800 I REPL     [rsSync] oplog sync 3 of 3
2015-11-14T16:41:57.265+0800 I REPL     [rsSync] initial sync finishing up
2015-11-14T16:41:57.268+0800 I REPL     [rsSync] replSet set minValid=5646f3d4:1
2015-11-14T16:41:57.274+0800 I REPL     [rsSync] initial sync done
2015-11-14T16:41:57.290+0800 I REPL     [ReplicationExecutor] transition to RECOVERING
2015-11-14T16:41:57.292+0800 I REPL     [ReplicationExecutor] transition to SECONDARY
2015-11-14T16:41:58.136+0800 I REPL     [ReplicationExecutor] could not find member to sync from
2015-11-14T16:41:58.971+0800 I REPL     [ReplicationExecutor] replSetElect voting yea for localhost:27001 (1)
2015-11-14T16:41:59.140+0800 I REPL     [ReplicationExecutor] Member localhost:27001 is now in state PRIMARY
2015-11-14T16:41:59.171+0800 I REPL     [ReplicationExecutor] Member localhost:27002 is now in state SECONDARY
</pre>
<p>
	从日志中，我们可以很清晰地看到，发起<code>rs.initiate</code>的<code>mongod</code>向其他<code>mongod</code>开启了连接，其他<code>mongod</code>获取到了我们配置的<code>conf</code>信息。
	而后，Replica Set开始启动。首先是各结点进行初始化同步，从发起<code>rs.initiate</code>的<code>mongod</code>处同步了oplog，并进入<code>Secondary</code>状态。然后，
	3个<code>Secondary</code>发现Replica Set中没有<code>Primary</code>，于是发起选举。日志里，我们甚至可以看到这个<code>mongod</code>把票投给了谁。最后，选举结束，<code>localhost:27001</code>成为了<code>Primary</code>。
</p>