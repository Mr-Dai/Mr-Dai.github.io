---
layout: posts
title: Scala 语言规范 - 第一章：语法
author: Robert Peng
category: Scala
---
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<div class="copyright">
  <p>本文由 <a href="http://mr-dai.github.io">Robert Peng</a> 翻译。未经许可，不得转载！</p>
  <p>原文出处： <a href="http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html" target="_blank">Scala Specification</a></p>
</div>
<p>
	Scala 程序由 Unicode 基本多文种平面（Basic Multilingual Plane, <a href="https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane" target="_blank">BMP</a>）字符集构成，
	暂不支持 Unicode 补充字符（Unicode supplementary character）。本章将描述 Scala 语法的两种模式：Scala 模式（Scala mode）和XML 模式（XML mode）。如无另外提及，
	下文中出现的 Scala 词法单元（token）均属 Scala 模式，字符<code>c</code>指代 Unicode 中的 ASCII 片段<code>\u0000</code>-<code>\u007F</code>。
</p>
<p>
	在 Scala 模式中，Unicode 转义（Unicode escape）将被替换为拥有给定十六进制码的 Unicode 字符。
</p>
<pre>
  UnicodeEscape ::= '\' 'u' {'u'} hexDigit hexDigit hexDigit hexDigit
  hexDigit      ::= '0' | … | '9' | 'A' | … | 'F' | 'a' | … | 'f'
</pre>
<p>
	为方便构造词法单元，字符将被分为如下几个类别（<a href="https://en.wikipedia.org/wiki/Unicode#Character_General_Category" target="_blank">Unicode general category</a>由括号给出）：
</p>
<ul>
  <li>空白字符：<code>\u0020 | \u0009 | \u000D | \u000A</code></li>
  <li>
    字母，包括小写字母（Ll）、大写字母（Lu）、首字母大写字母（titlecase letter, Lt）、其它字母（Lo）、数字字母（Nl）。
    除此之外还包括两个特殊的字符<code>\u0024 '$'</code>和<code>\u005F '_'</code>，
    这两个字符被视为大写字母
  </li>
  <li>数字：<code>'0' | … | '9'</code></li>
  <li>括号：<code>'(' | ')' | '[' | ']' | '{' | '}'</code></li>
  <li>分隔符：<code>'`' | ''' | '"' | '.' | ';' | ','</code></li>
  <li>运算符，包括不在上述几个类别中的所有可打印ASCII字符<code>\u0020</code> - <code>\u007F</code>、数学符号（Sm）和其他符号（So）</li>
</ul>
<hr />
<h2 class="jump" id="identifiers">1.1 标识符</h2>
<pre>
  op      ::= opchar {opchar}
  varid   ::= lower idrest
  plainid ::= upper idrest
            | varid
            | op
  id      ::= plainid
            | '`' stringLiteral '`'
  idrest  ::= {letter | digit} ['_' op]
</pre>
<p>
	标识符（identifier）包括三种形式。首先，一个标识符可以以一个字母开头，并跟上任意的字母和数字。
  接着，你还可以加上一个下划线<code>_</code>然后再加上由字母、数字或运算符字符组成的另一个字符串。
	其次，一个标识符可以以一个运算符字符开头，再跟上任意数量的运算符字符。
  上述两种形式的标识符称为<em>普通</em>标识符（<em>plain</em> identifier）。最后，标识符还可以由任意以反引号包围的字符串组成
	（用于运行程序的系统可能会对“合法标识符”添加一些额外的限制）。由此，标识符便由除反引号外的其他所有字符组成。
</p>
<p>
	按照惯例，我们同样使用最长匹配原则。比如，字符串
</p>
<p><code>big_bob++=`def`</code></p>
<p>
	将被拆分为三个标识符：<code>big_bob</code>、<code>++=</code>和<code>def</code>。
  在识别模式匹配语法时，我们还会把标识符分为以小写字母开头的变量标识符（variable identifier）和不以小写字母开头的常量标识符（constant identifier）。
</p>
<p>
	<code>$</code>则被保留为了编译器合成标识符（compiler-synthesized identifier）。用户程序不能定义包含<code>$</code>的标识符。
</p>
<p>
	下述命名均属于保留字（reserved word），无法被识别为标识符语法类（syntactic class）<code>id</code>（译者注：指上面那个上下文无关文法里的<code>id</code>）：
</p>
<pre>
  abstract    case        catch       class       def
  do          else        extends     false       final
  finally     for         forSome     if          implicit
  import      lazy        macro       match       new
  null        object      override    package     private
  protected   return      sealed      super       this
  throw       trait       try         true        type
  val         var         while       with        yield
  _    :    =    =>    &lt;-    &lt;:    &lt;%     >:    #    @
</pre>
<p>对应于 ASCII 中的<code>=></code>和<code>&lt;-</code>的 Unicode 字符<code>\u21D2 '⇒'</code>和<code>\u2190 '←'</code>同为保留字。
<blockquote>
<p>合法的标识符示例包括如下：</p>
<pre>
  x         Object        maxIndex   p2p      empty_?
  +         `yield`       αρετη     _y       dot_product_*
  __system  _MAX_LEN_
</pre>
</blockquote>
<blockquote>
  当需要使用被识别为 Scala 保留字的 Java 标识符时，可以使用反引号包围字符串。比如，语句<code>Thread.yeild()</code>是不合法的，因为<code>yield</code>是Scala中的一个保留字。
  将语句写为<code>Thread.`yield`()</code>即可。
</blockquote>
<hr />
<h2 class="jump" id="newline-characters">1.2 换行符</h2>
<pre>
  semi ::= ‘;’ |  nl {nl}
</pre>
<p>
  Scala 是面向行（line-oriented）的编程语言，语句需要以分号或换行符来标识结尾。Scala源代码文本中满足下列三个要求的换行符将被视为特殊词法单元“nl”：
</p>
<ul>
  <li>紧接着换行符的前一个词法单元可作为一个语句的结尾</li>
  <li>紧接着换行符的后一个词法单元可作为一个语句的开头</li>
  <li>该词法单元出现在换行可用的区域（region）</li>
</ul>
<p>可作为语句结尾的词法单元包括字面值（literal）、标识符以及如下的几个分隔符和保留字：</p>
<pre>
  this    null    true    false    return    type    &lt;xml-start>
  _       )       ]       }
</pre>
<p>除以下几个分隔符和保留字的所有Scala词法单元均可作为语句的开头：</p>
<pre>
  catch    else    extends    finally    forSome    match
  with    yield    ,    .    ;    :    =    =>    &lt;-    &lt;:    &lt;%
  >:    #    [    )    ]    }
</pre>
<p><code>case</code>单元当且仅当紧接着一个<code>class</code>单元或<code>object</code>单元时才可作为语句开头。
<p>换行可用的区域包括：</p>
<ul>
  <li>除换行不可用的嵌套区域外的 Scala 源代码文件中的任意位置</li>
  <li>除换行不可用的嵌套区域外的位于一对匹配的<code>{</code>和</code>}</code>单元间的任意位置</li>
</ul>
<p>在如下区域，换行不可用：</p>
<ul>
  <li>除换行可用的嵌套区域外的位于一对匹配的<code>(</code>和</code>)</code>单元间的任意位置</li>
  <li>除换行可用的嵌套区域外的位于一对匹配的<code>[</code>和</code>]</code>单元间的任意位置</li>
  <li>除换行可用的嵌套区域外的，位于<code>case</code>单元与其匹配的<code>=></code>单元间的任意位置</li>
  <li>使用<a href="#xml-mode">XML模式</a>识别的任意位置</li>
</ul>
<p>注意，括号包围的<code>{...}</code>XML 转义和字符串字面值不是词法单元，因此它们不包含换行可用的区域。</p>
<p>
	通常来讲，连续的两个位于不同行之中的非换行单元之间只会有一个<code>nl</code>单元，即使这两个单元之间隔了很多行。
	然而，如果两个单元被至少一个完全空白的行（不包含可打印字符的行）所分隔，它们之间会包含两个<code>nl</code>单元。
</p>
<p>
	Scala 的文法（在<a href="http://www.scala-lang.org/files/archive/spec/2.11/13-syntax-summary.html" target="_blank">这里</a>可以查看完整版）包含接受可选（optional）<code>nl</code>单元但不接受可选分号的产生式。
	由此，处于这些位置的换行便不会终结一个表达式或语句。这些位置可归纳如下。
</p>
<p>可接受多个换行符的位置包括如下：（注意，在这些位置放入分号是不允许的）</p>
<ul>
  <li>
    <a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#conditional-expressions" target="_blank">条件表达式</a>的条件之间或
    <a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#while-loop-expressions" target="_blank">while</a>循环与下一个表达式之间
  </li>
  <li>
	  <a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#for-comprehensions-and-for-loops" target="_blank">For推导式</a>的枚举符（Enumerator）
    与下一个表达式之间
  </li>
  <li>
    在<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#type-declarations-and-type-aliases" target="_blank">类型定义或声明</a>语句的起始<code>type</code>关键字之后
  </li>
</ul>
<p>可接受一个换行符的位置包括如下：</p>
<ul>
  <li>在前括号<code>{</code>之前，若该括号可作为当前语句或表达式的合法后缀</li>
  <li>
    在一个<a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#prefix,-infix,-and-postfix-operations" target="_blank">中缀运算符</a>之后，若下一行的第一个单元可作为一个表达式的起始符号
  </li>
  <li>
    在<a href="http://www.scala-lang.org/files/archive/spec/2.11/04-basic-declarations-and-definitions.html#function-declarations-and-definitions" target="_blank">函数声明</a>的参数列表之后
  </li>
  <li>在一个<a href="http://www.scala-lang.org/files/archive/spec/2.11/11-annotations.html#user-defined-annotations" target="_blank">注解</a>之后</li>
</ul>
<blockquote>
  <p>两行之间的换行符不会被视作语句分隔符：</p>
  <pre class="brush: scala">
if (x > 0)
  x = x - 1

while (x > 0)
  x = x / 2

for (x &lt;- 1 to 10)
  println(x)

type
  IntList = List[Int]
  </pre>
</blockquote>
<blockquote>
  <pre class="brush: scala">
new Iterator[Int]
{
  private var x = 0
  def hasNext = true
  def next = { x += 1; x }
}
  </pre>
  <p>如果加上一个换行符的话，同样的代码则会被视作是一个对象创建语句和一个局部代码块：</p>
  <pre class="brush: scala">
new Iterator[Int]

{
  private var x = 0
  def hasNext = true
  def next = { x += 1; x }
}
  </pre>
</blockquote>
<blockquote>
  <pre class="brush: scala">
x &lt; 0 ||
x &gt; 10
  </pre>
  <p>如果加上一个换行符的话，同样的代码则会被视作是两个表达式：</p>
  <pre class="brush: scala">
x &lt; 0 ||

x &gt; 10
  </pre>
</blockquote>
<blockquote>
  <pre class="brush: scala">
def func(x: Int)
        (y: Int) = x + y
  </pre>
  <p>如果加上一个换行符的话，同样的代码则会被视作是一个抽象函数声明和一个有语法错误的语句：</p>
  <pre class="brush: scala">
def func(x: Int)

        (y: Int) = x + y
  </pre>
</blockquote>
<blockquote>
  <pre class="brush: scala">
@serializable
protected class Data { ... }
  </pre>
  <p>如果加上一个换行符的话，同样的代码则会被视作是一个属性和一个有语法错误的分隔语句：</p>
  <pre class="brush: scala">
@serializable

protected class Data { ... }
  </pre>
</blockquote>
<hr />
<h2 class="jump" id="literals">1.3 字面值</h2>
<p>
  对于整型数、浮点数、字符、布尔变量、符号、字符串等，Scala 程序员可以直接在源代码中写下它们的字面值，语法上与它们在 Java 中的字面值语法相同。
</p>
<pre>
Literal  ::=  [‘-’] integerLiteral
           |  [‘-’] floatingPointLiteral
           |  booleanLiteral
           |  characterLiteral
           |  stringLiteral
           |  symbolLiteral
           |  ‘null’
</pre>
<h3 class="jump" id="integer-literals">1.3.1 整型字面值</h3>
<pre>
integerLiteral  ::=  (decimalNumeral | hexNumeral)
                       [‘L’ | ‘l’]
decimalNumeral  ::=  ‘0’ | nonZeroDigit {digit}
hexNumeral      ::=  ‘0’ (‘x’ | ‘X’) hexDigit {hexDigit}
digit           ::=  ‘0’ | nonZeroDigit
nonZeroDigit    ::=  ‘1’ | … | ‘9’
</pre>
<p>
  大多数情况下，整型字面值对应着<code>Int</code>类型，或在跟着<code>L</code>或<code>l</code>后缀时对应<code>Long</code>类型。
  <code>Int</code>类型变量的取值为 $[-2^{31},2^{31}-1]$ 之间的整数。
  而<code>Long</code>类型变量的取值则为 $[-2^{63},2^{63}-1]$ 之间的整数。
  整型字面值所代表的的数值超过这些范围将会导致编译错误。
</p>
<p>
  然而，如果某个字面值的期望类型 <i><a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#expression-typing" target="_blank">pt</a></i> 是<code>Byte</code>、
  <code>Short</code>或<code>Char</code>，且给定的字面值处于这些类型的取值范围中时，字面值所代表的的数字将会被转换至类型<i>pt</i>，同样字面值的类型也会变为<i>pt</i>。
  这些类型的取值范围如下：
</p>
<table class="table">
  <tr>
    <td><code>Byte</code></td>
    <td>$[-2^{7}, 2^{7}-1]$</td>
  </tr>
  <tr>
    <td><code>Short</code></td>
    <td>$[-2^{15}, 2^{15}-1]$</td>
  </tr>
  <tr>
    <td><code>Char</code></td>
    <td>$[0, 2^{16}-1]$</td>
  </tr>
</table>
<blockquote>
  <pre>0          21          0xFFFFFFFF       -42L</pre>
</blockquote>
<h3 class="jump" id="floating-point-literals">1.3.2 浮点型字面值</h3>
<pre>
floatingPointLiteral  ::=  digit {digit} ‘.’ digit {digit} [exponentPart] [floatType]
                        |  ‘.’ digit {digit} [exponentPart] [floatType]
                        |  digit {digit} exponentPart [floatType]
                        |  digit {digit} [exponentPart] floatType
exponentPart          ::=  (‘E’ | ‘e’) [‘+’ | ‘-’] digit {digit}
floatType             ::=  ‘F’ | ‘f’ | ‘D’ | ‘d’
</pre>
<p>
  大多数情况下，浮点字面值对应着<code>Double</code>类型，或在跟着<code>F</code>或<code>f</code>后缀时对应<code>Float</code>类型。
  <code>Float</code>类型包含所有 IEEE754 32位单精度二进制浮点型数，而<code>Double</code>类型则包含所有 IEEE754 64位双精度二进制浮点型数。
</p>
<p>
  如果在一个程序中，一个浮点型字面值紧跟着一个以字母开头的词法单元，两个单元必须被至少一个空白字符分隔。
</p>
<blockquote>
  <pre>0.0        1e30f      3.14159f      1.0e-100      .1</pre>
</blockquote>
<blockquote>
  <p>语句<code>1.toString</code>将被解析为三个不同的词法单元：整型字面值<code>1</code>，一个<code>.</code>和标识符<code>toString</code>。</p>
</blockquote>
<blockquote>
  <p><code>1.</code>并不是一个合法的浮点型字面值，因为在小数点后面必须跟着数字。</p>
</blockquote>
<h3 class="jump" id="boolean-literals">1.3.3 布尔字面值</h3>
<pre>
booleanLiteral  ::=  ‘true’ | ‘false’
</pre>
<p>布尔字面值<code>true</code>和<code>false</code>均属于<code>Boolean</code>类型。</p>
<h3 class="jump" id="character-literals">1.3.4 字符字面值</h3>
<pre>characterLiteral  ::=  ‘'’ (charNoQuoteOrNewline | UnicodeEscape | charEscapeSeq) ‘'’</pre>
<p>
  字符字面值表现为一个被单引号包围的单一字符。该字符可以是除下述字符外的任意单一 Unicode 字符：单引号、<code>\u000A</code>（LF）、<code>\u000D</code>（CR）。
  除此之外还可以是由指定 Unicode 转义符或者<a href="#escape-sequences">转义序列</a>所表示的 Unicode 字符。
</p>
<blockquote>
  <pre>'a'    '\u0041'    '\n'    '\t'</pre>
</blockquote>
<p>
  值得注意的是，虽然 Unicode 转换在语法解析较靠前的步骤中完成，因此源代码中的 Unicode 字符在大多数情况下和它们的转义展开式是等价的，字面值解析时编译器仍然接受任意的 Unicode 转义，
  包括字符字面值<code>'\u000A'</code>，也即<code>'\n'</code>。
</p>
<h3 class="jump" id="string-literals">1.3.5 字符串字面值</h3>
<pre>
stringLiteral  ::=  ‘"’ {stringElement} ‘"’
stringElement  ::=  charNoDoubleQuoteOrNewline | UnicodeEscape | charEscapeSeq
</pre>
<p>
  字符串字面值表现为被双引号包围的一串字符。这些字符可以是除下述字符外的任意 Unicode 字符：双引号、<code>\u000A</code>（LF）、<code>\u000D</code>（CR）。
  除此之外还可以是由指定 Unicode 转义符或者<a href="#escape-sequences">转义序列</a>所表示的 Unicode 字符。
</p>
<p>
  如果字符串字面值中包含双引号，它必须被写为转义字符<code>\"</code>。
</p>
<p>
  字符串字面值对应的值将会是类<code>String</code>的一个实例。
</p>
<blockquote>
  <pre>
"Hello, world!\n"
"\"Hello,\" replied the world."
  </pre>
</blockquote>
<h4 id="multi-line-string-literals">多行字符串字面值</h4>
<pre>
stringLiteral   ::=  ‘"""’ multiLineChars ‘"""’
multiLineChars  ::=  {[‘"’] [‘"’] charNoDoubleQuote} {‘"’}
</pre>
<p>
  多行字符串字面值表现为被三重双引号<code>""" ... """</code>包围的字符序列。该字符序列可以包含任意字符，除了三个或以上的连续的双引号。
  这些字符并不需要一定是可打印的：换行符或其他控制字符都是可以的。Unicode 转义同样可以在这里使用，但<a href="#escape-sequences">这里</a>给出的转义序列在这里则不会再被解析。
</p>
<blockquote>
<pre class="brush: scala">
"""the present string
   spans three
   lines."""
</pre>
<p>上述代码将产生字符串如下：</p>
<pre>
the present string
   spans three
   lines.
</pre>
<p>Scala 类库中提供了一个很有用的功能方法<code>stripMargin</code>，可被用于移除多行字符串中的空格前缀。表达式</p>
<pre class="brush: scala">
"""the present string
  |spans three
  |lines.""".stripMargin
</pre>
<p>将产生字符串</p>
<pre>
the present string
spans three
lines.
</pre>
<p>
  方法<code>stripMargin</code>被定义在类<code>scala.collection.immutable.StringLike</code>中。由于存在一个预先定义（predefined，暗指<code>Predef</code>类）的从<code>String</code>到<code>StringLike</code>的<a href="http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#implicit-conversions" target="_blank">隐式转换</a>，该方法可被用于任意字符串。
</p>
</blockquote>
<h3 class="jump" id="escape-sequences">1.3.6 转义序列</h3>
<p>
  如下的转义序列可被用于字符和字符串字面值中：
</p>
<table class="table">
  <tr>
    <th>转义序列</th>
    <th>Unicode</th>
    <th>名称</th>
    <th>字符</th>
  </tr>
  <tr>
    <td><code>‘\‘ ‘b‘</code></td>
    <td><code>\u0008</code></td>
    <td>退格（backspace）</td>
    <td><code>BS</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘t‘</code></td>
    <td><code>\u0009</code></td>
    <td>水平制表符（Horizontal Tab）</td>
    <td><code>HT</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘n‘</code></td>
    <td><code>\u000a</code></td>
    <td>换行符（Linefeed）</td>
    <td><code>LF</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘f‘</code></td>
    <td><code>\u000c</code></td>
    <td>换页符（Form Feed）</td>
    <td><code>FF</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘r‘</code></td>
    <td><code>\u000d</code></td>
    <td>回车（Carriage Return）</td>
    <td><code>CR</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘&quot;‘</code></td>
    <td><code>\u0022</code></td>
    <td>双引号</td>
    <td><code>&quot;</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘&#39;‘</code></td>
    <td><code>\u0027</code></td>
    <td>单引号</td>
    <td><code>&#39;</code></td>
  </tr>
  <tr>
    <td><code>‘\‘ ‘\‘</code></td>
    <td><code>\u005c</code></td>
    <td>反斜杠（Backslash）</td>
    <td><code>\</code></td>
  </tr>
</table>
<p>
  Unicode 值在 0 到 255 之间的字符同样可以表示为其对应的八进制转义序列，即反斜杠<code>\</code>加上最多3个八进制字符。
</p>
<p>
  如果一个出现在字符或字符串字面值中的反斜杠不能顺利引导一个合法的转义序列，将会出现编译期错误。
</p>
<h3 class="jump" id="symbol-literals">1.3.7 Symbol 字面值</h3>
<pre>symbolLiteral  ::=  ‘'’ plainid</pre>
<p>
  Symbol 字面值<code>'x</code>是表达式<code>scala.Symbol("x")</code>的简写。
  <code>Symbol</code>是一个<a href="http://www.scala-lang.org/files/archive/spec/2.11/05-classes-and-objects.html#case-classes" target="_blank">用例类</a>，其定义如下：
</p>
<pre class="brush: scala">
package scala
final case class Symbol private (name: String) {
  override def toString: String = "'" + name
}
</pre>
<p>
  <code>Symbol</code>类的伴生对象的<code>apply</code>方法会维持对所有<code>Symbol</code>实例的弱引用，由此确保相同的Symbol字面值将对应相同的<code>Symbol</code>对象引用。
</p>
<hr />
<h2 class="jump" id="whitespace-and-comments">1.4 空白字符和注释</h2>
<p>
  词法单元可被空白字符和注释分隔。注释有两种形式：
</p>
<p>单行注释是一串由<code>//</code>起始的字符序列，一直延伸到行末。</p>
<p>
  多行注释是一串由<code>/*</code>和<code>*/</code>包围的字符序列。多行注释可相互嵌套，但嵌套的多行注释也要保持合法的格式（<del>嵌套也要按照基本法</del>）。
  由此，像<code>/* /* */</code>这样的注释是会被拒绝的，因为里面有未终结的多行注释。
</p>
<hr />
<h2 class="jump" id="XML-mode">1.5 XML 模式</h2>
<p>
  为了允许在源代码中放入 XML 片段，词法分析器在下述情况下遇到开尖括号<code>'&lt;'</code>时会从 Scala 模式转入 XML 模式：该<code>'&lt;'</code>前面有空白字符、
  开括号<code>(</code>或开大括号<code>{</code>，同时紧跟着引导 XML 名的字符（a character strting an XML name）。
</p>
<pre>
( whitespace | ‘(’ | ‘{’ ) ‘<’ (XNameStart | ‘!’ | ‘?’)

XNameStart ::= ‘_’ | BaseChar | Ideographic // as in W3C XML, but without ‘:’
</pre>
<p>
  在以下情况下，词法单元扫描器（Scanner）将从 XML 模式转入 Scala 模式：
</p>
<ul>
  <li>由最初的<code>'&lt;'</code>引导的 XML 表达式或 XML 模式已被顺利解析，或者</li>
  <li>
    分析器（Parser）遇到了一个嵌套的 Scala 表达式或 Scala 模式，迫使扫描器（Sanner）回退到正常模式，直到顺利解析这个嵌套的 Scala 表达式或模式。
    在这种情况下，由于代码和 XML 片段可以相互嵌套，分析器（Parser）将会维持一个能够准确反映 XML 和 Scala 代码嵌套结构的栈。
  </li>
</ul>
<p>
  注意，在 XML 模式下，扫描器不会生成任何 Scala 词法单元，由此 Scala 注释也会被解释为一般的文本。
</p>
<blockquote>
  <p>如下值定义代码使用了一个带有两个嵌套 Scala 表达式的 XML 字面值：</p>
  <pre class="brush: scala">
val b = <book>
          <title>The Scala Language Specification</title>
          <version>{scalaBook.version}</version>
          <authors>{scalaBook.authors.mkList("", ", ", "")}</authors>
        </book>
  </pre>
</blockquote>