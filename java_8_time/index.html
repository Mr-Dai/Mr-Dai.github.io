<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java8 时间 API - Robert Peng&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="呆呆的博客"><meta name="msapplication-TileImage" content="/img/avatar.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="呆呆的博客"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java8 中最为人津津乐道的新改变恐怕当属函数式 API 的加入。但实际上，Java8 所加入的新功能远不止这个。本文将基于《Java SE8 for the Really Impatient》的第 5 章，归纳一下 Java8 加入的位于 java.time 包下的日期和时间 API。"><meta property="og:type" content="blog"><meta property="og:title" content="Java8 时间 API"><meta property="og:url" content="https://mr-dai.github.io/java_8_time/"><meta property="og:site_name" content="Robert Peng&#039;s Blog"><meta property="og:description" content="Java8 中最为人津津乐道的新改变恐怕当属函数式 API 的加入。但实际上，Java8 所加入的新功能远不止这个。本文将基于《Java SE8 for the Really Impatient》的第 5 章，归纳一下 Java8 加入的位于 java.time 包下的日期和时间 API。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://mr-dai.github.io/img/og_image.png"><meta property="article:published_time" content="2016-01-06T16:00:00.000Z"><meta property="article:modified_time" content="2016-01-06T16:00:00.000Z"><meta property="article:author" content="Robert Peng"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://mr-dai.github.io/java_8_time/"},"headline":"Java8 时间 API","image":["https://mr-dai.github.io/img/og_image.png"],"datePublished":"2016-01-06T16:00:00.000Z","dateModified":"2016-01-06T16:00:00.000Z","author":{"@type":"Person","name":"Robert Peng"},"publisher":{"@type":"Organization","name":"Robert Peng's Blog","logo":{"@type":"ImageObject","url":"https://mr-dai.github.io/img/avatar.png"}},"description":"Java8 中最为人津津乐道的新改变恐怕当属函数式 API 的加入。但实际上，Java8 所加入的新功能远不止这个。本文将基于《Java SE8 for the Really Impatient》的第 5 章，归纳一下 Java8 加入的位于 java.time 包下的日期和时间 API。"}</script><link rel="canonical" href="https://mr-dai.github.io/java_8_time/"><link rel="icon" href="/img/avatar.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2016-01-06T16:00:00.000Z" title="1/6/2016, 4:00:00 PM">2016-01-07</time>发表</span><span class="level-item"><time dateTime="2016-01-06T16:00:00.000Z" title="1/6/2016, 4:00:00 PM">2016-01-07</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/Java/">Java</a></span></div></div><h1 class="title is-3 is-size-4-mobile">Java8 时间 API</h1><div class="content"><p>Java8 中最为人津津乐道的新改变恐怕当属函数式 API 的加入。但实际上，Java8 所加入的新功能远不止这个。本文将基于《<a target="_blank" rel="noopener" href="http://t.cn/R4ZQRBh">Java SE8 for the Really Impatient</a>》的第 5 章，归纳一下 Java8 加入的位于 <code>java.time</code> 包下的日期和时间 API。</p>
<span id="more"></span>

<h2 id="时间点与时间间隔"><a href="#时间点与时间间隔" class="headerlink" title="时间点与时间间隔"></a>时间点与时间间隔</h2><p>在我们常说的四维空间体系中，时间轴往往作为除长宽高三轴以外的第四轴。时间轴由无穷多个时间点组成，而两个时间点之间的距离组成一个时间间隔。相较于我们常说的日期、时间，时间点本身所携带的信息是很少的，不会携带如时区等冗余的信息。作为时间轴上的一个点，我们可以将它称为绝对时间。</p>
<p>Java8 引入了 <code>Instant</code> 类（瞬时）来表示时间轴上的一个点。<code>Instant</code> 的构造方法是 <code>private</code> 的，我们只能通过调用它的静态工厂方法来产生一个 <code>Instant</code> 实例。其中最常用的是 <code>Instant.now()</code> 方法，返回当前的时间点。<code>Instant</code> 类也实现了 <code>comparesTo</code> 和 <code>equals</code> 方法来对比两个瞬时点。</p>
<p>通过调用 <code>Duration.between()</code> 方法我们便可以计算两个时间点之间的时间间隔：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Instant start = Instant.now();</span><br><span class="line"></span><br><span class="line">runAlgorithm();</span><br><span class="line"></span><br><span class="line">Instant end = Instant.now();</span><br><span class="line"></span><br><span class="line">Duration timeElapsed = Duration.between(start, end);</span><br><span class="line"><span class="keyword">long</span> millis = timeElapsed.toMillis();</span><br></pre></td></tr></table></figure>

<p><code>between</code> 方法返回一个 <code>Duration</code> 实例。<code>Duration</code> 内部以 <code>long</code> 成员来存储时间间隔信息，最小单位可去到纳秒，同时提供了如 <code>toMillis</code> 、 <code>toSeconds</code> 等方法。</p>
<p><code>Instant</code> 和 <code>Duration</code> 类常用的方法包括如下：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>plus</code>、<code>minus</code></td>
<td>对当前 <code>Instant</code> 或 <code>Duration</code> 增加或减少一段时间</td>
</tr>
<tr>
<td><code>plusNanos</code>、<code>plusMillis</code>、<code>plusSeconds</code>、<code>plusMinutes</code>、<code>plusHours</code>、<code>plusDays</code></td>
<td>根据指定的时间单位，对当前 <code>Instant</code> 或者 <code>Duration</code> 添加一段时间</td>
</tr>
<tr>
<td><code>minusNanos</code>、<code>minusMillis</code>、<code>minusSeconds</code>、<code>minusMinutes</code>、<code>minusHours</code>、<code>minusDays</code></td>
<td>根据指定的时间单位，对当前 <code>Instant</code> 或者 <code>Duration</code> 减少一段时间</td>
</tr>
<tr>
<td><code>multipliedBy</code>、<code>dividedBy</code>、<code>negated</code></td>
<td>返回当前 <code>Duration</code> 与指定 <code>long</code> 值相乘或相除得到的时间间隔</td>
</tr>
<tr>
<td><code>isZero</code>、<code>isNegative</code></td>
<td>检查 <code>Duration</code> 是否为 0 或负数</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：<code>Instant</code> 类和 <code>Duration</code> 类都是不可变的，上述方法都会返回一个新的实例。</p>
</blockquote>
<h2 id="本地日期"><a href="#本地日期" class="headerlink" title="本地日期"></a>本地日期</h2><p>在新的时间 API 中，Java 提供了两种时间格式：不带时区信息的本地时间和带时区的时间。本地日期表示一个日期，而本地时间还包含（一天中的）时间，但它们都不包含任何有关时区的信息。例如，June 14, 1903 就是一个本地日期。由于日期不含一天中的时间，也不含时区信息，所以它无法与一个准确的瞬时点对应。相反，July 16, 1969, 09:32:00 EDT 就是一个带时区的时间，它表示了时间轴上准确的一点。但有很多计算是不需要考虑时区的，在某些情况下考虑时区甚至可能导致错误的结果。出于此原因，API 设计者们更推荐使用不带时区的时间，除非你真的需要这个时区信息。</p>
<p><code>LocalDate</code> 就是一个不带时区的本地日期：它只带有年份、月份和当月的天数。你可以通过 <code>LocalDate</code> 的静态工厂方法 <code>now</code> 或 <code>of</code> 来创建一个实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalDate alonzosBirthday = LocalDate.of(<span class="number">1903</span>, <span class="number">6</span>, <span class="number">14</span>);</span><br><span class="line">alonzosBirthday = LocalDate.of(<span class="number">1903</span>, Month.JUNE, <span class="number">14</span>);</span><br></pre></td></tr></table></figure>

<p>这里我们看到，静态工厂方法中指示月份的数字是以 1 开始的，因此 6 就代表着六月。如果你实在是太喜欢以 0 开始，无法接受这种设定，你也可以使用枚举类型 <code>Month</code> 来指定月份。</p>
<p>下表中列出了 <code>LocalDate</code> 对象的一些常用方法。详细的方法说明请参考 <code>LocalDate</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDate.html">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>now</code>、<code>of</code></td>
<td>静态工厂方法，可以根据当前时间或指定的年月日来创建一个 <code>LocalDate</code> 对象</td>
</tr>
<tr>
<td><code>plusDays</code>、<code>plusWeeks</code>、<code>plusMonths</code>、<code>plusYears</code></td>
<td>返回在当前 <code>LocalDate</code> 的基础上加上几天、几周、几个月或者几年后的新的 <code>LocalDate</code> 对象，原有的 <code>LocalDate</code> 对象保持不变</td>
</tr>
<tr>
<td><code>minusDays</code>、<code>minusWeeks</code>、<code>minusMonths</code>、<code>minusYears</code></td>
<td>返回在当前 <code>LocalDate</code> 的基础上减去几天、几周、几个月或者几年后的新的 <code>LocalDate</code> 对象，原有的 <code>LocalDate</code> 对象保持不变</td>
</tr>
<tr>
<td><code>plus</code>、<code>minus</code></td>
<td>返回在当前 <code>LocalDate</code> 的基础上加上或减去一个 <code>Duration</code> 或者 <code>Period</code> 的新的 <code>LocalDate</code> 对象，原有的 <code>LocalDate</code> 对象保持不变</td>
</tr>
<tr>
<td><code>withDayOfMonth</code>、<code>withDayOfYear</code>、<code>withMonth</code>、<code>withYear</code></td>
<td>返回一个月份天数、年份天数、月份、年份修改为指定的值的新的 <code>LocalDate</code> 对象，原有的 <code>LocalDate</code> 对象保持不变</td>
</tr>
<tr>
<td><code>getDayOfMonth</code></td>
<td>获取月份天数（在 $[1,31]$ 之间）</td>
</tr>
<tr>
<td><code>getDayOfYear</code></td>
<td>获取年份天数（在 $[1,366]$ 之间）</td>
</tr>
<tr>
<td><code>getDayOfWeek</code></td>
<td>获取星期几（返回一个 <code>DayOfWeek</code> 枚举值）</td>
</tr>
<tr>
<td><code>getMonth</code>、<code>getMonthValue</code></td>
<td>获取月份，返回一个 <code>Month</code> 枚举的值，或者是 $[1,12]$ 之间的一个数字</td>
</tr>
<tr>
<td><code>getYear</code></td>
<td>获取年份，在 $[-999999999,999999999]$ 之间</td>
</tr>
<tr>
<td><code>until</code></td>
<td>获取两个日期之间的 <code>Period</code> 对象，或者以指定 <code>ChronoUnits</code> 为单位的数值</td>
</tr>
<tr>
<td><code>isBefore</code>、<code>isAfter</code></td>
<td>比较两个 <code>LocalDate</code></td>
</tr>
<tr>
<td><code>isLeapYear</code></td>
<td>是否为闰年</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：<code>LocalDate</code> 类是不可变的，上述方法都会返回一个新的实例。</p>
</blockquote>
<p>在上一节中我们提到，两个瞬时点 <code>Instant</code> 之间的是一个持续时间 <code>Duration</code>。对于本地时间，对应的对象就是时段 <code>Period</code>，它表示一段逝去的年月日。</p>
<h2 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h2><p><code>LocalTime</code> 代表一天中的某个时间，例如下午 3 点 30 分。同样，你可以通过 <code>LocalTime</code> 的静态工厂方法 <code>now</code> 和 <code>of</code> 来创建一个实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LocalTime rightNow = LocalTime.now();</span><br><span class="line">LocalTime bedtime= LocalTime.of(<span class="number">22</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<p>下表中列出了 <code>LocalTime</code> 对象的一些常用方法。详细的方法说明请参考 <code>LocalTime</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalTime.html">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>now</code>、<code>of</code></td>
<td>静态工厂方法，可以根据当前时间或指定的时分秒来创建一个 <code>LocalTime</code> 对象</td>
</tr>
<tr>
<td><code>plusHours</code>、<code>plusMinutes</code>、<code>plusSeconds</code>、<code>plusNanos</code></td>
<td>返回在当前 <code>LocalTime</code> 的基础上加上几小时、几分钟、几秒或者几纳秒后的新的 <code>LocalTime</code> 对象，原有的 <code>LocalTime</code> 对象保持不变</td>
</tr>
<tr>
<td><code>minusHours</code>、<code>minusMinutes</code>、<code>minusSeconds</code>、<code>minusNanos</code></td>
<td>返回在当前 <code>LocalTime</code> 的基础上减去几小时、几分钟、几秒或者几纳秒后的新的 <code>LocalTime</code> 对象，原有的 <code>LocalTime</code> 对象保持不变</td>
</tr>
<tr>
<td><code>plus</code>、<code>minus</code></td>
<td>返回在当前 <code>LocalTime</code> 的基础上加上或减去一个 <code>Duration</code> 的新的 <code>LocalTime</code> 对象，原有的 <code>LocalTime</code> 对象保持不变</td>
</tr>
<tr>
<td><code>withHour</code>、<code>withMinute</code>、<code>withSecond</code>、<code>withNano</code></td>
<td>返回一个小时数、分钟数、秒数、纳秒数修改为指定的值的新的 <code>LocalTime</code> 对象，原有的 <code>LocalTime</code> 对象保持不变</td>
</tr>
<tr>
<td><code>getHour</code>、<code>getMinute</code>、<code>getSecond</code>、<code>getNano</code></td>
<td>返回该 <code>LocalTime</code> 的小时、分钟、秒钟及纳秒值</td>
</tr>
<tr>
<td><code>isBefore</code> 、 <code>isAfter</code></td>
<td>比较两个 <code>LocalTime</code></td>
</tr>
</tbody></table>
<blockquote>
<p> <strong>注意</strong>：<code>LocalTime</code> 类是不可变的，上述方法都会返回一个新的实例。</p>
</blockquote>
<p><code>LocalDateTime</code> 类则可看作是 <code>LocalDate</code> 和 <code>LocalTime</code> 的结合。它用于存储本地时区中的某个时间点，包含当前的年月日等日期信息，同时也包含了时钟、分钟、秒钟等时间信息。同样，<code>LocalDateTime</code> 也是不可变的。</p>
<p>详细的方法说明请参考 <code>LocalDateTime</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/LocalDateTime.html">JavaDoc</a>。</p>
<h2 id="带时区的时间"><a href="#带时区的时间" class="headerlink" title="带时区的时间"></a>带时区的时间</h2><p>Java8 的时间 API 当然也加入了对时区的支持。分别对应着 <code>LocalDate</code>、<code>LocalTime</code> 和 <code>LocalDateTime</code>，带时区的时间类为 <code>ZonedDate</code>、<code>ZonedTime</code>、<code>ZonedDateTime</code>。</p>
<p>Java 中的时区信息来自于 IANA（Internet Assigned Numbers Authority）的数据库，其中每个时区都有着对应的 ID，例如 <code>America/New_York</code> 或者 <code>Europe/Berlin</code>。调用 <code>ZoneId.getAvailableIds</code> 方法即可获取所有可用的时区信息。</p>
<p>你还可以使用 <code>ZoneId.of(id)</code> 方法，用指定的时区 ID 来获取对应的 <code>ZoneId</code> 对象。通过调用 <code>local.atZone(zoneId)</code> 方法，你可以将一个 <code>LocalDateTime</code> 转换成一个 <code>ZonedDateTime</code> 对象，或者通过调用静态方法 <code>ZonedDateTime.of</code> 来创建一个对象。</p>
<p><code>ZonedDateTime</code> 的许多方法都与 <code>LocalDateTime</code> 一致。下表中列出了 <code>ZonedDateTime</code> 特有的常用方法，详细的方法说明请参考 <code>ZonedDateTime</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/ZonedDateTime.html">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>now</code>、<code>of</code>、<code>ofInstant</code></td>
<td>根据当前时间或指定的年月日时分秒、纳秒和 <code>ZoneId</code>，或者一个 <code>Instant</code> 和一个 <code>ZoneId</code> 来创建一个 <code>ZonedDateTime</code> 对象</td>
</tr>
<tr>
<td><code>withZoneSameInstant</code>、<code>withZoneSameLocal</code></td>
<td>返回时区失去中的一个新的 <code>ZonedDateTime</code> 对象，它表示相同的瞬时点或本地时间</td>
</tr>
<tr>
<td><code>getOffset</code></td>
<td>获得与 UTC 之间的时差，返回一个 <code>ZoneOffset</code> 对象</td>
</tr>
<tr>
<td><code>toLocalDate</code>、<code>toLocalTime</code>、<code>toInstant</code></td>
<td>返回对应的本地日期、本地时间或瞬时点</td>
</tr>
</tbody></table>
<p>除此之外，Java8 还提供了一个 <code>OffsetDateTime</code> 类，用来表示带有（与 UTC 相比的）偏移量的时间。这个类专门用于一些不需要时区规则的业务场景，比如某些网络协议。对于人类可读的时间，<code>ZonedDateTime</code> 是更好的选择。</p>
<p>详情请查阅 <code>OffsetDateTime</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/OffsetDateTime.html">JavaDoc</a>。</p>
<h2 id="日期校正器"><a href="#日期校正器" class="headerlink" title="日期校正器"></a>日期校正器</h2><p>有些时候，我们可以能需要得到类似“每月的第一个星期二”这样的日期。Java8 提供了 <code>TemporalAdjuster</code> 接口，用以实现自定义的日期校正逻辑。通过将创建好的 <code>TemporalAdjuster</code> 传递给日期时间类的 <code>with</code> 方法便可在原有日期时间对象的基础上产生出一个符合要求的日期时间。例如，你可以通过如下代码来计算下一个星期二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TemporalAdjuster NEXT_TUESDAY = (Temporal temporal) -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> dowValue = DayOfWeek.TUESDAY.getValue();</span><br><span class="line">    <span class="keyword">int</span> calDow = temporal.get(ChronoField.DAY_OF_WEEK);</span><br><span class="line">    <span class="keyword">if</span> (calDow == dowValue) &#123;</span><br><span class="line">        <span class="keyword">return</span> temporal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> daysDiff = calDow - dowValue;</span><br><span class="line">    <span class="keyword">return</span> temporal.plus(daysDiff &gt;= <span class="number">0</span> ? <span class="number">7</span> - daysDiff : -daysDiff, DAYS);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LocalDate nextTuesDay = today.with(NEXT_TUESDAY);</span><br></pre></td></tr></table></figure>

<p>此处利用 Lambda 表达式快速实现了一个匿名的 <code>TemporalAdjuster</code> 对象。注意 Lambda 表达式的参数类型为 <code>Temporal</code>，某些 <code>LocalDate</code> 或者 <code>LocalDateTime</code> 之类的类特有的方法将不可用，在使用前必须进行强制转换。你可以通过 <code>ofDateAdjuster</code> 方法和一个 <code>UnaryOperator&lt;LocalDate&gt;</code> 来避免强制转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">TermporalAdjuster NEXT_WORKDAY = TemporalAdjusters.ofDateAdjuster((LocalDate w) -&gt; &#123;</span><br><span class="line">	LocalDate result;</span><br><span class="line">	DayOfWeek dow = w.getDayOfWeek();</span><br><span class="line">	<span class="keyword">if</span> (dow == DayOfWeek.FRIDAY)</span><br><span class="line">		result = w.plusDays(<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (dow == DayOfWeek.SATURDAY)</span><br><span class="line">		result = w.plusDays(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		result = w.plusDays(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上述代码中使用的 <code>ofDateAdjuster</code> 方法来自类 <code>TemporalAdjusters</code>。实际上这个类通过静态方法提供了大量的常用 <code>TemporalAdjuster</code> 实现。比如，我们也可以通过如下代码来计算下一个星期二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LocalDate nextTuesDay = LocalDate.now().with(</span><br><span class="line">  TemporalAdjusters.nextOrSame(DayOfWeek.TUESDAY)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>下表中列出了 <code>TemporalAdjusters</code> 的一些常用方法。详细的方法说明请参考 <code>TemporalAdjusters</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/temporal/TemporalAdjusters.html">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>previous(dayOfWeek)</code>、<code>next(dayOfWeek)</code></td>
<td>返回被校正日期之后或之前最近的指定星期几</td>
</tr>
<tr>
<td><code>previoursOrSame(dayOfWeek)</code>、<code>nextOrSame(dayOfWeek)</code></td>
<td>返回从被校正日期开始，之前或之后的指定星期几。如果被校正日期已吻合条件，被校正的日期实例将被直接返回</td>
</tr>
<tr>
<td><code>dayOfWeekInMonth(n, dayOfWeek)</code></td>
<td>返回该月中指定的第几个星期几</td>
</tr>
<tr>
<td><code>firstInMonth(dayOfWeek)</code>、<code>lastInMonth(dayOfWeek)</code></td>
<td>返回该月第一个或最后一个星期几</td>
</tr>
<tr>
<td><code>firstDayOfMonth()</code>、<code>firstDayOfNextMonth()</code>、<code>firstDayOfNextYear()</code>、<code>lastDayOfMonth()</code>、<code>lastDayOfPreviousMonth()</code>、<code>lastDayOfYear()</code></td>
<td>返回方法名所描述的日期</td>
</tr>
</tbody></table>
<h2 id="格式化和解析"><a href="#格式化和解析" class="headerlink" title="格式化和解析"></a>格式化和解析</h2><p>除了日期校正，日期与字符串之间的相互转换也是十分常见的操作。对于原有的 <code>java.util.Date</code> 等类，我们使用 <code>java.text.DateFormat</code> 来对日期进行格式化和解析。对于 Java8 新引入的日期时间类，我们使用 <code>java.time.format.DateTimeFormatter</code> 类。</p>
<p><code>DateTimeFormatter</code> 类提供了三种格式化方法来打印日期时间：</p>
<ul>
<li>预定义的标准格式</li>
<li>语言环境相关的格式</li>
<li>自定义的格式</li>
</ul>
<p>下表中列出了所有预定义的 <code>DateTimeFormatter</code>。详细说明可参考 <code>DateTimeFormatter</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#predefined">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>BASIC_ISO_DATE</code></td>
<td><code>20111203</code></td>
</tr>
<tr>
<td><code>ISO_LOCAL_DATE</code><br/><code>ISO_LOCAL_TIME</code><br/><code>ISO_LOCAL_DATE_TIME</code></td>
<td><code>2011-12-03</code><br/><code>10:15:30</code><br/><code>2011-12-03T10:15:30</code></td>
</tr>
<tr>
<td><code>ISO_OFFSET_DATE</code><br/><code>ISO_OFFSET_TIME</code><br/><code>ISO_OFFSET_DATE_TIME</code></td>
<td><code>2011-12-03+01:00</code><br/><code>10:15:30+01:00</code><br/><code>2011-12-03T10:15:30+01:00</code></td>
</tr>
<tr>
<td><code>ISO_ZONED_DATE_TIME</code></td>
<td><code>2011-12-03T10:15:30+01:00[Europe/Paris]</code></td>
</tr>
<tr>
<td><code>ISO_INSTANT</code></td>
<td><code>2011-12-03T10:15:30Z</code></td>
</tr>
<tr>
<td><code>ISO_ORDINAL_DATE</code></td>
<td><code>2012-337</code></td>
</tr>
<tr>
<td><code>ISO_WEEK_DATE</code></td>
<td><code>2012-W48-6</code></td>
</tr>
<tr>
<td><code>ISO_DATE</code><br /><code>ISO_TIME</code><br /><code>ISO_DATE_TIME</code></td>
<td><code>2011-12-03+01:00</code>; <code>2011-12-03</code><br /><code>10:15:30+01:00</code>; <code>10:15:30</code><br /><code>2011-12-03T10:15:30+01:00[Europe/Paris]</code></td>
</tr>
<tr>
<td><code>RFC_1123_DATE_TIME</code></td>
<td><code>Tue, 3 Jun 2008 11:05:30 GMT</code></td>
</tr>
</tbody></table>
<p>通过调用 <code>DateTimeFormatter</code> 类的 <code>format</code> 方法即可对日期进行格式化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String formatted = DateTimeFormatter.ISO_DATE_TIME.format(apollolllaunch);</span><br><span class="line">  <span class="comment">// 1969-07-16T09:32:00-0500[America/New_York]</span></span><br></pre></td></tr></table></figure>

<p>标准格式主要用于机器可读的时间戳。为了产生人类可读的日期和时间，你需要使用语言环境相关的格式。下表中列出了 Java8 提供的 4 种风格：</p>
<table>
<thead>
<tr>
<th>风格</th>
<th>日期</th>
<th>时间</th>
</tr>
</thead>
<tbody><tr>
<td><code>SHORT</code></td>
<td><code>7/16/69</code></td>
<td><code>9:32 AM</code></td>
</tr>
<tr>
<td><code>MEDIUM</code></td>
<td><code>Jul 16, 1969</code></td>
<td><code>9:32:00 AM</code></td>
</tr>
<tr>
<td><code>LONG</code></td>
<td><code>July 16, 1969</code></td>
<td><code>9:32:00 AM EDT</code></td>
</tr>
<tr>
<td><code>FULL</code></td>
<td><code>Wednesday, July 16, 1969</code></td>
<td><code>9:32:00 AM EDT</code></td>
</tr>
</tbody></table>
<p>你可以通过静态方法 <code>ofLocalizedDate</code> 、 <code>ofLocalizedTime</code> 和 <code>ofLocalizedDateTime</code> 来创建这些格式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line"></span><br><span class="line">String formatted = formatter.format(apollolllaunch);</span><br><span class="line">    <span class="comment">// July 16, 1969 9:32:00 AM EDT</span></span><br></pre></td></tr></table></figure>

<p>这些方法使用的都是默认的语言环境。通过使用 <code>withLocale</code> 方法可以更改为其他语言环境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String formatted = formatter.withLocale(Locale.FRENCH).format(apollolllaunch);</span><br><span class="line">    <span class="comment">// 16 juillet 1969 09:32:00 EDT</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用 <code>formatter.toFormat()</code> 方法来获取一个等效的 <code>java.util.DateFormat</code> 对象。</p>
<p>最后，你可以通过指定的模式来自定义日期的格式。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;E yyyy-MM-dd HH:mm&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>其中不同的符号对应着不同的含义。下表中列出了不同符号的具体含义和实例，详情可查阅 <code>DateTimeFormatter</code> 的 <a target="_blank" rel="noopener" href="http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#patterns">JavaDoc</a>。</p>
<table>
<thead>
<tr>
<th>含义</th>
<th>符号</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>纪元</td>
<td><code>G</code><br/><code>GGGG</code><br /> <code>GGGGG</code></td>
<td><code>AD</code><br /><code>Anno Domini</code><br /><code>A</code></td>
</tr>
<tr>
<td>年份</td>
<td><code>yy</code><br /><code>yyyy</code></td>
<td><code>69</code><br /><code>1969</code></td>
</tr>
<tr>
<td>月份</td>
<td><code>M</code><br /><code>MM</code><br /><code>MMM</code><br /><code>MMMM</code><br /><code>MMMMM</code><br /></td>
<td><code>7</code><br /><code>07</code><br /><code>Jul</code><br /><code>July</code><br /><code>J</code></td>
</tr>
<tr>
<td>日份</td>
<td><code>d</code><br /><code>dd</code></td>
<td><code>6</code><br /><code>06</code></td>
</tr>
<tr>
<td>星期几</td>
<td><code>e</code><br /><code>E</code><br /><code>EEEE</code><br /><code>EEEEE</code></td>
<td><code>3</code><br /><code>Wed</code><br /><code>Wednesday</code><br /><code>W</code></td>
</tr>
<tr>
<td>24 小时制时钟（$[0,23]$）</td>
<td><code>H</code><br /><code>HH</code></td>
<td><code>9</code><br /><code>09</code></td>
</tr>
<tr>
<td>12 小时制时钟（$[0,11]$）</td>
<td><code>K</code><br /><code>KK</code></td>
<td><code>9</code><br /><code>09</code></td>
</tr>
<tr>
<td>AM/PM</td>
<td><code>a</code></td>
<td><code>AM</code></td>
</tr>
<tr>
<td>分钟</td>
<td><code>mm</code></td>
<td><code>02</code></td>
</tr>
<tr>
<td>秒钟</td>
<td><code>ss</code></td>
<td><code>00</code></td>
</tr>
<tr>
<td>时区 ID</td>
<td><code>VV</code></td>
<td><code>America/New_York</code></td>
</tr>
<tr>
<td>时区名称</td>
<td><code>z</code><br /><code>zzzz</code><br /></td>
<td><code>EDT</code><br /><code>Eastern Daylight Time</code></td>
</tr>
<tr>
<td>时差</td>
<td><code>x</code><br /><code>xx</code><br /><code>xxx</code><br /><code>XXX</code></td>
<td><code>-04</code><br /><code>-0400</code><br /><code>-04:00</code><br /><code>-Z4:ZZ</code></td>
</tr>
<tr>
<td>本地化的时差</td>
<td><code>O</code><br /><code>OOOO</code></td>
<td><code>GMT-4</code><br /><code>GMT-04:00</code></td>
</tr>
</tbody></table>
<p>要从一个字符串中解析出日期时间，可以使用静态方法 <code>parse</code> 的各个重载方法。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDate churchsBirthday = LocalDate.parse(<span class="string">&quot;1903-06-14&quot;</span>);</span><br><span class="line">ZonedDateTime apollolllaunch =</span><br><span class="line">    ZonedDateTime.parse(<span class="string">&quot;1969-07-16 03:32:00-0400&quot;</span>,</span><br><span class="line">                        DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ssxx&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="与遗留代码互操作"><a href="#与遗留代码互操作" class="headerlink" title="与遗留代码互操作"></a>与遗留代码互操作</h2><p>尽管使用全新的 API 可以获得更好的开发体验，但兼容遗留代码总是不可避免的。因此，熟知新的日期时间类和旧的日期时间类之间的转换方法也是我们必须学习的。</p>
<p>总体来讲，转换规则可以归纳为下表：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>To 遗留类</th>
<th>From 遗留类</th>
</tr>
</thead>
<tbody><tr>
<td><code>java.time.Instant</code><br /><code>java.util.Date</code></td>
<td><code>Date.from(instant)</code></td>
<td><code>date.toInstant()</code></td>
</tr>
<tr>
<td><code>java.time.Instant</code><br /><code>java.sql.Timestamp</code></td>
<td><code>Timestamp.from(instant)</code></td>
<td><code>timestamp.toInstant()</code></td>
</tr>
<tr>
<td><code>java.time.Instant</code><br /><code>java.nio.file.attribute.FileTime</code></td>
<td><code>FileTime.from(instant)</code></td>
<td><code>fileTime.toInstant()</code></td>
</tr>
<tr>
<td><code>java.time.ZonedDateTime</code><br /><code>java.util.GregorianCalendar</code></td>
<td><code>GregorianCalendar.from(zonedDateTime)</code></td>
<td><code>cal.toZonedDateTime()</code></td>
</tr>
<tr>
<td><code>java.time.LocalDate</code><br /><code>java.sql.Time</code></td>
<td><code>Date.valueOf(localDate)</code></td>
<td><code>date.toLocalDate()</code></td>
</tr>
<tr>
<td><code>java.time.LocalTime</code><br /><code>java.sql.Time</code></td>
<td><code>Date.valueOf(localDate)</code></td>
<td><code>date.toLocalTime()</code></td>
</tr>
<tr>
<td><code>java.time.LocalDateTime</code><br /><code>java.sql.Timestamp</code></td>
<td><code>Timestamp.valueOf(localDateTime)</code></td>
<td><code>timestamp.toLocalDateTime()</code></td>
</tr>
<tr>
<td><code>java.time.ZoneId</code><br /><code>java.util.TimeZone</code></td>
<td><code>Timezone.getTimeZone(id)</code></td>
<td><code>timeZone.toZoneId()</code></td>
</tr>
<tr>
<td><code>java.time.format.DateTimeFormatter</code><br /><code>java.text.DateFormat</code></td>
<td><code>formatter.toFormat()</code></td>
<td>无</td>
</tr>
</tbody></table>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java8 时间 API</p><p><a href="https://mr-dai.github.io/java_8_time/">https://mr-dai.github.io/java_8_time/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Robert Peng</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2016-01-07</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2016-01-07</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/img/alipay-qrcode.png" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/img/wechat-qrcode.png" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/java_string_formatting/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Java String Formatting</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/mongodb_distribution_tutorial/"><span class="level-item">MongoDB 分布式部署教程</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script>var disqus_config = function () {
            this.page.url = 'https://mr-dai.github.io/java_8_time/';
            this.page.identifier = 'java_8_time/';
        };
        (function() {
            var d = document, s = d.createElement('script');  
            s.src = '//' + 'robertpsblog' + '.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="呆呆"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">呆呆</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>中国广州</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">49</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">35</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://www.zhihu.com/people/robert.peng" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="知乎" href="https://www.zhihu.com/people/robert.peng"><i class="fab fa-zhihu"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Bash/"><span class="tag">Bash</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bigtable/"><span class="tag">Bigtable</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GC/"><span class="tag">GC</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Git/"><span class="tag">Git</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Go/"><span class="tag">Go</span><span class="tag">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Gradle/"><span class="tag">Gradle</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Groovy/"><span class="tag">Groovy</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/HBase/"><span class="tag">HBase</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hadoop/"><span class="tag">Hadoop</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hive-ThriftServer/"><span class="tag">Hive ThriftServer</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/JVM/"><span class="tag">JVM</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MIT-6-824/"><span class="tag">MIT 6.824</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mesos/"><span class="tag">Mesos</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Paxos/"><span class="tag">Paxos</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Python/"><span class="tag">Python</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Raft/"><span class="tag">Raft</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SQL/"><span class="tag">SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark/"><span class="tag">Spark</span><span class="tag">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spark-SQL/"><span class="tag">Spark SQL</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SparkSQL/"><span class="tag">SparkSQL</span><span class="tag">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Windows/"><span class="tag">Windows</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Yarn/"><span class="tag">Yarn</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ZooKeeper/"><span class="tag">ZooKeeper</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/etcd/"><span class="tag">etcd</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%87%E4%BB%BD/"><span class="tag">主从备份</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86/"><span class="tag">分布式共识</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%86%85%E5%AD%98/"><span class="tag">分布式内存</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%98%E5%82%A8/"><span class="tag">分布式存储</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"><span class="tag">分布式系统</span><span class="tag">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97/"><span class="tag">分布式计算</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C/"><span class="tag">团队协作</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6/"><span class="tag">集群资源调度</span><span class="tag">2</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#时间点与时间间隔"><span class="level-left"><span class="level-item">1</span><span class="level-item">时间点与时间间隔</span></span></a></li><li><a class="level is-mobile" href="#本地日期"><span class="level-left"><span class="level-item">2</span><span class="level-item">本地日期</span></span></a></li><li><a class="level is-mobile" href="#本地时间"><span class="level-left"><span class="level-item">3</span><span class="level-item">本地时间</span></span></a></li><li><a class="level is-mobile" href="#带时区的时间"><span class="level-left"><span class="level-item">4</span><span class="level-item">带时区的时间</span></span></a></li><li><a class="level is-mobile" href="#日期校正器"><span class="level-left"><span class="level-item">5</span><span class="level-item">日期校正器</span></span></a></li><li><a class="level is-mobile" href="#格式化和解析"><span class="level-left"><span class="level-item">6</span><span class="level-item">格式化和解析</span></span></a></li><li><a class="level is-mobile" href="#与遗留代码互操作"><span class="level-left"><span class="level-item">7</span><span class="level-item">与遗留代码互操作</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/avatar.png" alt="Robert Peng&#039;s Blog" height="28"></a><p class="is-size-7"><span>&copy; 2021 Robert Peng</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="我的 Github" href="https://github.com/Mr-Dai"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>