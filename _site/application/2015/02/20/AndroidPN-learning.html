<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/default.css" rel="stylesheet">
	<link href="/css/post.css" rel="stylesheet">
    <script type="text/javascript" src="/js/jquery-2.1.1.min.js"></script>
    
    <script type="text/javascript" src="/js/syntaxhighlighters/shCore.js"></script>
    <link href="/css/syntaxhighlighters/shCore.css" rel="stylesheet" type="text/css" />
    <link href="/css/syntaxhighlighters/shThemeDefault.css" rel="stylesheet" type="text/css" />
    
    <title>AndroidPN源码分析(未完成) - Mr.Dai</title>
</head>
<body>
    <div id="main_wrapper">
    <div id="banner_wrapper">
    <h1 style="padding-bottom:0">Robert P.'s Blog</h1>
	<p style="margin-top:8px; color: #999999; font-size: 22px">Blog is how I learn.</p>
    </div>
    <div id="content_wrapper">
        <div id="right_wrapper" style="margin-left: 10px; width: 30%; font-size:15px; line-height:25px;">
            <ul id="JumpList">
                <li><h4>跳转目录</h4></li>
            </ul>
        </div>
		<div id="left_wrapper">
			<p style="color: rgb(50, 93, 114); font-size:30px; font-weight:300; margin-top: 0; padding-top: 30px;">AndroidPN源码分析(未完成)</p>
			<p style="font-size:15px; margin-top: 0; color: #BBB"><em>By Mr.Dai</em>, 20 Feb 2015</p>
			<!-- content starts here -->
			<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushXml.js"></script>

<h2 class="jump">总述</h2>
<p>
AndroidPN，全名Android Push Notification，是一个基于XMPP协议的安卓开源推送服务平台，其完整代码目前托管于Github上。
在实现上，AndroidPN项目的服务端使用了Spring框架、Hibernate框架与mina框架，而客户端则使用了asmack框架。
Asmack框架作为为安卓设备量身定做的smack框架，在功能上比起源生的PC端smack框架有所精简，其代码同样托管在了Github上。
</p>
<br />
AndroidPN：<a href="https://github.com/dannytiehui/androidpn">https://github.com/dannytiehui/androidpn</a>
Asmack：<a href="https://github.com/Flowdalic/asmack">https://github.com/Flowdalic/asmack</a>
<br />
<p>
注：阅读本文要求读者对Spring、Hibernate、mina、XMPP有一定的了解。
AndroidPN项目中并不包含Asmack项目的源代码，但本教程中将会涉及到asmack的源代码，
因此推荐读者一并下载asmack的源代码。本文使用的是0.8.10版本的asmack以及2012年4月14日的AndroidPN
</p>

<h2 class="jump">AndroidPN业务分析</h2>
<p>在AndroidPN平台的首页上即可看到一张AndroidPN平台业务逻辑原理图：</p>
<p class="center"><img alt="" src="/img/apn-learning@1.png"></p>
<p>
AndroidPN推送平台的实现是基于在服务端与客户端之间保持一条长连接，
双方基于XMPP协议以XML stanza进行沟通。
正是基于这条长连接才使得服务端得以主动得为客户端推送消息。
</p>
<p>
在AndroidPN平台网页的Users选项卡与Sessions选项卡中可以看到，
AndroidPN平台会管理所有曾在平台上注册的设备以及当前活跃的会话，
其中每台设备由一个唯一的长度为32位的16位字符串username进行标识，
所有用户信息都由mysql数据库中的apn_user表进行管理。
</p>
<p class="center"><img alt="" src="/img/apn-learning@2.png"></p>
<p class="center"><img alt="" src="/img/apn-learning@3.png"></p>
<p>
基于以上表象，不难画出服务端与客户端的业务流程大致如下：
</p>
<p>
服务端启动后便不断地侦听指定端口。
当收到来自某个客户端的链接建立请求时便建立与这个客户端之间的长链接并为该链接分配一个新的线程，
由该线程处理该链接的其他请求，并由一个类似于SessionManager的事物对所有的这些线程进行管理。
</p>
<p>
客户端则只需要在启动时向服务器发出链接建立请求，在服务端返回结果后维护建立的长链接，利用该长链接进行后续通信。
</p>
<br />
<p>
接下来我将基于项目的源代码进行分析。
</p>
<h2 class="jump">会话管理 - 客户端</h2>
<p>
我们先从客户端开始。AndroidPN Client比较简单，作为一个Demo App它只有一个Activity，也就是DemoAppActivity：
</p>
<pre class="brush: java">
// DemoAppActivity.java, starts from line 40
// Settings
Button okButton = (Button) findViewById(R.id.btn_settings);
okButton.setOnClickListener(new View.OnClickListener() {
    public void onClick(View view) {
        ServiceManager.viewNotificationSettings(DemoAppActivity.this);
    }
});

// Start the service
ServiceManager serviceManager = new ServiceManager(this);
serviceManager.setNotificationIcon(R.drawable.notification);
serviceManager.startService();
</pre>
<p>
这里为视图的Settings按钮绑定了onClick事件，通过调用ServiceManager类的静态方法来调出Settings页面。这部分无关紧要。
</p>
<p>
往下走就看到程序实例化了一个ServiceManager并启用了Service，可见客户端主要的业务逻辑以Service的形式运行在设备中，Activity只负责展现视图。
</p>
<p>
那么看到ServiceManager类：
</p>
<pre class="brush: java">
// ServiceManager.java
public ServiceManager(Context context) {
    this.context = context;

    if (context instanceof Activity) {
        Log.i(LOGTAG, "Callback Activity...");
        Activity callbackActivity = (Activity) context;
        callbackActivityPackageName = callbackActivity.getPackageName();
        callbackActivityClassName = callbackActivity.getClass().getName();
    }

    //        apiKey = getMetaDataValue("ANDROIDPN_API_KEY");
    //        Log.i(LOGTAG, "apiKey=" + apiKey);
    //        //        if (apiKey == null) {
    //        //            Log.e(LOGTAG, "Please set the androidpn api key in the manifest file.");
    //        //            throw new RuntimeException();
    //        //        }

    props = loadProperties();
        // 读取/res/raw/androipn.properties下的属性值
    apiKey = props.getProperty("apiKey", "");
    xmppHost = props.getProperty("xmppHost", "127.0.0.1");
    xmppPort = props.getProperty("xmppPort", "5222");
    Log.i(LOGTAG, "apiKey=" + apiKey);
    Log.i(LOGTAG, "xmppHost=" + xmppHost);
    Log.i(LOGTAG, "xmppPort=" + xmppPort);

    sharedPrefs = context.getSharedPreferences(
            Constants.SHARED_PREFERENCE_NAME, Context.MODE_PRIVATE);
    Editor editor = sharedPrefs.edit();
    editor.putString(Constants.API_KEY, apiKey);
    editor.putString(Constants.VERSION, version);
    editor.putString(Constants.XMPP_HOST, xmppHost);
    editor.putInt(Constants.XMPP_PORT, Integer.parseInt(xmppPort));
    editor.putString(Constants.CALLBACK_ACTIVITY_PACKAGE_NAME,
            callbackActivityPackageName);
    editor.putString(Constants.CALLBACK_ACTIVITY_CLASS_NAME,
            callbackActivityClassName);
    editor.commit();
    // Log.i(LOGTAG, "sharedPrefs=" + sharedPrefs.toString());
}
</pre>
<p>
代码中包含了大量的日志打印语句。我们只需注意到构造函数将在视图逻辑中传入的DemoAppActivity实例作为Context对象保存到了本类的成员变量中，
然后便调用loadProperties()函数从/res/raw/androidpn.properties文件中读入了相关的配置信息，并将这些信息写入到SharedPreferences中。
</p>
<br />
<p>
然后，DemoAppActivity调用了ServiceManager的startService()方法启动服务。
</p>
<pre class="brush: java">
public void startService() {
    Thread serviceThread = new Thread(new Runnable() {
        public void run() {
            Intent intent = NotificationService.getIntent();
            context.startService(intent);
        }
    });
    serviceThread.start();
}
</pre>
<p>
可以看到方法中启动了一个NotificationService实例。这里建立了一个新的线程来运行服务。
</p>
<p>
然后我们看到NotificationService类：
</p>
<pre class="brush: java">
// NotificationService.java
public NotificationService() {
    notificationReceiver = new NotificationReceiver();
    connectivityReceiver = new ConnectivityReceiver(this);
    phoneStateListener = new PhoneStateChangeListener(this);
    executorService = Executors.newSingleThreadExecutor();
    taskSubmitter = new TaskSubmitter(this);
    taskTracker = new TaskTracker(this);
}

@Override
public void onCreate() {
    Log.d(LOGTAG, "onCreate()...");
    telephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
    // wifiManager = (WifiManager) getSystemService(Context.WIFI_SERVICE);
    // connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);

    sharedPrefs = getSharedPreferences(Constants.SHARED_PREFERENCE_NAME,
            Context.MODE_PRIVATE);

    // Get deviceId
    deviceId = telephonyManager.getDeviceId();
    // Log.d(LOGTAG, "deviceId=" + deviceId);
    Editor editor = sharedPrefs.edit();
    editor.putString(Constants.DEVICE_ID, deviceId);
    editor.commit();

    // If running on an emulator
    if (deviceId == null || deviceId.trim().length() == 0
            || deviceId.matches("0+")) {
        if (sharedPrefs.contains("EMULATOR_DEVICE_ID")) {
            deviceId = sharedPrefs.getString(Constants.EMULATOR_DEVICE_ID,
                    "");
        } else {
            deviceId = (new StringBuilder("EMU")).append(
                    (new Random(System.currentTimeMillis())).nextLong())
                    .toString();
            editor.putString(Constants.EMULATOR_DEVICE_ID, deviceId);
            editor.commit();
        }
    }
    Log.d(LOGTAG, "deviceId=" + deviceId);

    xmppManager = new XmppManager(this);

    taskSubmitter.submit(new Runnable() {
        public void run() {
            NotificationService.this.start();
        }
    });
}
</pre>
<p>
可以看到，NotificationService类在构造函数中初始化了各种BroadcastReceiver和Listener。
我们只需要注意到在其onCreate方法中，NotificationService向SharedPreferences中写入了设备的id、
实例化了一个XmppManager且向TaskSubmitter提交了启动自己的任务。
</p>
<pre class="brush: java">
private void start() {
    Log.d(LOGTAG, "start()...");
    registerNotificationReceiver();
    registerConnectivityReceiver();
    // Intent intent = getIntent();
    // startService(intent);
    xmppManager.connect();
}
</pre>
<p>
在启动时，NotificationService则注册了自己的两个BroadcastReceiver并利用XmppManager向服务器发起链接。
</p>
<br />
<p>
那么我们看到XmppManager：
</p>
<pre class="brush: java">
// XmppManager.java
public XmppManager(NotificationService notificationService) {
    context = notificationService;
    taskSubmitter = notificationService.getTaskSubmitter();
    taskTracker = notificationService.getTaskTracker();
    sharedPrefs = notificationService.getSharedPreferences();

    xmppHost = sharedPrefs.getString(Constants.XMPP_HOST, "localhost");
    xmppPort = sharedPrefs.getInt(Constants.XMPP_PORT, 5222);
    username = sharedPrefs.getString(Constants.XMPP_USERNAME, "");
    password = sharedPrefs.getString(Constants.XMPP_PASSWORD, "");

    connectionListener = new PersistentConnectionListener(this);
    notificationPacketListener = new NotificationPacketListener(this);

    handler = new Handler();
    taskList = new ArrayList<Runnable>();
    reconnection = new ReconnectionThread(this);
}
</pre>
<p>
XmppManager将传入的NotificationService实例作为Context保存到了自己的成员变量中，
并获得了其TaskSubmitter与TaskTracker实例。
然后XmppManager从SharedPreferences中取出了在DemoAppActivity中写入的服务器信息。
</p>
<pre class="brush: java">
// XmppManager.java
public void connect() {
    Log.d(LOGTAG, "connect()...");
    submitLoginTask();
}
private void submitConnectTask() {
    Log.d(LOGTAG, "submitConnectTask()...");
    addTask(new ConnectTask());
}

private void submitRegisterTask() {
    Log.d(LOGTAG, "submitRegisterTask()...");
    submitConnectTask();
    addTask(new RegisterTask());
}

// Connect -> Register -> Login
private void submitLoginTask() {
    Log.d(LOGTAG, "submitLoginTask()...");
    submitRegisterTask();
    addTask(new LoginTask());
}
private void addTask(Runnable runnable) {
    Log.d(LOGTAG, "addTask(runnable)...");
    taskTracker.increase();
    synchronized (taskList) {
        if (taskList.isEmpty() && !running) {
            running = true;
            futureTask = taskSubmitter.submit(runnable);
            if (futureTask == null) {
                taskTracker.decrease();
            }
        } else {
            taskList.add(runnable);
        }
    }
    Log.d(LOGTAG, "addTask(runnable)... done");
}
</pre>
<p>
可见，调用submitLoginTask()方法会在任务队列taskList中依次放入ConnectTask、RegisterTask、LoginTask。addTask()方法通过判断taskList是否为空来决定新的任务是直接放入taskSubmitter还是先放入taskList。同样是操作taskList，我们再看到runTask()方法：
</p>
<pre class="brush: java">
// XmppManager.java
public void runTask() {
    Log.d(LOGTAG, "runTask()...");
    synchronized (taskList) {
        running = false;
        futureTask = null;
        if (!taskList.isEmpty()) {
            Runnable runnable = (Runnable) taskList.get(0);
            taskList.remove(0);
            running = true;
            futureTask = taskSubmitter.submit(runnable);
            if (futureTask == null) {
                taskTracker.decrease();
            }
        }
    }
    taskTracker.decrease();
    Log.d(LOGTAG, "runTask()...done");
}
</pre>
<p>
runTask方法从taskList中拿出一个任务并提交到TaskSubmitter里进行运行，
可见ConnectTask、RegisterTask、LoginTask在执行之前，均需要通过任务队列taskList进行一次同步操作
，然后再进入多线程进行执行。这里我也不懂为什么要这么做。
</p>
<br />
<p>
我们看到ConnectTask的run()方法：
</p>
<pre class="brush: java">
// XmppManager.java
public void run() {
    Log.i(LOGTAG, "ConnectTask.run()...");

    if (!xmppManager.isConnected()) {
        // Create the configuration for this new connection
        ConnectionConfiguration connConfig = new ConnectionConfiguration(
                xmppHost, xmppPort);
        // connConfig.setSecurityMode(SecurityMode.disabled);
        connConfig.setSecurityMode(SecurityMode.required);
        connConfig.setSASLAuthenticationEnabled(false);
        connConfig.setCompressionEnabled(false);

        XMPPConnection connection = new XMPPConnection(connConfig);
        xmppManager.setConnection(connection);

        try {
            // Connect to the server
            connection.connect();
            Log.i(LOGTAG, "XMPP connected successfully");

            // packet provider
            ProviderManager.getInstance().addIQProvider("notification",
                    "androidpn:iq:notification",
                    new NotificationIQProvider());

        } catch (XMPPException e) {
            Log.e(LOGTAG, "XMPP connection failed", e);
        }

        xmppManager.runTask();

    } else {
        Log.i(LOGTAG, "XMPP connected already");
        xmppManager.runTask();
    }
}
</pre>
<p>
ConnectTask配置好链接目标与链接信息后便实例化了一个XMPPConnection并将其交给XmppManager进行管理，然后通过XMPPConnection的connect()方法打开链接并将一个NotificationIQProvider放入到了ProviderManager中。
</p>
<p>
我们先看到XMPPConnection的connect()方法：
</p>
<pre class="brush: java">
// XMPPConnection.java
/**
 * Establishes a connection to the XMPP server and performs an automatic login
 * only if the previous connection state was logged (authenticated). It basically
 * creates and maintains a socket connection to the server.&lt;p&gt;
 * &lt;p/&gt;
 * Listeners will be preserved from a previous connection if the reconnection
 * occurs after an abrupt termination.
 *
 * @throws XMPPException if an error occurs while trying to establish the connection.
 *      Two possible errors can occur which will be wrapped by an XMPPException --
 *      UnknownHostException (XMPP error code 504), and IOException (XMPP error code
 *      502). The error codes and wrapped exceptions can be used to present more
 *      appropriate error messages to end-users.
 */
public void connect() throws XMPPException {
    // Establishes the connection, readers and writers
    connectUsingConfiguration(config);
    // Automatically makes the login if the user was previously connected successfully
    // to the server and the connection was terminated abruptly
    if (connected && wasAuthenticated) {
        // Make the login
        if (isAnonymous()) {
            // Make the anonymous login
            loginAnonymously();
        }
        else {
            login(config.getUsername(), config.getPassword(), config.getResource());
        }
        notifyReconnection();
    }
}
private void connectUsingConfiguration(ConnectionConfiguration config) throws XMPPException {
    XMPPException exception = null;
    Iterator&lt;HostAddress&gt; it = config.getHostAddresses().iterator();
    List&lt;HostAddress&gt; failedAddresses = new LinkedList&lt;HostAddress&gt;();
    boolean xmppIOError = false;
    while (it.hasNext()) {
        exception = null;
        HostAddress hostAddress = it.next();
        String host = hostAddress.getFQDN();
        int port = hostAddress.getPort();
        try {
            if (config.getSocketFactory() == null) {
                this.socket = new Socket(host, port);
            }
            else {
                this.socket = config.getSocketFactory().createSocket(host, port);
            }
        } catch (UnknownHostException uhe) {
            String errorMessage = "Could not connect to " + host + ":" + port + ".";
            exception = new XMPPException(errorMessage, new XMPPError(XMPPError.Condition.remote_server_timeout,
                    errorMessage), uhe);
        } catch (IOException ioe) {
            String errorMessage = "XMPPError connecting to " + host + ":" + port + ".";
            exception = new XMPPException(errorMessage, new XMPPError(XMPPError.Condition.remote_server_error,
                    errorMessage), ioe);
            xmppIOError = true;
        }
        if (exception == null) {
            // We found a host to connect to, break here
            config.setUsedHostAddress(hostAddress);
            break;
        }
        hostAddress.setException(exception);
        failedAddresses.add(hostAddress);
        if (!it.hasNext()) {
            // There are no more host addresses to try
            // throw an exception and report all tried
            // HostAddresses in the exception
            StringBuilder sb = new StringBuilder();
            for (HostAddress fha : failedAddresses) {
                sb.append(fha.getErrorMessage());
                sb.append("; ");
            }
            XMPPError xmppError;
            if (xmppIOError) {
                xmppError = new XMPPError(XMPPError.Condition.remote_server_error);
            }
            else {
                xmppError = new XMPPError(XMPPError.Condition.remote_server_timeout);
            }
            throw new XMPPException(sb.toString(), xmppError, exception);
        }
    }
    socketClosed = false;
    initConnection();
}
</pre>
<p>
    在connectUsingConfiguration()方法里，可以看到客户端使用源生Socket接口打开通往服务器的链接。由于对于一台设备，必然只会有一条连接服务器的链接，因此可以直接用源生Socket来管理链接。但在服务端，服务器需要同时管理大量设备的长链接，因此后面我们会看到，AndroidPN的服务端使用了mina框架来管理这些链接。
</p>
<p>
    在connectUsingConfiguration()的最后调用了initConnection()，那么我们看到这个方法：
</p>
<pre class="brush: java">
// XMPPConnection.java

/**
 * Initializes the connection by creating a packet reader and writer and opening a
 * XMPP stream to the server.
 *
 * @throws XMPPException if establishing a connection to the server fails.
 */
private void initConnection() throws XMPPException {
    boolean isFirstInitialization = packetReader == null || packetWriter == null;
    compressionHandler = null;
    serverAckdCompression = false;

    // Set the reader and writer instance variables
    initReaderAndWriter();

    try {
        if (isFirstInitialization) {
            packetWriter = new PacketWriter(this);
            packetReader = new PacketReader(this);

            // If debugging is enabled, we should start the thread that will listen for
            // all packets and then log them.
            if (config.isDebuggerEnabled()) {
                addPacketListener(debugger.getReaderListener(), null);
                if (debugger.getWriterListener() != null) {
                    addPacketSendingListener(debugger.getWriterListener(), null);
                }
            }
        }
        else {
            packetWriter.init();
            packetReader.init();
        }

        // Start the packet writer. This will open a XMPP stream to the server
        packetWriter.startup();
        // Start the packet reader. The startup() method will block until we
        // get an opening stream packet back from server.
        packetReader.startup();

        // Make note of the fact that we're now connected.
        connected = true;

        if (isFirstInitialization) {
            // Notify listeners that a new connection has been established
            for (ConnectionCreationListener listener : getConnectionCreationListeners()) {
                listener.connectionCreated(this);
            }
        }

    }
    catch (XMPPException ex) {
        // An exception occurred in setting up the connection. Make sure we shut down the
        // readers and writers and close the socket.

        if (packetWriter != null) {
            try {
                packetWriter.shutdown();
            }
            catch (Throwable ignore) { /* ignore */ }
            packetWriter = null;
        }
        if (packetReader != null) {
            try {
                packetReader.shutdown();
            }
            catch (Throwable ignore) { /* ignore */ }
            packetReader = null;
        }
        if (reader != null) {
            try {
                reader.close();
            }
            catch (Throwable ignore) { /* ignore */ }
            reader = null;
        }
        if (writer != null) {
            try {
                writer.close();
            }
            catch (Throwable ignore) {  /* ignore */}
            writer = null;
        }
        if (socket != null) {
            try {
                socket.close();
            }
            catch (Exception e) { /* ignore */ }
            socket = null;
        }
        this.setWasAuthenticated(authenticated);
        chatManager = null;
        authenticated = false;
        connected = false;

        throw ex;        // Everything stoppped. Now throw the exception.
    }
}

private void initReaderAndWriter() throws XMPPException {
    try {
        if (compressionHandler == null) {
            reader =
                    new BufferedReader(new InputStreamReader(socket.getInputStream(), "UTF-8"));
            writer = new BufferedWriter(
                    new OutputStreamWriter(socket.getOutputStream(), "UTF-8"));
        }
        else {
            try {
                OutputStream os = compressionHandler.getOutputStream(socket.getOutputStream());
                writer = new BufferedWriter(new OutputStreamWriter(os, "UTF-8"));

                InputStream is = compressionHandler.getInputStream(socket.getInputStream());
                reader = new BufferedReader(new InputStreamReader(is, "UTF-8"));
            }
            catch (Exception e) {
                e.printStackTrace();
                compressionHandler = null;
                reader = new BufferedReader(
                        new InputStreamReader(socket.getInputStream(), "UTF-8"));
                writer = new BufferedWriter(
                        new OutputStreamWriter(socket.getOutputStream(), "UTF-8"));
            }
        }
    }
    catch (IOException ioe) {
        throw new XMPPException(
                "XMPPError establishing connection with server.",
                new XMPPError(XMPPError.Condition.remote_server_error,
                        "XMPPError establishing connection with server."),
                ioe);
    }

    // If debugging is enabled, we open a window and write out all network traffic.
    initDebugger();
}
</pre>
			<!-- and ends here -->
			
			<!-- Disqus Block starts here -->
			<div id="disqus_thread"></div>
			<script type="text/javascript">
				/* * * CONFIGURATION VARIABLES * * */
				var disqus_shortname = 'robertpsblog';
				var disqus_identifier = 'AndroidPN源码分析(未完成)';
    
				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
					var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<!-- and ends here -->
		</div>
    </div>
    </div>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/mrdai.js"></script>
    <script>SyntaxHighlighter.all()</script>
</body>
</html>