<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/default.css" rel="stylesheet">
	<link href="/css/post.css" rel="stylesheet">
    <script type="text/javascript" src="/js/jquery-2.1.1.min.js"></script>
    
    <script type="text/javascript" src="/js/syntaxhighlighters/shCore.js"></script>
    <link href="/css/syntaxhighlighters/shCore.css" rel="stylesheet" type="text/css" />
    <link href="/css/syntaxhighlighters/shThemeDefault.css" rel="stylesheet" type="text/css" />
	
	<link rel="shortcut icon" href="/img/favicon.ico" >
    
    <title>安卓Service生命周期 - Mr.Dai</title>
</head>
<body>
	<script src="/js/bootstrap.min.js"></script>
	<script src="/js/mrdai.js"></script>
    <div id="main_wrapper">
    <div id="banner_wrapper">
    <h1 style="padding-bottom:0">Robert P.'s Blog</h1>
	<p style="margin-top:8px; color: #999999; font-size: 22px">Blog is how I learn.</p>
    </div>
    <div id="content_wrapper">
        <div id="right_wrapper" style="margin-left: 10px; width: 30%; font-size:15px; line-height:25px;">
            <ul id="JumpList">
                <li><h4>跳转目录</h4></li>
            </ul>
        </div>
		<div id="left_wrapper">
			<p style="color: rgb(50, 93, 114); font-size:30px; font-weight:300; margin-top: 0; padding-top: 30px;">安卓Service生命周期</p>
			<p style="font-size:15px; margin-top: 0; color: #BBB"><em>By Mr.Dai</em>, 15 Mar 2015</p>
			<script>SyntaxHighlighter.all()</script>
			<!-- content starts here -->
			<h2 class="jump">背景</h2>
<p>
    由于本人实在是没有经过系统的安卓学习，因此到了最近才真正懂得Service的一些本质。
    于是，今天我便要写下这篇博客来让自己以后能快速地复习起这些知识。
</p>

<h2 class="jump">Service是什么</h2>
<blockquote>
 <p>Most confusion about the Service class actually revolves around what
 it is <em>not</em>:</p>
 
 <ul>
 <li> A Service is <b>not</b> a separate process.  The Service object itself
 does not imply it is running in its own process; unless otherwise specified,
 it runs in the same process as the application it is part of.
 <li> A Service is <b>not</b> a thread.  It is not a means itself to do work off
 of the main thread (to avoid Application Not Responding errors).
 </ul>
 
 <p>Thus a Service itself is actually very simple, providing two main features:</p>
 
 <ul>
 <li>A facility for the application to tell the system <em>about</em>
 something it wants to be doing in the background (even when the user is not
 directly interacting with the application).  This corresponds to calls to
 <code><a href="/reference/android/content/Context.html#startService(android.content.Intent)">Context.startService()</a></code>, which
 ask the system to schedule work for the service, to be run until the service
 or someone else explicitly stop it.
 <li>A facility for an application to expose some of its functionality to
 other applications.  This corresponds to calls to
 <code><a href="/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int)">Context.bindService()</a></code>, which
 allows a long-standing connection to be made to the service in order to
 interact with it.
 </ul>
 
 <p>When a Service component is actually created, for either of these reasons,
 all that the system actually does is instantiate the component
 and call its <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> and any other appropriate callbacks on the
 main thread.  It is up to the Service to implement these with the appropriate
 behavior, such as creating a secondary thread in which it does its work.</p>
 
 <p>Note that because Service itself is so simple, you can make your
 interaction with it as simple or complicated as you want: from treating it
 as a local Java object that you make direct method calls on (as illustrated
 by <a href="#LocalServiceSample">Local Service Sample</a>), to providing
 a full remoteable interface using AIDL.</p>
 <footer>http://developer.android.com/reference/android/app/Service.html#WhatIsAService</footer>
</blockquote>

<p>
    总结起来其实就是：Service既不是一个新的线程也不是一个新的进程，它直接运行在那个通过startService或者bindService启动它的线程上。
    为了让Service运行在一个独立的线程而不是主线程上，你可以先新建一个线程，在新线程里通过调用startService或者bindService启动它，
    也可以在主线程上启动它，然后在Service新建一个线程来运行Service的业务逻辑。个人更加推荐前一种方法，因为前一种方法关闭新线程的唯一途径只能是
    通过stopService或者unbindService关闭Service，这样会使得线程更加可控。
</p>

<h2 class="jump">Service生命周期</h2>
<blockquote>
     <p>There are two reasons that a service can be run by the system.  If someone
 calls <code><a href="/reference/android/content/Context.html#startService(android.content.Intent)">Context.startService()</a></code> then the system will
 retrieve the service (creating it and calling its <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> method
 if needed) and then call its <code><a href="/reference/android/app/Service.html#onStartCommand(android.content.Intent, int, int)">onStartCommand(Intent, int, int)</a></code> method with the
 arguments supplied by the client.  The service will at this point continue
 running until <code><a href="/reference/android/content/Context.html#stopService(android.content.Intent)">Context.stopService()</a></code> or
 <code><a href="/reference/android/app/Service.html#stopSelf()">stopSelf()</a></code> is called.  Note that multiple calls to
 Context.startService() do not nest (though they do result in multiple corresponding
 calls to onStartCommand()), so no matter how many times it is started a service
 will be stopped once Context.stopService() or stopSelf() is called; however,
 services can use their <code><a href="/reference/android/app/Service.html#stopSelf(int)">stopSelf(int)</a></code> method to ensure the service is
 not stopped until started intents have been processed.
 
 <p>For started services, there are two additional major modes of operation
 they can decide to run in, depending on the value they return from
 onStartCommand(): <code><a href="/reference/android/app/Service.html#START_STICKY">START_STICKY</a></code> is used for services that are
 explicitly started and stopped as needed, while <code><a href="/reference/android/app/Service.html#START_NOT_STICKY">START_NOT_STICKY</a></code>
 or <code><a href="/reference/android/app/Service.html#START_REDELIVER_INTENT">START_REDELIVER_INTENT</a></code> are used for services that should only
 remain running while processing any commands sent to them.  See the linked
 documentation for more detail on the semantics.
 
 <p>Clients can also use <code><a href="/reference/android/content/Context.html#bindService(android.content.Intent, android.content.ServiceConnection, int)">Context.bindService()</a></code> to
 obtain a persistent connection to a service.  This likewise creates the
 service if it is not already running (calling <code><a href="/reference/android/app/Service.html#onCreate()">onCreate()</a></code> while
 doing so), but does not call onStartCommand().  The client will receive the
 <code><a href="/reference/android/os/IBinder.html">IBinder</a></code> object that the service returns from its
 <code><a href="/reference/android/app/Service.html#onBind(android.content.Intent)">onBind(Intent)</a></code> method, allowing the client to then make calls back
 to the service.  The service will remain running as long as the connection
 is established (whether or not the client retains a reference on the
 service's IBinder).  Usually the IBinder returned is for a complex
 interface that has been <a href="/guide/components/aidl.html">written
 in aidl</a>.
 
 <p>A service can be both started and have connections bound to it.  In such
 a case, the system will keep the service running as long as either it is
 started <em>or</em> there are one or more connections to it with the
 <code><a href="/reference/android/content/Context.html#BIND_AUTO_CREATE">Context.BIND_AUTO_CREATE</a></code>
 flag.  Once neither
 of these situations hold, the service's <code><a href="/reference/android/app/Service.html#onDestroy()">onDestroy()</a></code> method is called
 and the service is effectively terminated.  All cleanup (stopping threads,
 unregistering receivers) should be complete upon returning from onDestroy().
 <footer>http://developer.android.com/reference/android/app/Service.html#ServiceLifecycle</footer>
</blockquote>

<p>总结起来其实就是下图：</p>
<p class="center"><img alt="" src="/img/service-lifecycle@1.png"></p>
<p>其中还提到onStartCommand()和onBind()函数的返回值可以影响Service的特性。这个以后再慢慢了解</p>


			<!-- and ends here -->
			<div class="blank" style="height: 80px"></div>
			<!-- Disqus Block starts here -->
			<div id="disqus_thread"></div>
			<script type="text/javascript">
				/* * * CONFIGURATION VARIABLES * * */
				var disqus_shortname = 'robertpsblog';
				var disqus_identifier = '安卓Service生命周期';
    
				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
					var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<!-- and ends here -->
		</div>
    </div>
    </div>
</body>
</html>