<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/default.css" rel="stylesheet">
	<link href="/css/post.css" rel="stylesheet">
    <script type="text/javascript" src="/js/jquery-2.1.1.min.js"></script>
    
    <script type="text/javascript" src="/js/syntaxhighlighters/shCore.js"></script>
    <link href="/css/syntaxhighlighters/shCore.css" rel="stylesheet" type="text/css" />
    <link href="/css/syntaxhighlighters/shThemeDefault.css" rel="stylesheet" type="text/css" />
	
	<link rel="shortcut icon" href="/img/favicon.ico" >
    
    <title>Scala性能基准测试 - Robert Peng</title>
</head>
<body>
    <div id="main_wrapper">
    <div id="banner_wrapper">
    <h1 style="padding-bottom:0">Robert P.'s Blog</h1>
	<p style="margin-top:8px; color: #999999; font-size: 22px">Blog is how I learn.</p>
    </div>
    <div id="content_wrapper">
        <div id="right_wrapper" style="margin-left: 10px; width: 30%; font-size:15px; line-height:25px;">
            <ul id="JumpList">
                <li><h4>跳转目录</h4></li>
            </ul>
        </div>
		<div id="left_wrapper">
			<p style="color: rgb(50, 93, 114); font-size:30px; font-weight:300; margin-top: 0; padding-top: 30px;">Scala性能基准测试</p>
			<p style="font-size:15px; margin-top: 0; color: #BBB"><em>By Robert Peng</em>, 12 Aug 2015</p>
			<!-- content starts here -->
			<script type="text/javascript" src="/js/syntaxhighlighters/shBrushBash.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushCpp.js"></script>
<script type="text/javascript" src="/js/syntaxhighlighters/shBrushScala.js"></script>

<h2 class="jump">写作背景</h2>

<p>
	对于Spark或者Scala开发者而言，Scala语言的魅力是毋庸置疑的。
</p>
<p>	
	大部分Scala程序员在学习Scala之前都有过一定的Java编程经验。并不能说Java的面向对象不好，但正是由于Java的面向对象是如此的规范，
	很多情况下我们不得不写出大量的胶水代码。这样的代码仅仅是为了让整个程序能跑起来，但从业务逻辑上来讲毫无用处，从某种程度上也拖慢了项目开发的速度。
	人们当然不喜欢“胶水代码”这个名字，于是在这种情况下我们给了它们一个很有艺术感的名字：设计模式。（注：并不是所有设计模式都是无用的胶水代码）
</p>
<p>
	Scala作为又一门JVM语言，它延续了Java的面向对象特性，但更为自由，同时引入了比起Java成熟得多的函数式编程特性。学习过Scala提供的大量的语法糖后，
	大多数程序员从此走上了敏捷开发的道路。对他们来说，Scala简直就是一把尚方宝剑。
</p>
<p>
	别急着赞同。如果我告诉你，同样的代码，Scala比Java慢几十倍，你会有什么想法？
</p>
<p>
	这是我编出来吓你的玩笑话？你看看<a href="http://www.cnblogs.com/chengxin1982/p/4034186.html">这个</a>，再看看<a href="http://www.cnblogs.com/superjt/archive/2012/04/22/2465348.html">这个</a>。
	触目惊心？好像真的慢了几十倍啊。当然了，如果你不是Scala程序员而依然是Java的卫道士，我想你现在应该十分骄傲吧。“让你们乱来，让你们抄近路，性能触底了吧，哈哈”。
</p>
<p>事实真的是如此吗？</p>
<p>
	我一直都觉得，没有详实的数据记录就随便下结论等同于耍流氓（耍流氓都成了梗了 - -），所以我要写这篇文章。在这篇文章里，我将进行大量的实验，
	不断地测试同一个功能的不同Scala写法以及同样的写法在Java中的性能表现，并以图表的形式告诉你们，到底怎样写更快，怎样写更慢，Scala是不是真的比Java慢几十倍。
</p>

<h1>1 循环</h1>
<p>
	循环这种东西，用得简直就是太多啦。像我在上一节列出的两篇博文，其实都有提到一个观点：“Scala的循环比Java慢很多，尤其是Scala的for循环，
	甚至比它自己的while循环都要慢上几十倍”。那事实又是如何呢？我们来问问神奇数据吧！
</p>
<h2 class="jump">1.1 遍历单个大集合</h2>
<p>首先，基准测试要有测试代码。我们先来看Java的测试代码：（不想看代码可以直接跳到下面）</p>
<pre class="brush: java">
package benchmark.loop;

/**
 * Java Benchmark Testing on loop. Only used to give a baseline of JVM loop performance
 *
 * @author Robert Peng  12/08/2015
 */
public class JavaFor {

    private static long startMili;
    private static long endMili;
    private static long dummy;
    private static int[] sizeCandidates = {
    100000000, 200000000, 300000000, 400000000, 500000000,
    600000000, 700000000, 800000000, 900000000, 1000000000
    };

    public static void main(String[] args) {
        // Test on performance of Java `for` loop...
        for (int size : sizeCandidates) {
            dummy = 0;
            startMili = System.currentTimeMillis();
            for (int i = 1; i &lt;= size; i++)
                dummy += (i % 10);
            endMili = System.currentTimeMillis();
            echo("Java `for` loop of size " + size + " finished in " + (endMili - startMili) + " ms");
        }

        // Test on performance of Java `while` loop...
        for (int size : sizeCandidates) {
            dummy = 0;
            startMili = System.currentTimeMillis();
            int i = 1;
            while (i &lt;= size) {
                dummy += (i % 10);
                i++;
            }
            endMili = System.currentTimeMillis();
            echo("Java `while` loop of size " + size + " finished in " + (endMili - startMili) + " ms");
        }

        // Test on performance of Java `for` loop with guard...
        for (int size : sizeCandidates) {
            dummy = 0;
            startMili = System.currentTimeMillis();
            for (int i = 1; i &lt;= size; i++)
                if (i % 2 == 0)
                    dummy += (i % 10);
            endMili = System.currentTimeMillis();
            echo("Java `for` loop with guard of size " + size + " finished in " + (endMili - startMili) + " ms");
        }

        // Test on performance of Java `while` loop with guard...
        for (int size : sizeCandidates) {
            dummy = 0;
            startMili = System.currentTimeMillis();
            int i = 1;
            while (i &lt;= size) {
                if (i % 2 == 0)
                    dummy += (i % 10);
                i++;
            }
            endMili = System.currentTimeMillis();
            echo("Java `while` loop with guard of size " + size + " finished in " + (endMili - startMili) + " ms");
        }
    }

    private static void echo(String s) {
        System.out.println(s);
    }

}
</pre>
<p>
	这里我解释一下上面的代码都测了什么。没看代码的读者可以看一下这一段，看过代码的读者可以选择跳过。上述代码分别对Java的<code>for</code>
	循环以及<code>while</code>循环进行测试，测试遍历一个超大数据集所需的时间。后半段代码则是在循环体的内部加入了一个<code>if</code>判断语句，
	再度测试Java的<code>for</code>和<code>while</code>的性能表现。那么实际结果又是如何呢？
</p>
<p>
	上述代码由最新版的1.8 JDK编译，并运行于64位的1.8（build 1.8.0_45-b15） HotSpot JVM（build 25.45-b02）之上。
	该程序在我的笔记本上重复执行了5次，对数据采样求均值并制成图表以后结果如下：
</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@1.jpg"></p>
<p>
	可以看到，Java的<code>for</code>循环比起<code>while</code>循环会慢一点，耗时大概多了20%，
	但当它们都带上了<code>if</code>条件判断的时候，它们的性能却又几乎相同了。
	这倒是个比较耐人寻味的差别，或许和Java的编译优化或者JVM的运行优化有关。
</p>
<p>不过Java运行结果之间的对比倒不是今天的重点。接下来我们来看看Scala。测试代码如下：（同上，不想看的读者可以直接跳过）</p>
<pre class="brush: scala">
package benchmark.loop

/**
 * Scala Benchmark Testing on `for` loop, comparing to Java-like loop implemented by `while`
 *
 * @author Robert Peng  11/08/2015
 */
object ScalaFor {

    var startMili: Long = _
    var endMili: Long = _

    var dummy: Long = _

    def echo(s: String) = Console println s

    def main(args: Array[String]): Unit = {
        val sizeCandidates =
            Array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).map( _ * 100000000)

        // Test on performance of Scala `for` loop...
        for (size &lt;- sizeCandidates) {
            dummy = 0
            startMili = System.currentTimeMillis
            for (i &lt;- 1 to size)
                dummy += (i % 10)
            endMili = System.currentTimeMillis
            echo("Scala `for` loop of size " + size + " finished in " + (endMili - startMili) + " ms")
        }

        // Test on performance of Java-like Scala `while` loop...
        for (size &lt;- sizeCandidates) {
            dummy = 0
            startMili = System.currentTimeMillis
            var i = 0
            while (i &lt; size) {
                dummy += (i % 10)
                i += 1
            }
            endMili = System.currentTimeMillis
            echo("Java-like Scala `while` loop of size " + size + " finished in " + (endMili - startMili) + " ms")
        }

        // Test on performance of Scala `for` loop with guard...
        for (size &lt;- sizeCandidates) {
            dummy = 0
            startMili = System.currentTimeMillis
            for (i &lt;- 1 to size if i % 2 == 0)
                dummy += (i % 10)
            endMili = System.currentTimeMillis
            echo("Scala `for` loop with guard of size " + size + " finished in " + (endMili - startMili) + " ms")
        }

        // Test on performance of Scala `for` loop with if...
        echo("===")
        for (size &lt;- sizeCandidates) {
            dummy = 0
            startMili = System.currentTimeMillis
            for (i &lt;- 1 to size)
                if (i % 2 == 0)
                    dummy += (i % 10)
            endMili = System.currentTimeMillis
            echo("Scala `for` loop with guard of size " + size + " finished in " + (endMili - startMili) + " ms")
        }
        echo("===")

        // Test on performance of Java-like Scala `while` loop with `if`...
        for (size &lt;- sizeCandidates) {
            dummy = 0
            startMili = System.currentTimeMillis
            var i = 0
            while (i &lt; size) {
                if (i % 2 == 0) dummy += (i % 10)
                i += 1
            }
            endMili = System.currentTimeMillis
            echo("Java-like Scala `while` loop with guard of size " + size + " finished in " + (endMili - startMili) + " ms")
        }
    }
}
</pre>
<p>
	我解释一下上面的代码在干什么。没看代码的读者可以看一下这一段，看过代码的读者可以选择跳过。这段代码测试了和上一段Java代码相同的4项功能：
	<code>for</code>、<code>while</code>、有<code>if</code>的<code>for</code>、有<code>if</code>的<code>while</code>。不过要注意的是，Scala的<code>for</code>
	循环与Java的不同，Scala的<code>for</code>关键字只提供了foreach的功能，如果要实现像Java中的那种<code>for(初始化;条件;更新)</code>的功能，
	只能通过Scala的<code>while</code>来实现。除此之外，这段代码还测试了Scala的for循环守卫的性能，我们可以看看守卫和循环体内<code>if</code>语句的性能是否有差别。
</p>
<p>上述代码由最新版的2.11.7 Scala编译器编译为字节码，使用与上一段Java测试相同的JVM进行测试。测试结果如下：</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@2.jpg"></p>
<p>
	惊了，使用守卫的for循环居然这么慢！与逻辑相同的在函数体内使用if语句的for循环，耗时直接增加了两倍以上。
	除了这个特别突出的案例以外，其他四项测试显示的数据分布与Java的十分相似，数值上也和Java十分接近。其中Scala的for也没有像传说的那样比Scala的while慢几十倍，
	在耗时上for仅仅比while多了大约10%，这一点上与Java中的for和while比较相似。
</p>
<p>那么接下来，我们开始分项地对比同样的功能在Java和Scala之间的性能差别。首先我们先来看看最简单的for：</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@3.jpg"></p>
<p>
	尽管我们看到Scala的for循环稍快于Java，但从两条线的斜率上看，不难看出这样的结果仅存在于数据集如此庞大的情况下。
	Scala首先需要用<code>to</code>方法生成遍历体，生成遍历体的过程便存在一定的性能损失，而Java并不存在这样的过程。
	测试中所使用的最小的数据集都拥有100,000,000个元素，在正常的编程环境中根本不可能使用这么大的数组。
	所以只能说，Scala在大到没朋友的数据集上暂时小胜。
</p>
<p>接下来我们看看while：</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@4.jpg"></p>
<p>
	除了少数由于测试数据过少导致的误差以外，我们可以看到Scala的while和Java表现出了完全相同的性能。
	这其实并不奇怪，因为Scala的while和Java的while本来就是同一个东西。
	这只能说明“Scala比Java慢好几倍”这个说法在while循环上不成立。
</p>
<p>接下来是带条件的for：</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@5.jpg"></p>
<p>
	尽管斜率上的表现和普通的for的图表十分相似，但这次Scala和For却换了一次位置，这倒是十分有意思。
	那在小数据集的情况下，说不定Scala会比Java更快？
</p>
<p>接下来是有条件的while：</p>
<p class="center"><img style="width: 100%" alt="" src="/img/ScalaBenchmark@6.jpg"></p>
<p>
	这次Scala倒是比Java慢了一点。我们刚刚看到，简单的while语句在Scala和Java上有着完全一致的性能，
	实质上来讲Scala的while和Java的本来就是同一个东西。那么这次出现的性能的差异，
	恐怕意味着在Scala中计算<code>i % 2 == 0</code>要比Java慢一点点。
</p>
<br />
<br />
<p>在这次测试中，我们用大到没朋友的数据集分别测试了Scala和Java中for和while循环的性能并对它们进行了对比，最终得出结论：</p>
<ul>
	<li>Scala for语句的if守卫性能十分糟糕，在同样的数据集上，其耗时比起逻辑相同的在循环体内使用if语句的Scala for循环多了两倍以上。</li>
	<li>Scala的while与Java的while表现出了完全一致的性能，证明了它们原理上完全相同的本质。</li>
	<li>Scala for语句的性能表现略优于Java的for语句，但这种情况似乎仅存在于超大的数据集上。</li>
	<li>Scala带条件的while比Java的稍慢，也许意味着Scala计算<code>i % 2 == 0</code>需要更多的时间。</li>
</ul>
<p>
	<b>注意</b>，本文仅保证以上结论在当前情况下成立，以上结论在小数据集的情况下不一定成立。
	当前测试为单次遍历超大数据集的测试，测试中使用的最小的数据集都拥有100,000,000个元素，如此大的数据集在实际编程中是不可能存在的。
	测试结果请酌情参考。
</p>

<h2 class="jump">下集预告</h2>
<p>下一次我将测试两种语言在遍历大量小集合时的性能表现，毋庸置疑这样的测试对于实际的编程环境具有更大的参考意义。敬请期待。</p>

			<!-- and ends here -->
			<div class="blank" style="height: 80px"></div>
			<!-- Disqus Block starts here -->
			<div id="disqus_thread"></div>
			<script type="text/javascript">
				/* * * CONFIGURATION VARIABLES * * */
				var disqus_shortname = 'robertpsblog';
				var disqus_identifier = 'Scala性能基准测试';
    
				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
					var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
			</script>
			<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
			<!-- and ends here -->
		</div>
    </div>
    </div>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/mrdai.js"></script>
    <script>SyntaxHighlighter.all()</script>
</body>
</html>