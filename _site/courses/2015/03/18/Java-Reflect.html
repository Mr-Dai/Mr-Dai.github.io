<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/mrdai.css" rel="stylesheet">
    <script type="text/javascript" src="/js/jquery-2.1.1.min.js"></script>
    
    <script type="text/javascript" src="/js/syntaxhighlighters/shCore.js"></script>
    <link href="/css/syntaxhighlighters/shCore.css" rel="stylesheet" type="text/css" />
    <link href="/css/syntaxhighlighters/shThemeDefault.css" rel="stylesheet" type="text/css" />
    
    <title>Java反射学习笔记 - Robert Peng</title>
</head>
<body>
    <div id="main_wrapper">
    <div id="banner_wrapper">
    <h1 style="padding-bottom:0">Robert P.'s Blog</h1>
	<p style="margin-top:8px; color: #999999; font-size: 22px">Blog is how I learn.</p>
    </div>
    <div id="content_wrapper" style="padding:20px; line-height:30px">
        <div id="right_wrapper" style="float:right; margin-left: 10px; width: 30%; font-size:15px; line-height:25px;">
            <ul id="JumpList">
                <li><h4>跳转目录</h4></li>
            </ul>
        </div>
        <p style="color: rgb(50, 93, 114); font-size:30px; font-weight:300">Java反射学习笔记</p>
		<p style="font-size:15px; margin-top: 0; color: #BBB"><em>By Robert Peng</em>, 18 Mar 2015</p>
        <!-- content begins here -->
        <script type="text/javascript" src="/js/syntaxhighlighters/shBrushJava.js"></script>

<p>内容出自慕课网： <a href="http://www.imooc.com/video/3725">反射——Java高级开发必须懂的</a>，转载请注明出处</p>
<br />

<h2 class="jump">第一节：Class类的使用</h2>
<p><i>在面向对象的世界里，万事万物皆对象。</i></p>
<p>那在Java语言中，只有两样东西不是对象，那就是静态成员和基本数据类型</p>
<p>那么，我们写的类是不是对象呢？</p>
<p>答案是肯定的。我们写的类也是对象，它们是java.lang.Class类的实例对象</p>
<p>那么这个类对象如何表示呢？</p>

<pre class="brush: java">
public class ClassDemo1 {
    public static void main(String[] args) {
        // Foo的实例对象如何表示？
        Foo foo1 = new Foo(); // foo1就表示出来了
        // Foo这个类也是一个实例对象，Class类的实例对象。如何表示呢？
        // 任何一个类都是Class的实例对象，这个实例对象有三种表示方式
        
        // 第一种表示方式 -> 任何一个类都有一个隐含的静态成员变量class
        Class c1 = Foo.class;
        
        // 第二种表示方式 -> 已知该类的对象，通过getClass方法
        Class c2 = foo1.getClass();
        
        System.out.println(c1 == c2);
        
        // 第三种表达方式
        Class c3 = null;
            c3 = Class.forName("Foo"); // 为了简化，这里省略了try/catch
        System.out.println(c2 == c3);
        // c1, c2, c3表示了Foo类的类类型(class type)
        
        // 我们完全可以通过类的类类型创建该类的对象实例
        Foo foo = (Foo) c1.newInstance(); // 需要有无参数的构造方法（为了简化，这里省略了try/catch）
        foo.print();
    }
}

class Foo {
    void print() {
        System.out.println("foo");
    }
}
</pre>

<h2 class="jump">第二节：动态加载类</h2>
<p>在开始深入讲解前，首先我们要区分动态加载和静态加载</p>
<p><i>编译时刻加载类是静态加载类，运行时刻加载类是动态加载类</i></p>

<p>设想我们要实现一个Office，我们输入Word他就启动Word，输入Excel就启动Excel</p>
<pre class="brush: java">
class Office {
    public static void main(String[] args) {
        if ("Word".equals(args[0])) {
            Word w = new Word();
            w.start();
        }
        if ("Excel".equals(args[0])) {
            Excel e = new Excel();
            e.start();
        }
    }
}
</pre>
<p>显然这个类是无法编译成功的，因为不存在Word类和Excel类。为了让它通过编译并运行起来，我们需要实现Word类和Excel类。</p>
<p>但是运行时，Word一定用得上吗？Excel一定用得上吗？</p>
<p>比如说，我们实现了Word，实际运行时我们只会用Word不会用Excel，Office类还是无法通过编译。静态加载要求在编译时就加载所有可能用到的类。</p>
<p>夸张点说，如果我们有100个功能，只要有其中一个功能没有实现，其他99个功能就全都用不了。这是不科学的。因此我们考虑使用动态加载。我们将程序改成这样：</p>
<pre class="brush: java">
class OfficeBetter {
    public static void main(String[] args) {
        try {
            Class c = Class.forName(args[0]);
            OfficeAble oa = (OfficeAble) c.newInstance();
            oa.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</pre>
<p>这个类就可以通过编译。而且对比与原本的Office类，如果未来需要加入Outlook、PowerPoint、Visio等新功能，Office类需要修改其源代码，而OfficeBetter完全不需要修改。因此在设计上，OfficeBetter更加优越，只需要为所有的Office软件制定一个共同的标准（接口、父类）OfficeAble并在OfficeAble内声明start即可，这种设计也符合工厂模式。</p>

<h2 class="jump">第三节：获取方法信息</h2>
<pre class="brush: java">
public class ClassDemo2 {
    public static void main(String[] args[]) {
        // Java中有很多的关键字也有class变量
        Class c1 = int.class;
        Class c2 = String.class;
        Class c3 = void.class;
        Class c4 = double.class;
        Class c5 = Double.class; // 注意 c4 != c5
        
        System.out.println(c1.getName()); // 获取类的全称
        System.out.println(c1.getSimpleName()); // 不包含包名的类名称
    }
}
</pre>

<pre class="brush: java">
public class ClassUtil {
    /**
     * 打印类的信息，包括类的成员函数、成员变量
     * @param obj 打印该对象所属类的信息
     */
    public static void printClassMessage(Object obj) {
        // 首先获取类的类类型
        Class c = obj.getClass();
        // 获取类的名称
        System.out.println("类的名称是：" + c.getName());
        // Method类，一个成员方法就是一个Method对象
        // getMethods()方法获取的是所有的public的函数，包括从父类继承而来的
        // getDeclaredMethods() 获取的是所有该类自己生命的方法，无论访问权限
        Method[] ms = c.getMethods();
        for (Method m : ms) {
            Class returnType = m.getReturnType();
            System.out.print(returnType.getName() + " "); // 得到方法的返回值类型的类类型
            System.out.print(m.getName() + "("); // 得到方法名
            // 获取参数类型
            Class[] paramTypes = m.getParameterTypes();
            for (Class cc : paramTypes) {
                System.out.print(cc.getName() + ", ");
            }
            System.out.println(")");
        }
        
        // 成员变量也是对象，是java.lang.reflect.Field类的对象
        // Field类封装了关于成员变量的操作
        // getFields()方法获取的是所有的public的成员变量的信息
        // getDeclaredFields()获取的是该类自己声明的成员变量的信息
        Fields[] fs = c.getDeclaredFields();
        for (Field f : fs) {
            // 得到成员变量的类型的类类型
            Class fieldType = f.getType();
            String typeName = fieldType.getName();
            String fieldName = field.getName(); // 得到成员变量的名称
            System.out.println(typeName + " " + fieldName);
        }
        
        // 打印对象的构造函数的信息
        // 构造函数也是对象，是java.lang.Constructor类的实例对象
        // Constructor类中封装了构造函数的信息
        Constructor[] cs = c.getDeclaredConstructors();
        for (Constructor cc : cs) {
            System.out.print(cc.getSimpleName() + "(");
            Class[] paramTypes = cc.getParameterTypes();
            for (Class cl: cs) {
                System.out.print(cl.getName() + ", ");
            }
            System.out.println(")");
        }
        
    }
}
</pre>
<p>除去上述提到的API，Class类还包含很多其他的方法，详情请查询Class类、Method类、Constructor类、Field类相关API文档</p>
<h2 class="jump">第四节：方法反射的基本操作</h2>
<ul>
    <li>如何获取某个方法：方法的名称和方法的参数列表才能唯一决定某个方法
    <li>方法反射的操作：method.invoke(对象, 参数列表)
</ul>
<pre class="brush: java">
public class MethodDemo1 {
    public static void main(String[] args) {
        // 要获取print(int, int)方法，首先要获取类的信息
        A a1 = new A();
        Class c = a1.getClass();
        // 获取方法名称和参数列表
        Method m = c.getMethod("print", new Class[]{int.class, int.class});
            // 也可以是 c.getMethod("print", int.class, int.class);
            // 这里会抛出异常，出于简化省略了try/catch块
        
        // 方法的反射操作是用m对象来进行方法调用，和a1.print调用的效果相同
        Object o = m.invoke(a1, new Object[]{10, 20});
        // 也可以是 m.invoke(a1, 10, 20);
            // 返回的是方法的返回值，如果是void则返回null
    }
}

class A {
    public void print(int a, int b) {
        System.out.println(a + b);
    }
    public void print(String a, String b) {
        System.out.println(a.toUpperCase() + ", " b.toUpperCase());
    }
}
</pre>
        <!-- and end here -->
    </div>
    </div>
    <script src="/js/bootstrap.min.js"></script>
    <script src="/js/mrdai.js"></script>
    <script>SyntaxHighlighter.all()</script>
</body>
</html>